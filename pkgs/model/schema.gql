# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AggregateUser {
    count(
        cursor: UserWhereUniqueInput
        orderBy: UserOrderByInput
        skip: Int
        take: Int
        where: UserWhereInput
    ): Int!
}

type BatchPayload {
    count: Int!
}

input IntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: Int
    notIn: [Int!]
}

type Mutation {
    createUser(data: UserCreateInput!): User!
    deleteManyUser(where: UserWhereInput): BatchPayload!
    deleteUser(where: UserWhereUniqueInput!): User
    updateManyUser(
        data: UserUpdateManyMutationInput!
        where: UserWhereInput
    ): BatchPayload!
    updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
    upsertUser(
        create: UserCreateInput!
        update: UserUpdateInput!
        where: UserWhereUniqueInput!
    ): User!
}

input NameUserIdCompoundUniqueInput {
    name: String!
    userId: Int!
}

input NullableIntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: Int
    notIn: [Int!]
}

input NullableStringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: String
    notIn: [String!]
    startsWith: String
}

enum OrderByArg {
    asc
    desc
}

type Query {
    aggregateUser: AggregateUser!
    user(where: UserWhereUniqueInput!): User
    users(
        cursor: UserWhereUniqueInput
        orderBy: UserOrderByInput
        skip: Int
        take: Int
        where: UserWhereInput
    ): [User!]!
}

type Step {
    expected: String
    id: Int!
    key: String
    kind: StepKind!
    selector: String
    tests(
        cursor: TestWhereUniqueInput
        orderBy: TestOrderByInput
        skip: Int
        take: Int
        where: TestWhereInput
    ): [Test!]
    url: String
    User: User
    userId: Int
    value: String
}

input StepCreateManyWithoutTestsInput {
    connect: [StepWhereUniqueInput!]
    create: [StepCreateWithoutTestsInput!]
}

input StepCreateManyWithoutUserInput {
    connect: [StepWhereUniqueInput!]
    create: [StepCreateWithoutUserInput!]
}

input StepCreateWithoutTestsInput {
    expected: String
    key: String
    kind: StepKind!
    selector: String
    url: String
    User: UserCreateOneWithoutStepsInput
    value: String
}

input StepCreateWithoutUserInput {
    expected: String
    key: String
    kind: StepKind!
    selector: String
    tests: TestCreateManyWithoutStepsInput
    url: String
    value: String
}

input StepFilter {
    every: StepWhereInput
    none: StepWhereInput
    some: StepWhereInput
}

enum StepKind {
    assertText
    assertVisibility
    click
    go
    hover
    key
    screenshot
    set
}

input StepKindFilter {
    equals: StepKind
    in: [StepKind!]
    not: StepKind
    notIn: [StepKind!]
}

input StepOrderByInput {
    expected: OrderByArg
    id: OrderByArg
    key: OrderByArg
    kind: OrderByArg
    selector: OrderByArg
    url: OrderByArg
    userId: OrderByArg
    value: OrderByArg
}

input StepScalarWhereInput {
    AND: [StepScalarWhereInput!]
    expected: NullableStringFilter
    id: IntFilter
    key: NullableStringFilter
    kind: StepKindFilter
    NOT: [StepScalarWhereInput!]
    OR: [StepScalarWhereInput!]
    selector: NullableStringFilter
    tests: TestFilter
    url: NullableStringFilter
    userId: NullableIntFilter
    value: NullableStringFilter
}

input StepUpdateManyDataInput {
    expected: String
    id: Int
    key: String
    kind: StepKind
    selector: String
    url: String
    value: String
}

input StepUpdateManyWithoutTestsInput {
    connect: [StepWhereUniqueInput!]
    create: [StepCreateWithoutTestsInput!]
    delete: [StepWhereUniqueInput!]
    deleteMany: [StepScalarWhereInput!]
    disconnect: [StepWhereUniqueInput!]
    set: [StepWhereUniqueInput!]
    update: [StepUpdateWithWhereUniqueWithoutTestsInput!]
    updateMany: [StepUpdateManyWithWhereNestedInput!]
    upsert: [StepUpsertWithWhereUniqueWithoutTestsInput!]
}

input StepUpdateManyWithoutUserInput {
    connect: [StepWhereUniqueInput!]
    create: [StepCreateWithoutUserInput!]
    delete: [StepWhereUniqueInput!]
    deleteMany: [StepScalarWhereInput!]
    disconnect: [StepWhereUniqueInput!]
    set: [StepWhereUniqueInput!]
    update: [StepUpdateWithWhereUniqueWithoutUserInput!]
    updateMany: [StepUpdateManyWithWhereNestedInput!]
    upsert: [StepUpsertWithWhereUniqueWithoutUserInput!]
}

input StepUpdateManyWithWhereNestedInput {
    data: StepUpdateManyDataInput!
    where: StepScalarWhereInput!
}

input StepUpdateWithoutTestsDataInput {
    expected: String
    id: Int
    key: String
    kind: StepKind
    selector: String
    url: String
    User: UserUpdateOneWithoutStepsInput
    value: String
}

input StepUpdateWithoutUserDataInput {
    expected: String
    id: Int
    key: String
    kind: StepKind
    selector: String
    tests: TestUpdateManyWithoutStepsInput
    url: String
    value: String
}

input StepUpdateWithWhereUniqueWithoutTestsInput {
    data: StepUpdateWithoutTestsDataInput!
    where: StepWhereUniqueInput!
}

input StepUpdateWithWhereUniqueWithoutUserInput {
    data: StepUpdateWithoutUserDataInput!
    where: StepWhereUniqueInput!
}

input StepUpsertWithWhereUniqueWithoutTestsInput {
    create: StepCreateWithoutTestsInput!
    update: StepUpdateWithoutTestsDataInput!
    where: StepWhereUniqueInput!
}

input StepUpsertWithWhereUniqueWithoutUserInput {
    create: StepCreateWithoutUserInput!
    update: StepUpdateWithoutUserDataInput!
    where: StepWhereUniqueInput!
}

input StepWhereInput {
    AND: [StepWhereInput!]
    expected: NullableStringFilter
    id: IntFilter
    key: NullableStringFilter
    kind: StepKindFilter
    NOT: [StepWhereInput!]
    OR: [StepWhereInput!]
    selector: NullableStringFilter
    tests: TestFilter
    url: NullableStringFilter
    User: UserWhereInput
    userId: NullableIntFilter
    value: NullableStringFilter
}

input StepWhereUniqueInput {
    id: Int
}

input StringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: String
    notIn: [String!]
    startsWith: String
}

type Tag {
    id: Int!
    name: String!
    Test: Test
    testId: Int
    user: User!
    userId: Int!
}

input TagCreateManyWithoutTestInput {
    connect: [TagWhereUniqueInput!]
    create: [TagCreateWithoutTestInput!]
}

input TagCreateManyWithoutUserInput {
    connect: [TagWhereUniqueInput!]
    create: [TagCreateWithoutUserInput!]
}

input TagCreateWithoutTestInput {
    name: String!
    user: UserCreateOneWithoutTagsInput!
}

input TagCreateWithoutUserInput {
    name: String!
    Test: TestCreateOneWithoutTagsInput
}

input TagFilter {
    every: TagWhereInput
    none: TagWhereInput
    some: TagWhereInput
}

input TagOrderByInput {
    id: OrderByArg
    name: OrderByArg
    testId: OrderByArg
    userId: OrderByArg
}

input TagScalarWhereInput {
    AND: [TagScalarWhereInput!]
    id: IntFilter
    name: StringFilter
    NOT: [TagScalarWhereInput!]
    OR: [TagScalarWhereInput!]
    testId: NullableIntFilter
    userId: IntFilter
}

input TagUpdateManyDataInput {
    id: Int
    name: String
}

input TagUpdateManyWithoutTestInput {
    connect: [TagWhereUniqueInput!]
    create: [TagCreateWithoutTestInput!]
    delete: [TagWhereUniqueInput!]
    deleteMany: [TagScalarWhereInput!]
    disconnect: [TagWhereUniqueInput!]
    set: [TagWhereUniqueInput!]
    update: [TagUpdateWithWhereUniqueWithoutTestInput!]
    updateMany: [TagUpdateManyWithWhereNestedInput!]
    upsert: [TagUpsertWithWhereUniqueWithoutTestInput!]
}

input TagUpdateManyWithoutUserInput {
    connect: [TagWhereUniqueInput!]
    create: [TagCreateWithoutUserInput!]
    delete: [TagWhereUniqueInput!]
    deleteMany: [TagScalarWhereInput!]
    disconnect: [TagWhereUniqueInput!]
    set: [TagWhereUniqueInput!]
    update: [TagUpdateWithWhereUniqueWithoutUserInput!]
    updateMany: [TagUpdateManyWithWhereNestedInput!]
    upsert: [TagUpsertWithWhereUniqueWithoutUserInput!]
}

input TagUpdateManyWithWhereNestedInput {
    data: TagUpdateManyDataInput!
    where: TagScalarWhereInput!
}

input TagUpdateWithoutTestDataInput {
    id: Int
    name: String
    user: UserUpdateOneRequiredWithoutTagsInput
}

input TagUpdateWithoutUserDataInput {
    id: Int
    name: String
    Test: TestUpdateOneWithoutTagsInput
}

input TagUpdateWithWhereUniqueWithoutTestInput {
    data: TagUpdateWithoutTestDataInput!
    where: TagWhereUniqueInput!
}

input TagUpdateWithWhereUniqueWithoutUserInput {
    data: TagUpdateWithoutUserDataInput!
    where: TagWhereUniqueInput!
}

input TagUpsertWithWhereUniqueWithoutTestInput {
    create: TagCreateWithoutTestInput!
    update: TagUpdateWithoutTestDataInput!
    where: TagWhereUniqueInput!
}

input TagUpsertWithWhereUniqueWithoutUserInput {
    create: TagCreateWithoutUserInput!
    update: TagUpdateWithoutUserDataInput!
    where: TagWhereUniqueInput!
}

input TagWhereInput {
    AND: [TagWhereInput!]
    id: IntFilter
    name: StringFilter
    NOT: [TagWhereInput!]
    OR: [TagWhereInput!]
    Test: TestWhereInput
    testId: NullableIntFilter
    user: UserWhereInput
    userId: IntFilter
}

input TagWhereUniqueInput {
    id: Int
    name_userId: NameUserIdCompoundUniqueInput
}

type Test {
    id: Int!
    name: String!
    steps(
        cursor: StepWhereUniqueInput
        orderBy: StepOrderByInput
        skip: Int
        take: Int
        where: StepWhereInput
    ): [Step!]
    tags(
        cursor: TagWhereUniqueInput
        orderBy: TagOrderByInput
        skip: Int
        take: Int
        where: TagWhereInput
    ): [Tag!]
    user: User!
    userId: Int!
}

input TestCreateManyWithoutStepsInput {
    connect: [TestWhereUniqueInput!]
    create: [TestCreateWithoutStepsInput!]
}

input TestCreateManyWithoutUserInput {
    connect: [TestWhereUniqueInput!]
    create: [TestCreateWithoutUserInput!]
}

input TestCreateOneWithoutTagsInput {
    connect: TestWhereUniqueInput
    create: TestCreateWithoutTagsInput
}

input TestCreateWithoutStepsInput {
    name: String!
    tags: TagCreateManyWithoutTestInput
    user: UserCreateOneWithoutTestsInput!
}

input TestCreateWithoutTagsInput {
    name: String!
    steps: StepCreateManyWithoutTestsInput
    user: UserCreateOneWithoutTestsInput!
}

input TestCreateWithoutUserInput {
    name: String!
    steps: StepCreateManyWithoutTestsInput
    tags: TagCreateManyWithoutTestInput
}

input TestFilter {
    every: TestWhereInput
    none: TestWhereInput
    some: TestWhereInput
}

input TestOrderByInput {
    id: OrderByArg
    name: OrderByArg
    userId: OrderByArg
}

input TestScalarWhereInput {
    AND: [TestScalarWhereInput!]
    id: IntFilter
    name: StringFilter
    NOT: [TestScalarWhereInput!]
    OR: [TestScalarWhereInput!]
    steps: StepFilter
    tags: TagFilter
    userId: IntFilter
}

input TestUpdateManyDataInput {
    id: Int
    name: String
}

input TestUpdateManyWithoutStepsInput {
    connect: [TestWhereUniqueInput!]
    create: [TestCreateWithoutStepsInput!]
    delete: [TestWhereUniqueInput!]
    deleteMany: [TestScalarWhereInput!]
    disconnect: [TestWhereUniqueInput!]
    set: [TestWhereUniqueInput!]
    update: [TestUpdateWithWhereUniqueWithoutStepsInput!]
    updateMany: [TestUpdateManyWithWhereNestedInput!]
    upsert: [TestUpsertWithWhereUniqueWithoutStepsInput!]
}

input TestUpdateManyWithoutUserInput {
    connect: [TestWhereUniqueInput!]
    create: [TestCreateWithoutUserInput!]
    delete: [TestWhereUniqueInput!]
    deleteMany: [TestScalarWhereInput!]
    disconnect: [TestWhereUniqueInput!]
    set: [TestWhereUniqueInput!]
    update: [TestUpdateWithWhereUniqueWithoutUserInput!]
    updateMany: [TestUpdateManyWithWhereNestedInput!]
    upsert: [TestUpsertWithWhereUniqueWithoutUserInput!]
}

input TestUpdateManyWithWhereNestedInput {
    data: TestUpdateManyDataInput!
    where: TestScalarWhereInput!
}

input TestUpdateOneWithoutTagsInput {
    connect: TestWhereUniqueInput
    create: TestCreateWithoutTagsInput
    delete: Boolean
    disconnect: Boolean
    update: TestUpdateWithoutTagsDataInput
    upsert: TestUpsertWithoutTagsInput
}

input TestUpdateWithoutStepsDataInput {
    id: Int
    name: String
    tags: TagUpdateManyWithoutTestInput
    user: UserUpdateOneRequiredWithoutTestsInput
}

input TestUpdateWithoutTagsDataInput {
    id: Int
    name: String
    steps: StepUpdateManyWithoutTestsInput
    user: UserUpdateOneRequiredWithoutTestsInput
}

input TestUpdateWithoutUserDataInput {
    id: Int
    name: String
    steps: StepUpdateManyWithoutTestsInput
    tags: TagUpdateManyWithoutTestInput
}

input TestUpdateWithWhereUniqueWithoutStepsInput {
    data: TestUpdateWithoutStepsDataInput!
    where: TestWhereUniqueInput!
}

input TestUpdateWithWhereUniqueWithoutUserInput {
    data: TestUpdateWithoutUserDataInput!
    where: TestWhereUniqueInput!
}

input TestUpsertWithoutTagsInput {
    create: TestCreateWithoutTagsInput!
    update: TestUpdateWithoutTagsDataInput!
}

input TestUpsertWithWhereUniqueWithoutStepsInput {
    create: TestCreateWithoutStepsInput!
    update: TestUpdateWithoutStepsDataInput!
    where: TestWhereUniqueInput!
}

input TestUpsertWithWhereUniqueWithoutUserInput {
    create: TestCreateWithoutUserInput!
    update: TestUpdateWithoutUserDataInput!
    where: TestWhereUniqueInput!
}

input TestWhereInput {
    AND: [TestWhereInput!]
    id: IntFilter
    name: StringFilter
    NOT: [TestWhereInput!]
    OR: [TestWhereInput!]
    steps: StepFilter
    tags: TagFilter
    user: UserWhereInput
    userId: IntFilter
}

input TestWhereUniqueInput {
    id: Int
    name_userId: NameUserIdCompoundUniqueInput
}

type User {
    email: String!
    first: String!
    id: Int!
    last: String!
    password: String!
    steps(
        cursor: StepWhereUniqueInput
        orderBy: StepOrderByInput
        skip: Int
        take: Int
        where: StepWhereInput
    ): [Step!]
    tags(
        cursor: TagWhereUniqueInput
        orderBy: TagOrderByInput
        skip: Int
        take: Int
        where: TagWhereInput
    ): [Tag!]
    tests(
        cursor: TestWhereUniqueInput
        orderBy: TestOrderByInput
        skip: Int
        take: Int
        where: TestWhereInput
    ): [Test!]
}

input UserCreateInput {
    email: String!
    first: String!
    last: String!
    password: String!
    steps: StepCreateManyWithoutUserInput
    tags: TagCreateManyWithoutUserInput
    tests: TestCreateManyWithoutUserInput
}

input UserCreateOneWithoutStepsInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutStepsInput
}

input UserCreateOneWithoutTagsInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutTagsInput
}

input UserCreateOneWithoutTestsInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutTestsInput
}

input UserCreateWithoutStepsInput {
    email: String!
    first: String!
    last: String!
    password: String!
    tags: TagCreateManyWithoutUserInput
    tests: TestCreateManyWithoutUserInput
}

input UserCreateWithoutTagsInput {
    email: String!
    first: String!
    last: String!
    password: String!
    steps: StepCreateManyWithoutUserInput
    tests: TestCreateManyWithoutUserInput
}

input UserCreateWithoutTestsInput {
    email: String!
    first: String!
    last: String!
    password: String!
    steps: StepCreateManyWithoutUserInput
    tags: TagCreateManyWithoutUserInput
}

input UserOrderByInput {
    email: OrderByArg
    first: OrderByArg
    id: OrderByArg
    last: OrderByArg
    password: OrderByArg
}

input UserUpdateInput {
    email: String
    first: String
    id: Int
    last: String
    password: String
    steps: StepUpdateManyWithoutUserInput
    tags: TagUpdateManyWithoutUserInput
    tests: TestUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
    email: String
    first: String
    id: Int
    last: String
    password: String
}

input UserUpdateOneRequiredWithoutTagsInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutTagsInput
    update: UserUpdateWithoutTagsDataInput
    upsert: UserUpsertWithoutTagsInput
}

input UserUpdateOneRequiredWithoutTestsInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutTestsInput
    update: UserUpdateWithoutTestsDataInput
    upsert: UserUpsertWithoutTestsInput
}

input UserUpdateOneWithoutStepsInput {
    connect: UserWhereUniqueInput
    create: UserCreateWithoutStepsInput
    delete: Boolean
    disconnect: Boolean
    update: UserUpdateWithoutStepsDataInput
    upsert: UserUpsertWithoutStepsInput
}

input UserUpdateWithoutStepsDataInput {
    email: String
    first: String
    id: Int
    last: String
    password: String
    tags: TagUpdateManyWithoutUserInput
    tests: TestUpdateManyWithoutUserInput
}

input UserUpdateWithoutTagsDataInput {
    email: String
    first: String
    id: Int
    last: String
    password: String
    steps: StepUpdateManyWithoutUserInput
    tests: TestUpdateManyWithoutUserInput
}

input UserUpdateWithoutTestsDataInput {
    email: String
    first: String
    id: Int
    last: String
    password: String
    steps: StepUpdateManyWithoutUserInput
    tags: TagUpdateManyWithoutUserInput
}

input UserUpsertWithoutStepsInput {
    create: UserCreateWithoutStepsInput!
    update: UserUpdateWithoutStepsDataInput!
}

input UserUpsertWithoutTagsInput {
    create: UserCreateWithoutTagsInput!
    update: UserUpdateWithoutTagsDataInput!
}

input UserUpsertWithoutTestsInput {
    create: UserCreateWithoutTestsInput!
    update: UserUpdateWithoutTestsDataInput!
}

input UserWhereInput {
    AND: [UserWhereInput!]
    email: StringFilter
    first: StringFilter
    id: IntFilter
    last: StringFilter
    NOT: [UserWhereInput!]
    OR: [UserWhereInput!]
    password: StringFilter
    steps: StepFilter
    tags: TagFilter
    tests: TestFilter
}

input UserWhereUniqueInput {
    email: String
    id: Int
}
