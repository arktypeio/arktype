"use strict";(self.webpackChunk_re_docs=self.webpackChunk_re_docs||[]).push([[213],{6383:(e,t,n)=>{n.d(t,{kt:()=>m});var a=n(1672);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(n),k=r,c=m["".concat(d,".").concat(k)]||m[k]||s[k]||i;return n?a.createElement(c,l(l({ref:t},u),{},{components:n})):a.createElement(c,l({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8939:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>g,contentTitle:()=>k,default:()=>f,frontMatter:()=>m,metadata:()=>c,toc:()=>N});var a=n(6383),r=Object.defineProperty,i=Object.defineProperties,l=Object.getOwnPropertyDescriptors,o=Object.getOwnPropertySymbols,d=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,s=(e,t,n)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,u=(e,t)=>{for(var n in t||(t={}))d.call(t,n)&&s(e,n,t[n]);if(o)for(var n of o(t))p.call(t,n)&&s(e,n,t[n]);return e};const m={sidebar_position:1},k="Model",c={unversionedId:"model/intro",id:"model/intro",title:"Model",description:"@re-/model",source:"@site/docs/model/intro.mdx",sourceDirName:"model",slug:"/model/intro",permalink:"/docs/model/intro",editUrl:"https://github.com/re-do/re-po/edit/main/pkgs/docs/docs/model/intro.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"model"},g={},N=[{value:"What&#39;s a model?",id:"whats-a-model",level:2},{value:"Installation",id:"installation",level:2},{value:"Definition",id:"definition",level:2},{value:"Space",id:"space",level:2},{value:"Declaration",id:"declaration",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Objects",id:"objects",level:3},{value:"Map",id:"map",level:4},{value:"Tuple",id:"tuple",level:4},{value:"Strings",id:"strings",level:3},{value:"Keywords",id:"keywords",level:4},{value:"Literals",id:"literals",level:4},{value:"Expressions",id:"expressions",level:4},{value:"Primitives",id:"primitives",level:3},{value:"Contributing",id:"contributing",level:2},{value:"About Redo",id:"about-redo",level:2},{value:"License",id:"license",level:2}],y={toc:N};function f(e){var t,n=e,{components:r}=n,s=((e,t)=>{var n={};for(var a in e)d.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&o)for(var a of o(e))t.indexOf(a)<0&&p.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=u(u({},y),s),i(t,l({components:r,mdxType:"MDXLayout"}))),(0,a.kt)("h1",u({},{id:"model"}),"Model"),(0,a.kt)("div",{align:"center"},(0,a.kt)("img",{src:"/img/logo.svg",width:"400",alt:"Redo Logo"}),(0,a.kt)("h1",null,"@re-/model")),(0,a.kt)("div",{align:"center"},(0,a.kt)("p",null,"Type-first validation from editor to runtime \ud83e\udded")),(0,a.kt)("h2",u({},{id:"whats-a-model"}),"What's a model?"),(0,a.kt)("p",null,"A model is a way to create universal types for your JS/TS values. From one definition, you get all the benefits of ",(0,a.kt)("a",u({parentName:"p"},{href:"https://github.com/microsoft/TypeScript"}),"TypeScript")," at compile time and a validator like ",(0,a.kt)("a",u({parentName:"p"},{href:"https://github.com/jquense/yup"}),"Yup")," or ",(0,a.kt)("a",u({parentName:"p"},{href:"https://github.com/sideway/joi"}),"JOI")," at runtime."),(0,a.kt)("h2",u({},{id:"installation"}),"Installation"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"npm install @re-/model")),(0,a.kt)("p",null,"(feel free to substitute ",(0,a.kt)("inlineCode",{parentName:"p"},"yarn"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"pnpm"),", et al.)"),(0,a.kt)("p",null,"If you're using TypeScript, you'll need at least ",(0,a.kt)("inlineCode",{parentName:"p"},"4.4"),"."),(0,a.kt)("h2",u({},{id:"definition"}),"Definition"),(0,a.kt)("p",null,"This snippet will give you an idea of ",(0,a.kt)("inlineCode",{parentName:"p"},"@re-/model")," syntax, but the best way to get a feel for it is in a live editor. Try messing around with the ",(0,a.kt)("inlineCode",{parentName:"p"},"user")," model in ",(0,a.kt)("a",u({parentName:"p"},{href:"https://TODO:updatelink"}),"our sandbox")," or paste it in your own editor and see how the type hints help guide you in the right direction."),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ts"}),'import { define } from "@re-/model"\n\n// Most common TypeScript expressions just work...\nconst user = define({\n    name: {\n        first: "string",\n        middle: "string?",\n        last: "string"\n    },\n    age: "number",\n    interests: "string[]|null"\n})\n\n// If you\'re using TypeScript, you can create your type...\ntype User = typeof user.type\n\n// And it will be totally equivalent to...\ntype RedundantUserDeclaration = {\n    name: {\n        first: string\n        middle?: string\n        last: string\n    }\n    age: number\n    interests: string[] | null\n}\n\n// But a model can also validate your data at runtime...\nconst fetchUser = () => {\n    return {\n        name: {\n            first: "Reed",\n            last: "Doe"\n        },\n        age: 28,\n        interests: undefined\n    }\n}\n\n// Will throw: "At path interests, undefined is not assignable to any of string[]|null."\nuser.validate(fetchUser())\n')),(0,a.kt)("h2",u({},{id:"space"}),"Space"),(0,a.kt)("p",null,"Your models can reference each other or themselves using a ",(0,a.kt)("strong",{parentName:"p"},"space"),". ",(0,a.kt)("a",u({parentName:"p"},{href:"https://TODO:updatelink"}),"Try it out"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ts"}),'import { compile } from "@re-/model"\n\nconst mySpace = compile({\n    user: {\n        name: "string",\n        friends: "user[]",\n        groups: "group[]"\n    },\n    group: {\n        name: "string",\n        description: "string",\n        members: "user[]"\n    }\n})\n\n// Typescript types can be extracted like this\ntype User = typeof mySpace.user.type\n\n// Will throw: "At path friends/groups/0, \'Type Enjoyers\' is not assignable\n// to {name: string, description: string, members: user[]}"\nmySpace.user.validate({\n    name: "Devin Aldai",\n    friends: [\n        {\n            name: "Devin Olnyt",\n            friends: [], // :(\n            groups: ["Type Enjoyers"]\n        }\n    ],\n    groups: []\n})\n\n// Once you\'ve created a space, you can use it to create new models\n// that reference existing models like "user"\nconst community = mySpace.model({\n    users: "user[]",\n    groups: "group[]",\n    population: "number"\n})\n')),(0,a.kt)("h2",u({},{id:"declaration"}),"Declaration"),(0,a.kt)("p",null,"If you prefer to split your space definitions across one or more files, you'll want to use a ",(0,a.kt)("strong",{parentName:"p"},"declaration"),". ",(0,a.kt)("a",u({parentName:"p"},{href:"https://TODO:updatelink"}),"Try it out"),"."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"index.ts")),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ts"}),'import { declare } from "@re-/model"\n\n// Declare the names in your space allows\nconst declared = declare("user", "group")\n\n// A declaration\'s "define" prop can be used anywhere to create\n// a definition that allows references to other declared names\nexport const { define } = declared\n\nimport { userDef } from "./user"\nimport { groupDef } from "./group"\n\n// Type error: "Declared types \'group\' were never defined."\nconst badSpace = declared.compile(userDef)\n\n// Creates a space identical to that of "Creating your first space"\nconst mySpace = declared.compile(userDef, groupDef)\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"user.ts")),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ts"}),'import { define } from "./index"\n\nconst badUserDef = define.user({\n    name: "string",\n    friends: "user[]",\n    // Type error: "Unable to determine the type of \'grop\'"\n    groups: "grop[]"\n})\n\nexport const userDef = define.user({\n    name: "string",\n    friends: "user[]",\n    groups: "group[]"\n})\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"group.ts")),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ts"}),'import { define } from "./index"\n\nexport const groupDef = define.group({\n    name: "string",\n    description: "string",\n    members: "user[]"\n})\n')),(0,a.kt)("h2",u({},{id:"syntax"}),"Syntax"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"@re-/model")," supports all of TypeScript's built-in types and a lot of its most common type definition syntax. The following sections outline the kinds of definitions you can use in your models."),(0,a.kt)("p",null,"If the TS syntax you want to use is not listed here, feel free to create an issue summarizing your use case. Our model is easy to extend, so you might just see it an upcoming release \ud83c\udf81"),(0,a.kt)("h3",u({},{id:"objects"}),"Objects"),(0,a.kt)("p",null,"Object definitions are sets of keys or indices corresponding to string, primitive, or nested object definitions."),(0,a.kt)("h4",u({},{id:"map"}),"Map"),(0,a.kt)("p",null,"Map definitions are represented using the familiar object literal syntax."),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ts"}),'const foo = model({\n    key: "string?",\n    anotherKey: ["unknown", { re: "\'model\'|\'state\'|\'test\'" }]\n})\n\n// Equivalent TS\ntype FooToo = {\n    key?: string\n    anotherKey: [\n        unknown,\n        {\n            re: "model" | "state" | "test"\n        }\n    ]\n}\n')),(0,a.kt)("h4",u({},{id:"tuple"}),"Tuple"),(0,a.kt)("p",null,"Tuple definitions are useful for fixed-length lists and are represented as array literals."),(0,a.kt)("pre",null,(0,a.kt)("code",u({parentName:"pre"},{className:"language-ts"}),'const bar = model([\n    "true|null",\n    { coords: ["number", "number"], piOus: [3, 1, 4] }\n])\n\n// Equivalent TS\ntype BarAgain = [\n    true | null,\n    {\n        coords: [number, number]\n        piOus: [3, 1, 4]\n    }\n]\n')),(0,a.kt)("h3",u({},{id:"strings"}),"Strings"),(0,a.kt)("p",null,"String definitions are strings constructed from the following fragment types:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Builtins, including keywords like ",(0,a.kt)("inlineCode",{parentName:"li"},'"number"')," and literals like ",(0,a.kt)("inlineCode",{parentName:"li"},"\"'redo'\"")),(0,a.kt)("li",{parentName:"ul"},"Aliases like ",(0,a.kt)("inlineCode",{parentName:"li"},'"user"')," or ",(0,a.kt)("inlineCode",{parentName:"li"},'"group"')," that have been defined in your space"),(0,a.kt)("li",{parentName:"ul"},"Expressions consisting of one or more string definitions modified by an operator, like ",(0,a.kt)("inlineCode",{parentName:"li"},'"user | number"')," or ",(0,a.kt)("inlineCode",{parentName:"li"},'"group[]?"'))),(0,a.kt)("h4",u({},{id:"keywords"}),"Keywords"),(0,a.kt)("p",null,"All TypeScript keywords that can be used to represent a type are valid definitions. Each of the following string definitions maps directly to its corresponding TS type:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Keyword"),(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Notes"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"any"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"unknown"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Behaves like ",(0,a.kt)("inlineCode",{parentName:"td"},"any")," when used in validation.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"never"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Will always throw an error when used in validation.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"undefined"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"void"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Behaves like ",(0,a.kt)("inlineCode",{parentName:"td"},"undefined")," when used in validation")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"object"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"null"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"function"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"string"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"number"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"bigint"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"boolean"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"true"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"false"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"symbol"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}))))),(0,a.kt)("h4",u({},{id:"literals"}),"Literals"),(0,a.kt)("p",null,"Literals are used to specify a ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"bigint")," type constrained to an exact value."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Literal"),(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Syntax"),(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Examples"),(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Notes"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"string"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"\"'T'\"")," or ",(0,a.kt)("inlineCode",{parentName:"td"},"'\"T\"'")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"\"'redo'\"")," or ",(0,a.kt)("inlineCode",{parentName:"td"},"'\"WithDoubleQuotes\"'")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Spaces are not currently supported and will be ignored.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"number"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"T"'),", where T is a numeric value"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"5"')," or ",(0,a.kt)("inlineCode",{parentName:"td"},'"-7.3"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Though validation checks for the literal's exact value, TypeScript widens its type to ",(0,a.kt)("inlineCode",{parentName:"td"},"number"),". To avoid this behavior, use a number primitive.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"bigint"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"Tn"'),", where T is an integer"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},'"0n"')," or ",(0,a.kt)("inlineCode",{parentName:"td"},'"-999n"')),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Though validation checks for the literal's exact value, TypeScript widens its type to ",(0,a.kt)("inlineCode",{parentName:"td"},"bigint"),". To avoid this behavior, use a bigint primitive.")))),(0,a.kt)("p",null,"While ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean")," values could also be considered literals, they are modeled as keywords since, unlike other literal types, they can can be defined as a finite set (i.e. ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),")."),(0,a.kt)("h4",u({},{id:"expressions"}),"Expressions"),(0,a.kt)("p",null,"Expressions are a set of syntactic patterns that can be applied to one or more nested string definitions to modify the type they represent. Unless otherwise noted, expressions can be applied to any valid string definition, including other expressions."),(0,a.kt)("p",null,"The following table is ordered by relative precedence in the event that a definition matches multiple patterns. For example, the definition ",(0,a.kt)("inlineCode",{parentName:"p"},'"string|boolean[]"')," would be interpreted as either a ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," or a list of ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean"),' since "Or" applies before "List." Parenthetical grouping is not yet supported, but can be emulated by adding the desired grouping to a space and referencing its alias.'),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Exrpession"),(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Pattern"),(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Examples"),(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Notes"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Optional"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"T?")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"function?")," ",(0,a.kt)("br",null),(0,a.kt)("inlineCode",{parentName:"td"},"boolean[]?")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Adds ",(0,a.kt)("inlineCode",{parentName:"td"},"undefined")," as a possible value. When used in an Object type, also makes the corresponding key optional.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Arrow Function"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"(T1,T2,...)=>T3")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"(string,boolean[])=>void")," ",(0,a.kt)("br",null),(0,a.kt)("inlineCode",{parentName:"td"},"()=>object")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"At runtime, falls back to validating that a value is of type ",(0,a.kt)("inlineCode",{parentName:"td"},"function"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Union"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"T1\\|T2\\|T3\\|...")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"false\\|string")," ",(0,a.kt)("br",null),(0,a.kt)("inlineCode",{parentName:"td"},"string\\|number\\|boolean[]")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Acts just like TypeScript's union operator (",(0,a.kt)("inlineCode",{parentName:"td"},"\\|"),")")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"List"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"T[]")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"string[]")," ",(0,a.kt)("br",null),(0,a.kt)("inlineCode",{parentName:"td"},"number[][]")),(0,a.kt)("td",u({parentName:"tr"},{align:null}))))),(0,a.kt)("p",null,"Spaces are ignored when parsing expressions, so feel free to use whatever format you find most readable."),(0,a.kt)("h3",u({},{id:"primitives"}),"Primitives"),(0,a.kt)("p",null,"Any definition that is neither a string nor an object is considered a primitive and models a type that allows only its exact value. All primitive definitions correspond to an equivalent string definition, so whether you use them often comes down to stylistic preference, though there are some noted circumstances in which they allow TypeScript to infer narrower types than their string equivalents."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Definition Type"),(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Examples"),(0,a.kt)("th",u({parentName:"tr"},{align:null}),"Notes"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"undefined"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"undefined")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Requires compiler option ",(0,a.kt)("inlineCode",{parentName:"td"},'"strictNullChecks"')," or ",(0,a.kt)("inlineCode",{parentName:"td"},'"strict"')," set to ",(0,a.kt)("inlineCode",{parentName:"td"},"true")," in your ",(0,a.kt)("inlineCode",{parentName:"td"},"tsconfig.json"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"null"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"null")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"Requires compiler option ",(0,a.kt)("inlineCode",{parentName:"td"},'"strictNullChecks"')," or ",(0,a.kt)("inlineCode",{parentName:"td"},'"strict"')," set to ",(0,a.kt)("inlineCode",{parentName:"td"},"true")," in your ",(0,a.kt)("inlineCode",{parentName:"td"},"tsconfig.json"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"boolean"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"true")," ",(0,a.kt)("br",null)," ",(0,a.kt)("inlineCode",{parentName:"td"},"false")),(0,a.kt)("td",u({parentName:"tr"},{align:null}))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"number"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"0")," ",(0,a.kt)("br",null)," ",(0,a.kt)("inlineCode",{parentName:"td"},"32.33")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"TS infers the exact value of ",(0,a.kt)("inlineCode",{parentName:"td"},"number")," primitives, while string literals are always widened to ",(0,a.kt)("inlineCode",{parentName:"td"},"number"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",u({parentName:"tr"},{align:null}),"bigint"),(0,a.kt)("td",u({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"99n")," ",(0,a.kt)("br",null)," ",(0,a.kt)("inlineCode",{parentName:"td"},"-100n")),(0,a.kt)("td",u({parentName:"tr"},{align:null}),"TS infers the exact value of ",(0,a.kt)("inlineCode",{parentName:"td"},"bigint")," primitives, while string literals are always widened to ",(0,a.kt)("inlineCode",{parentName:"td"},"bigint"),". ",(0,a.kt)("br",null)," Requires a target of ES2020 or higher.")))),(0,a.kt)("h2",u({},{id:"contributing"}),"Contributing"),(0,a.kt)("p",null,"If you're interested in contributing to ",(0,a.kt)("inlineCode",{parentName:"p"},"@re-/model"),"..."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Thank you \ud83d\ude0d We'll do everything we can to make this as straightforward as possible, regardless of your experience."),(0,a.kt)("li",{parentName:"ol"},"Check out our ",(0,a.kt)("a",u({parentName:"li"},{href:"https://github.com/re-do/re-po/blob/main/CONTRIBUTING.md"}),"guide")," to get started!")),(0,a.kt)("h2",u({},{id:"about-redo"}),"About Redo"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"@re-/model")," is part of a set of devtools designed to help you navigate the JS/TS ecosystem and get back to doing what you love. Learn more ",(0,a.kt)("a",u({parentName:"p"},{href:"https://github.com/re-do/re-po"}),"at the root of this repo"),"."),(0,a.kt)("h2",u({},{id:"license"}),"License"),(0,a.kt)("p",null,"This project is licensed under the terms of the\n",(0,a.kt)("a",u({parentName:"p"},{href:"https://github.com/re-do/re-po/blob/main/LICENSE"}),"MIT license"),"."))}f.isMDXComponent=!0}}]);