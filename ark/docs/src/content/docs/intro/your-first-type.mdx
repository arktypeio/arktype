---
title: Your first type
sidebar:
  order: 2
---

import { TypeBenchmarksGraph } from "../../../components/BenchmarksGraph.tsx"

## Define

If you already know TypeScript, congratulations- you just learned most of ArkType's syntax ðŸŽ‰

```ts
// @noErrors
import { type } from "arktype"

const user = type({
	name: "string",
	platform: "'android' | 'ios'",
	"versions?": "(number | string)[]"
})

// extract the type if needed
type User = typeof user.infer
// ---cut-start---
// this empty line prevents the source syntax highlighting from breaking

// ---cut-end---
```

If you make a mistake, don't worry- every definition gets the autocomplete and validation you're used to from your editor, all within TypeScript's type system.

:::note[Will ArkType crash my TypeScript server?]
Thousands of hours of optimization have gone into making validating native type syntax not just feasible, but often much faster than alternatives.

<details>
	<summary>Editor performance compared to Zod</summary>
	<TypeBenchmarksGraph />
</details>
:::

## Compose

Let's say we want to move `platform` and `version` from our original type to a new `device` property.

```ts
import { type } from "arktype"

const user = type({
	name: "string",
	// nested definitions don't need to be wrapped
	device: {
		platform: "'android' | 'ios'",
		"versions?": "(number | string)[]"
	}
})
```

If we want to decouple `device` from `user`, we just move it to its own type and reference it.

```ts
import { type } from "arktype"

const device = type({
	platform: "'android' | 'ios'",
	"versions?": "(number | string)[]"
})

const user = type({
	name: "string",
	device: device
})
```

## Validate

At runtime, we can pass arbitrary data to our new type and get back either a validated `User`

```ts
import { type } from "arktype"

const user = type({
	name: "string",
	// nested definitions don't need to be wrapped
	device: {
		platform: "'android' | 'ios'",
		"versions?": "(number | string)[]"
	}
})
// ---cut---
// Validators return typed data or clear, customizable errors.
export const out = user({
	name: "Alan Turing",
	device: {
		// errors.summary: "device/platform must be 'android' or 'ios' (was 'enigma')"
		platform: "enigma"
	}
})

if (out instanceof type.errors) {
	// a clear, user-ready error message, even for complex unions and intersections
	console.log(out.summary)
} else {
	// your valid data!
	console.log(out)
}
```
