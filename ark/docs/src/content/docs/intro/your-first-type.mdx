---
title: Your first type
sidebar:
  order: 2
---

import { TypeBenchmarksGraph } from "../../../components/BenchmarksGraph.tsx"

## Definitions

If you already know TypeScript, congratulations! You just learned most of ArkType's syntax ðŸŽ‰

```ts
// @noErrors
import { type } from "arktype"

const user = type({
	name: "string",
	platform: "'android' | 'ios'",
	"version?": "number | string"
})
```

If you make a mistake, don't worry- every definition gets the autocomplete and validation you're used to in your editor, all from within TypeScript's type system.

:::note[Will ArkType crash my TypeScript server?]
A huge amount of optimization has gone into making validating native type syntax not just feasible, but often much faster than alternatives.

<details>
	<summary>Editor performance compared to Zod</summary>
	<TypeBenchmarksGraph />
</details>
:::

## Composition

One of the best things about type syntax is how well it composes.

Let's say we want to move `platform` and `version` from our original type to a new `device` property.

```ts
import { type } from "arktype"

const user = type({
	name: "string",
	// nested definitions don't need to be wrapped
	device: {
		platform: "'android' | 'ios'",
		"version?": "number | string"
	}
})
```

If we want to decouple `device` from `user`, we just move it to its own type and reference it.

```ts
const device = type({
	platform: "'android' | 'ios'",
	"version?": "number | string"
})

const user = type({
	name: "string",
	device: device
})
```

```ts
// Validators return typed data or clear, customizable errors.
export const out = user({
	name: "Alan Turing",
	device: {
		// errors.summary: "device/platform must be 'android' or 'ios' (was 'enigma')"
		platform: "enigma"
	}
})

if (out instanceof type.errors) {
	// a clear, user-ready error message, even for complex unions and intersections
	console.log(out.summary)
} else {
	// your valid data!
	console.log(out)
}
```

```

```
