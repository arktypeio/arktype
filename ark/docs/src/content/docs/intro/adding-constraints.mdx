---
title: Adding Constraints
sidebar:
  order: 3
---

:::caution[Under Construction]
We're still working on our new docs, as evidenced by the fact that they are not done.

Check back soon for more!
:::

TypeScript is extremely versatile for representing types like `string` or `number`, but what about `email` or `integer less than 100`?

In ArkType, conditions that narrow a type beyond its **basis** are called **constraints**.

Constraints are a first-class citizen of ArkType. They are fully composable with TypeScript's built-in operators and governed by the same underlying principles of set-theory.

In other words, **they just work**.

## Define

Let's create a new `contact` Type that enforces our example constraints.

```ts
import { type } from "arktype"
// ---cut---
// hover to see the type-level representation
const contact = type({
	// many common constraints are available as built-in keywords
	email: "email",
	// others can be written as type-safe expressions
	score: "integer < 100"
})

// if you need the TS type, just infer it out as normal
type Contact = typeof contact.infer
// ---cut-start---
// this empty line prevents the source syntax highlighting from breaking

// ---cut-end---
```

## Compose

Imagine we want to define a new Type representing a non-empty list of `Contact`.

While the expression syntax we've been using is ideal for creating new types, chaining is a great way to refine or transform existing ones.

```ts
import { type, type Type } from "arktype"

const _contact = type({
	email: "email",
	score: "integer < 100"
})

type _Contact = typeof _contact.t

interface Contact extends _Contact {}

export const contact: Type<Contact> = _contact
// ---cut---
// a non-empty list of Contact
const contacts = contact.array().atLeastLength(1)
```

## Narrow

Structured constraints like divisors and ranges will only take us so far. Luckily, they integrate seamlessly with whatever custom validation logic you need.

```ts
import { type, type Type } from "arktype"

const _contact = type({
	email: "email",
	score: "integer < 100"
})

type _Contact = typeof _contact.t

interface Contact extends _Contact {}

export const contact: Type<Contact> = _contact

const contacts = contact.array().atLeastLength(1)

const extractDuplicates = (arr: typeof contacts.infer) =>
	Object.values(Object.groupBy(arr, contact => contact.email)).flatMap(
		contactsWithEmail =>
			contactsWithEmail && contactsWithEmail.length > 1 ?
				contactsWithEmail[0].email
			:	[]
	)
// ---cut---
const uniqueContacts = contacts.narrow((arr, ctx) => {
	// get a list of the duplicate emails
	const duplicates = extractDuplicates(arr)

	// return true if there are no duplicates
	if (duplicates.length === 0) return true

	// or false with a custom error message listing the duplicates
	return ctx.invalid({
		expected: "an array of unique contacts",
		actual: `duplicated by ${duplicates}`
	})
})
```
