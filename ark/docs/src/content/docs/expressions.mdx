---
title: Expressions
---

import { Tabs } from "@astrojs/starlight/components"
import SyntaxTab from "../../components/SyntaxTab.astro"

### Intersection

üöß Coming soon ‚Ñ¢Ô∏èüöß

### Union

All unions are automatically discriminated to optimize check time and error message clarity.

<Tabs>
	<SyntaxTab string>

```ts
const unions = type({
	key: "string | number"
})
```

    </SyntaxTab>

    <SyntaxTab fluent>

```ts
const unions = type({
	key: type.string.or(type.number)
})
```

    </SyntaxTab>

    <SyntaxTab tuple>

```ts
const unions = type({
	key: ["string", "|", { name: "string" }]
})
```

    </SyntaxTab>

    <SyntaxTab spread>

```ts
const unions = type({
	key: type("string", "|", { name: "string" })
})
```

    </SyntaxTab>

</Tabs>

### Brand

üöß Coming soon ‚Ñ¢Ô∏èüöß

### Narrow

üöß Coming soon ‚Ñ¢Ô∏èüöß

### Morph

üöß Coming soon ‚Ñ¢Ô∏èüöß

### Unit

While embedded [literal syntax](/literals) is usually ideal for defining exact primitive values, `===` and `type.unit` can be helpful for referencing a non-serialiazable value like a `symbol` from your type.

<Tabs>

    <SyntaxTab fluent>

```ts
const mySymbol = Symbol()

const exactValue = type.unit(mySymbol)
```

    </SyntaxTab>

    <SyntaxTab tuple>

```ts
const mySymbol = Symbol()

const exactValue = type(["===", mySymbol])
```

    </SyntaxTab>

    <SyntaxTab spread>

```ts
const mySymbol = Symbol()

const exactValue = type("===", mySymbol)
```

    </SyntaxTab>

</Tabs>

### Enumerated

`type.enumerated` defines a type based on a list of allowed values. It is semantically equivalent to `type.unit` if provided a single value.

<Tabs>

    <SyntaxTab fluent>

```ts
const mySymbol = Symbol()

const exactValueFromSet = type.enumerated(1337, true, mySymbol)
```

    </SyntaxTab>

    <SyntaxTab tuple>

```ts
const mySymbol = Symbol()

const exactValueFromSet = type(["===", 1337, true, mySymbol])
```

    </SyntaxTab>

    <SyntaxTab spread>

```ts
const mySymbol = Symbol()

const exactValueFromSet = type("===", 1337, true, mySymbol)
```

    </SyntaxTab>

</Tabs>

### Meta

üöß Coming soon ‚Ñ¢Ô∏èüöß

### Cast

üöß Coming soon ‚Ñ¢Ô∏èüöß

### Parenthetical

By default, ArkType's operators follow the same precedence as TypeScript's. Also like in TypeScript, this can be overridden by wrapping an expression in parentheses.

```ts
// hover to see the distinction!
const groups = type({
	stringOrArrayOfNumbers: "string | number[]",
	arrayOfStringsOrNumbers: "(string | number)[]"
})
```

### this

`this` is a special keyword that can be used to create a recursive type referencing the root of the current definition.

```ts
const fetchGift = async () => null
// ---cut---
const disappointingGift = type({ label: "string", "box?": "this" })
const myGift = disappointingGift.assert(await fetchGift())

// hover me
const chainable = myGift.box?.box?.label
```

Unlike its TypeScript counterpart, ArkType's `this` is not limited to interfaces. It can also be used from within a tuple expression.

```ts
// boxes now expects an array of our gift object
const disappointingGifts = type({ label: "string", boxes: "this" }, "[]")
```

Referencing `this` from within a scope will result in a ParseError. For similar behavior within a scoped definition, just reference the alias by name:

```ts
const types = scope({
	disappointingGift: {
		label: "string",
		// Resolves correctly to the root of the current type
		"box?": "disappointingGift"
	}
}).export()
```
