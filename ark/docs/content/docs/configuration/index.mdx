---
title: Configuration
---

ArkType aims to have great defaults supports four levels of configuration:

<table>
  <thead>
    <tr>
      <th>Level</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Defaults</td>
      <td>Built-in defaults that apply unless overridden.</td>
      <td>n/a</td>
    </tr>
    <tr>
      <td>Global</td>
      <td>Use <code>configure()</code> to set options once.</td>
      <td>
```ts
import { configure } from "arktype/config"
configure({ clone: structuredClone, onUndeclaredKey: "reject" })
```
     </td>
    </tr>
    <tr>
      <td>Scope</td>
      <td>Pass a config object when creating or extending a Scope.</td>
      <td>
```ts
const myScope = scope({})
```
      </td>
    </tr>
    <tr>
      <td>Type</td>
      <td>Configure options directly on a Type to affect only that Typeâ€™s behavior.</td>
      <td>

```ts
import { type } from "arktype"

const t = type("number % 2").configure({})
```

      </td>
    </tr>

  </tbody>
</table>

Some options only make sense at specific levels. For example, the "clone" option is global or scope-level, while "meta" is typically applied at the type-level.

### Errors

### Clone

By default, before a [morph](/docs/intro/morphs-and-more) is applied, ArkType will deeply clone the original input value with a built-in `deepClone` function that tries to make reasonable assumptions about preserving prototypes etc. The implementation of `deepClone` can be found [here](https://github.com/arktypeio/arktype/blob/main/ark/util/clone.ts).

You can provide an alternate clone implementation to the `clone` config option.

```ts
import { configure } from "arktype/config"

configure({ clone: structuredClone })

import { type } from "arktype"

// will now create a new object using structuredClone
const userForm = type({
	age: "string.numeric.parse"
})
```

To mutate the input object directly, you can set the `clone` config option to `false`.

```ts
import { configure } from "arktype/config"

configure({ clone: false })

import { type } from "arktype"

const userForm = type({
	age: "string.numeric.parse"
})

const formData = {
	age: "42"
}

const out = userForm(formData)

// the original object's age key is now a number
console.log(formData.age)
```

### onUndeclaredKey

Like TypeScript, ArkType defaults to ignoring undeclared keys during validation. However, it also supports two additional behaviors:

- `"ignore"` (default): Allow undeclared keys on input, preserve them on output
- `"delete"`: Allow undeclared keys on input, delete them before returning output
- `"reject"`: Reject input with undeclared keys

These behaviors can be associated with individual Types via the builtin `"+"` syntax (see [those docs](/docs/objects/properties-undeclared) for more on how they work). You can also change the default globally:

```ts
import { configure } from "arktype/config"

configure({ onUndeclaredKey: "delete" })

import { type } from "arktype"

const userForm = type({
	name: "string"
})

// out is now { name: "Alice" }
const out = userForm({
	name: "Alice",
	age: "42"
})
```

### jitless

By default, when a `Type` is instantiated, ArkType will precompile optimized validation logic that will run when the type is invoked. This behavior is disabled by default in environments that don't support `new Function`, e.g. Cloudflare Workers.

If you'd like to opt out of it for another reason, you can set the `jitless` config option to `true`.

```ts
import { configure } from "arktype/config"

// IMPORTANT: make sure you import from the "arktype/config" entry point
// and invoke configure before importing anything else from ArkType
// unless you want the builtin types to be precompiled

configure({ jitless: true })

import { type } from "arktype"

// will not be precompiled
const myObject = type({
	foo: "string"
})
```

### custom

```ts
// add this anywhere in your project
declare global {
	interface ArkEnv {
		meta(): {
			// meta properties should always be optional
			secretIngredient?: string
		}
	}
}

// now types you define can specify and access your metadata
const mrPingsSecretIngredientSoup = type({
	broth: "'miso' | 'vegetable'",
	ingredients: "string[]"
}).configure({ secretIngredient: "nothing!" })
```
