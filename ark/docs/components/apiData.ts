import type { ApiDocsByGroup } from "../../repo/docgen.ts"

/** THIS FILE IS AUTOGENERATED FROM ark/repo/docgen.ts **/
// prettier-ignore
export const apiDocsByGroup: ApiDocsByGroup = {
    "Type": [
        {
            "group": "Type",
            "name": "$",
            "summary": [
                {
                    "kind": "reference",
                    "value": "Scope"
                },
                {
                    "kind": "text",
                    "value": "in which chained methods are parsed"
                }
            ],
            "notes": []
        },
        {
            "group": "Type",
            "name": "infer",
            "summary": [
                {
                    "kind": "text",
                    "value": "type of output this returns"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "ü•∏ inference-only property that will be `undefined` at runtime"
                    }
                ]
            ],
            "example": "const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\ntype ParsedNumber = typeof parseNumber.infer // number"
        },
        {
            "group": "Type",
            "name": "inferIn",
            "summary": [
                {
                    "kind": "text",
                    "value": "type of input this allows"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "ü•∏ inference-only property that will be `undefined` at runtime"
                    }
                ]
            ],
            "example": "const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\ntype UnparsedNumber = typeof parseNumber.inferIn // string"
        },
        {
            "group": "Type",
            "name": "json",
            "summary": [
                {
                    "kind": "text",
                    "value": "internal JSON representation"
                }
            ],
            "notes": []
        },
        {
            "group": "Type",
            "name": "toJsonSchema",
            "summary": [
                {
                    "kind": "text",
                    "value": "generate a JSON Schema"
                }
            ],
            "notes": []
        },
        {
            "group": "Type",
            "name": "meta",
            "summary": [
                {
                    "kind": "text",
                    "value": "metadata like custom descriptions and error messages"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ type"
                    },
                    {
                        "kind": "link",
                        "url": "https://arktype.io/docs/configuration#custom",
                        "value": "can be customized"
                    },
                    {
                        "kind": "text",
                        "value": "for your project"
                    }
                ]
            ]
        },
        {
            "group": "Type",
            "name": "description",
            "summary": [
                {
                    "kind": "text",
                    "value": "human-readable English description"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ works best for primitive values"
                    }
                ]
            ],
            "example": "const n = type(\"0 < number <= 100\")\nconsole.log(n.description) // positive and at most 100"
        },
        {
            "group": "Type",
            "name": "expression",
            "summary": [
                {
                    "kind": "text",
                    "value": "syntax string similar to native TypeScript"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ works well for both primitives and structures"
                    }
                ]
            ],
            "example": "const loc = type({ coords: [\"number\", \"number\"] })\nconsole.log(loc.expression) // { coords: [number, number] }"
        },
        {
            "group": "Type",
            "name": "assert",
            "summary": [
                {
                    "kind": "text",
                    "value": "validate and return transformed data or throw"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ sugar to avoid checking for"
                    },
                    {
                        "kind": "reference",
                        "value": "type.errors"
                    },
                    {
                        "kind": "text",
                        "value": "if they are unrecoverable"
                    }
                ]
            ],
            "example": "const criticalPayload = type({\n    superImportantValue: \"string\"\n})\n// throws TraversalError: superImportantValue must be a string (was missing)\nconst data = criticalPayload.assert({ irrelevantValue: \"whoops\" })\nconsole.log(data.superImportantValue) // valid output can be accessed directly"
        },
        {
            "group": "Type",
            "name": "allows",
            "summary": [
                {
                    "kind": "text",
                    "value": "check input without applying morphs"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ good for stuff like filtering that doesn't benefit from detailed errors"
                    }
                ]
            ],
            "example": "const numeric = type(\"number | bigint\")\n// [0, 2n]\nconst numerics = [0, \"one\", 2n].filter(numeric.allows)"
        },
        {
            "group": "Type",
            "name": "configure",
            "summary": [
                {
                    "kind": "text",
                    "value": "add metadata to shallow references"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚ö†Ô∏è does not affect error messages within properties of an object"
                    }
                ]
            ],
            "example": "const notOdd = type(\"number % 2\").configure({ description: \"not odd\" })\n// all constraints at the root are affected\nconst odd = notOdd(3) // must be not odd (was 3)\nconst nonNumber = notOdd(\"two\") // must be not odd (was \"two\")\n\nconst notOddBox = type({\n   // we should have referenced notOdd or added meta here\n   notOdd: \"number % 2\",\n// but instead chained from the root object\n}).configure({ description: \"not odd\" })\n// error message at path notOdd is not affected\nconst oddProp = notOddBox({ notOdd: 3 }) // notOdd must be even (was 3)\n// error message at root is affected, leading to a misleading description\nconst nonObject = notOddBox(null) // must be not odd (was null)"
        },
        {
            "group": "Type",
            "name": "describe",
            "summary": [
                {
                    "kind": "text",
                    "value": "add description to shallow references"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "üîó equivalent to `.configure({ description })` (see"
                    },
                    {
                        "kind": "reference",
                        "value": "configure"
                    },
                    {
                        "kind": "text",
                        "value": ")"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚ö†Ô∏è does not affect error messages within properties of an object"
                    }
                ]
            ],
            "example": "const aToZ = type(/^a.*z$/).describe(\"a string like 'a...z'\")\nconst good = aToZ(\"alcatraz\") // \"alcatraz\"\n// ArkErrors: must be a string like 'a...z' (was \"albatross\")\nconst badPattern = aToZ(\"albatross\")"
        },
        {
            "group": "Type",
            "name": "onUndeclaredKey",
            "summary": [
                {
                    "kind": "text",
                    "value": "apply undeclared key behavior"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "- `\"ignore\"` (default) - allow and preserve extra properties"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "- `\"reject\"` - disallow extra properties"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "- `\"delete\"` - clone and remove extra properties from output"
                    }
                ]
            ]
        },
        {
            "group": "Type",
            "name": "onDeepUndeclaredKey",
            "summary": [
                {
                    "kind": "text",
                    "value": "deeply apply undeclared key behavior"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "- `\"ignore\"` (default) - allow and preserve extra properties"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "- `\"reject\"` - disallow extra properties"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "- `\"delete\"` - clone and remove extra properties from output"
                    }
                ]
            ]
        },
        {
            "group": "Type",
            "name": "from",
            "summary": [
                {
                    "kind": "text",
                    "value": "alias for"
                },
                {
                    "kind": "reference",
                    "value": "assert"
                },
                {
                    "kind": "text",
                    "value": "with typed input"
                }
            ],
            "notes": [],
            "example": "const t = type({ foo: \"string\" });\n// TypeScript: foo must be a string (was 5)\nconst data = t.from({ foo: 5 });"
        },
        {
            "group": "Type",
            "name": "brand",
            "summary": [
                {
                    "kind": "text",
                    "value": "add a compile-time brand to output"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "ü•∏ inference-only function that does nothing runtime"
                    }
                ]
            ],
            "example": "const palindrome = type(\"string\")\n    .narrow(s => s === [...s].reverse().join(\"\"))\n    .brand(\"palindrome\")\n// Brand<string, \"palindrome\">\nconst out = palindrome.assert(\"racecar\")"
        },
        {
            "group": "Type",
            "name": "array",
            "summary": [
                {
                    "kind": "text",
                    "value": "an array of this"
                }
            ],
            "notes": [],
            "example": "// Type<{ rebmun: number }[]>\nconst t = type({ rebmun: \"number\" }).array();"
        },
        {
            "group": "Type",
            "name": "optional",
            "summary": [
                {
                    "kind": "link",
                    "url": "https://arktype.io/docs/objects#properties-optional",
                    "value": "optional definition"
                }
            ],
            "notes": [
                [
                    {
                        "kind": "noteStart",
                        "value": "‚ö†Ô∏è unlike most other methods, this creates a definition rather than a Type (read why)"
                    }
                ]
            ],
            "example": "const prop = type({ foo: \"number\" })\n// Type<{ bar?: { foo: number } }>\nconst obj = type({ bar: prop.optional() })"
        },
        {
            "group": "Type",
            "name": "default",
            "summary": [
                {
                    "kind": "link",
                    "url": "https://arktype.io/docs/objects#properties-defaultable",
                    "value": "defaultable definition"
                }
            ],
            "notes": [
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ object defaults can be returned from a function"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚ö†Ô∏è throws if the default value is not allowed"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚ö†Ô∏è unlike most other methods, this creates a definition rather than a Type (read why)"
                    }
                ]
            ],
            "example": "// Type<{ count: Default<number, 0> }>\nconst state = type({ count: type.number.default(0) })\nconst prop = type({ nested: \"boolean\" })\nconst forObj = type({\n    key: nested.default(() => ({ nested: false }))\n})"
        },
        {
            "group": "Type",
            "name": "filter",
            "summary": [
                {
                    "kind": "text",
                    "value": "apply a predicate function to input"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚ö†Ô∏è the behavior of"
                    },
                    {
                        "kind": "reference",
                        "value": "narrow"
                    },
                    {
                        "kind": "text",
                        "value": ", this method's output counterpart, is usually more desirable"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ most useful for morphs with input types that are re-used externally"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "ü•∏"
                    },
                    {
                        "kind": "link",
                        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates",
                        "value": "Type predicates"
                    },
                    {
                        "kind": "text",
                        "value": "can be used as casts"
                    }
                ]
            ],
            "example": "const stringifyUser = type({ name: \"string\" }).pipe(user => JSON.stringify(user))\nconst stringifySafe = stringifyUser.filter(user => user.name !== \"Bobby Tables\")\n// Type<(In: `${string}Z`) => To<Date>>\nconst withPredicate = type(\"string.date.parse\").filter((s): s is `${string}Z` =>\n    s.endsWith(\"Z\")\n)"
        },
        {
            "group": "Type",
            "name": "narrow",
            "summary": [
                {
                    "kind": "text",
                    "value": "apply a predicate function to output"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ go-to fallback for validation not composable via builtin types and operators"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ runs after all other validators and morphs, if present"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "ü•∏"
                    },
                    {
                        "kind": "link",
                        "url": "https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates",
                        "value": "Type predicates"
                    },
                    {
                        "kind": "text",
                        "value": "can be used as casts"
                    }
                ]
            ],
            "example": "const palindrome = type(\"string\").narrow(s => s === [...s].reverse().join(\"\"))\n\nconst palindromicEmail = type(\"string.date.parse\").narrow((date, ctx) =>\n\t\tdate.getFullYear() === 2025 || ctx.mustBe(\"the current year\")\n)\n// Type<`${string}.tsx`>\nconst withPredicate = type(\"string\").narrow((s): s is `${string}.tsx` => /\\.tsx?$/.test(s))"
        },
        {
            "group": "Type",
            "name": "pipe",
            "summary": [
                {
                    "kind": "text",
                    "value": "pipe output through arbitrary transformations or other Types"
                }
            ],
            "notes": [],
            "example": "const user = type({ name: \"string\" })\n\n// parse a string and validate that the result as a user\nconst parseUser = type(\"string\").pipe(s => JSON.parse(s), user)"
        },
        {
            "group": "Type",
            "name": "to",
            "summary": [
                {
                    "kind": "text",
                    "value": "parse a definition as an output validator"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "üîó `to({ name: \"string\" })` is equivalent to `.pipe(type({ name: \"string\" }))`"
                    }
                ]
            ],
            "example": "// parse a string and validate that the result as a user\nconst parseUser = type(\"string\").pipe(s => JSON.parse(s)).to({ name: \"string\" })"
        },
        {
            "group": "Type",
            "name": "as",
            "summary": [
                {
                    "kind": "text",
                    "value": "cast the way this is inferred"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "ü•∏ inference-only function that does nothing runtime"
                    }
                ]
            ],
            "example": "// Type<`LEEEEEEEE${string}ROY`>\nconst leeroy = type(/^LE{8,}ROY$/).as<`LEEEEEEEE${string}ROY`>()"
        },
        {
            "group": "Type",
            "name": "and",
            "summary": [
                {
                    "kind": "text",
                    "value": "intersect the parsed Type, throwing if the result is unsatisfiable"
                }
            ],
            "notes": [],
            "example": "// Type<{ foo: number; bar: string }>\nconst t = type({ foo: \"number\" }).and({ bar: \"string\" })\n// ParseError: Intersection at foo of number and string results in an unsatisfiable type\nconst bad = type({ foo: \"number\" }).and({ foo: \"string\" })"
        },
        {
            "group": "Type",
            "name": "or",
            "summary": [
                {
                    "kind": "text",
                    "value": "union with the parsed Type"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚ö†Ô∏è a union that could apply different morphs to the same data is a ParseError ([docs](https://arktype.io/docs/expressions/union-morphs))"
                    }
                ]
            ],
            "example": "// Type<string | { box: string }>\nconst t = type(\"string\").or({ box: \"string\" })"
        },
        {
            "group": "Type",
            "name": "intersect",
            "summary": [
                {
                    "kind": "text",
                    "value": "intersect the parsed Type, returning an introspectable"
                },
                {
                    "kind": "reference",
                    "value": "Disjoint"
                },
                {
                    "kind": "text",
                    "value": "if the result is unsatisfiable"
                }
            ],
            "notes": [],
            "example": "// Type<{ foo: number; bar: string }>\nconst t = type({ foo: \"number\" }).intersect({ bar: \"string\" })\nconst bad = type(\"number > 10\").intersect(\"number < 5\")\n// logs \"Intersection of > 10 and < 5 results in an unsatisfiable type\"\nif (bad instanceof Disjoint) console.log(`${bad.summary}`)"
        },
        {
            "group": "Type",
            "name": "equals",
            "summary": [
                {
                    "kind": "text",
                    "value": "check if the parsed Type's constraints are identical"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ equal types have identical input and output constraints and transforms"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ ignores associated"
                    },
                    {
                        "kind": "reference",
                        "value": "meta"
                    },
                    {
                        "kind": "text",
                        "value": ", which does not affect the set of allowed values"
                    }
                ]
            ],
            "example": "const divisibleBy6 = type.number.divisibleBy(6).moreThan(0)\n// false (left side must also be positive)\ndivisibleBy6.equals(\"number % 6\")\n// false (right side has an additional <100 constraint)\nconsole.log(divisibleBy6.equals(\"0 < (number % 6) < 100\"))\nconst thirdTry = type(\"(number % 2) > 0\").divisibleBy(3)\n// true (types are normalized and reduced)\nconsole.log(divisibleBy6.equals(thirdTry))"
        },
        {
            "group": "Type",
            "name": "ifEquals",
            "summary": [
                {
                    "kind": "text",
                    "value": "narrow this based on an"
                },
                {
                    "kind": "reference",
                    "value": "equals"
                },
                {
                    "kind": "text",
                    "value": "check"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ ignores associated"
                    },
                    {
                        "kind": "reference",
                        "value": "meta"
                    },
                    {
                        "kind": "text",
                        "value": ", which does not affect the set of allowed values"
                    }
                ]
            ],
            "example": "const n = type.raw(`${Math.random()}`)\n// Type<0.5> | undefined\nconst ez = n.ifEquals(\"0.5\")"
        },
        {
            "group": "Type",
            "name": "extends",
            "summary": [
                {
                    "kind": "text",
                    "value": "check if this is a subtype of the parsed Type"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ a subtype must include all constraints from the base type"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ unlike"
                    },
                    {
                        "kind": "reference",
                        "value": "equals"
                    },
                    {
                        "kind": "text",
                        "value": ", additional constraints may be present"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ ignores associated"
                    },
                    {
                        "kind": "reference",
                        "value": "meta"
                    },
                    {
                        "kind": "text",
                        "value": ", which does not affect the set of allowed values"
                    }
                ]
            ],
            "example": "type.string.extends(\"unknown\") // true\ntype.string.extends(/^a.*z$/) // false"
        },
        {
            "group": "Type",
            "name": "ifExtends",
            "summary": [
                {
                    "kind": "text",
                    "value": "narrow this based on an"
                },
                {
                    "kind": "reference",
                    "value": "extends"
                },
                {
                    "kind": "text",
                    "value": "check"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ ignores associated"
                    },
                    {
                        "kind": "reference",
                        "value": "meta"
                    },
                    {
                        "kind": "text",
                        "value": ", which does not affect the set of allowed values"
                    }
                ]
            ],
            "example": "const n = type(Math.random() > 0.5 ? \"true\" : \"0\") // Type<0 | true>\nconst ez = n.ifExtends(\"boolean\") // Type<true> | undefined"
        },
        {
            "group": "Type",
            "name": "overlaps",
            "summary": [
                {
                    "kind": "text",
                    "value": "check if a value could satisfy this and the parsed Type"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚ö†Ô∏è will return true unless a"
                    },
                    {
                        "kind": "reference",
                        "value": "Disjoint"
                    },
                    {
                        "kind": "text",
                        "value": "can be proven"
                    }
                ]
            ],
            "example": "type.string.overlaps(\"string | number\") // true (e.g. \"foo\")\ntype(\"string | number\").overlaps(\"1\") // true (1)\ntype(\"number > 0\").overlaps(\"number < 0\") // false (no values exist)\n\nconst noAt = type(\"string\").narrow(s => !s.includes(\"@\"))\nnoAt.overlaps(\"string.email\") // true (no values exist, but not provable)"
        },
        {
            "group": "Type",
            "name": "extract",
            "summary": [
                {
                    "kind": "text",
                    "value": "extract branches"
                },
                {
                    "kind": "reference",
                    "value": "extend"
                },
                {
                    "kind": "text",
                    "value": "ing the parsed Type"
                }
            ],
            "notes": [],
            "example": "// Type<true | 0 | 2>\nconst t = type(\"boolean | 0 | 'one' | 2 | bigint\").extract(\"number | 0n | true\")"
        },
        {
            "group": "Type",
            "name": "exclude",
            "summary": [
                {
                    "kind": "text",
                    "value": "exclude branches"
                },
                {
                    "kind": "reference",
                    "value": "extend"
                },
                {
                    "kind": "text",
                    "value": "ing the parsed Type"
                }
            ],
            "notes": [],
            "example": "// Type<false | 'one' | bigint>\nconst t = type(\"boolean | 0 | 'one' | 2 | bigint\").exclude(\"number | 0n | true\")"
        }
    ],
    "Traversal": [
        {
            "group": "Traversal",
            "name": "path",
            "summary": [
                {
                    "kind": "text",
                    "value": "the path being validated or morphed"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ array indices represented as numbers"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚ö†Ô∏è mutated during traversal - use `path.slice(0)` to snapshot"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "üîó use"
                    },
                    {
                        "kind": "reference",
                        "value": "propString"
                    },
                    {
                        "kind": "text",
                        "value": "for a stringified version"
                    }
                ]
            ]
        },
        {
            "group": "Traversal",
            "name": "errors",
            "summary": [
                {
                    "kind": "reference",
                    "value": "ArkErrors"
                },
                {
                    "kind": "text",
                    "value": "that will be part of this traversal's finalized result"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ will always be an empty array for a valid traversal"
                    }
                ]
            ]
        },
        {
            "group": "Traversal",
            "name": "root",
            "summary": [
                {
                    "kind": "text",
                    "value": "the original value being traversed"
                }
            ],
            "notes": []
        },
        {
            "group": "Traversal",
            "name": "config",
            "summary": [
                {
                    "kind": "text",
                    "value": "configuration for this traversal"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ options can affect traversal results and error messages"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ defaults < global config < scope config"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ does not include options configured on individual types"
                    }
                ]
            ]
        },
        {
            "group": "Traversal",
            "name": "reject",
            "summary": [
                {
                    "kind": "text",
                    "value": "add an"
                },
                {
                    "kind": "reference",
                    "value": "ArkError"
                },
                {
                    "kind": "text",
                    "value": "and return `false`"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ useful for predicates like `.narrow`"
                    }
                ]
            ]
        },
        {
            "group": "Traversal",
            "name": "mustBe",
            "summary": [
                {
                    "kind": "text",
                    "value": "add an"
                },
                {
                    "kind": "reference",
                    "value": "ArkError"
                },
                {
                    "kind": "text",
                    "value": "from a description and return `false`"
                }
            ],
            "notes": [
                [],
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ useful for predicates like `.narrow`"
                    }
                ],
                [
                    {
                        "kind": "noteStart",
                        "value": "üîó equivalent to"
                    },
                    {
                        "kind": "reference",
                        "value": "reject"
                    },
                    {
                        "kind": "text",
                        "value": "({ expected })"
                    }
                ]
            ]
        },
        {
            "group": "Traversal",
            "name": "error",
            "summary": [
                {
                    "kind": "text",
                    "value": "add and return an"
                },
                {
                    "kind": "reference",
                    "value": "ArkError"
                }
            ],
            "notes": [
                [
                    {
                        "kind": "noteStart",
                        "value": "‚úÖ useful for morphs like `.pipe`"
                    }
                ]
            ]
        },
        {
            "group": "Traversal",
            "name": "hasError",
            "summary": [
                {
                    "kind": "text",
                    "value": "whether"
                },
                {
                    "kind": "reference",
                    "value": "currentBranch"
                },
                {
                    "kind": "text",
                    "value": "(or the traversal root, outside a union) has one or more errors"
                }
            ],
            "notes": []
        }
    ]
}

/** Raw ArkType definition file for editor integration **/
// prettier-ignore
export const arktypeRawDts = "import * as _ark_schema from '@ark/schema';\nimport { arkKind, BaseRoot, BaseParseContext, GenericAst, GenericParamAst, writeUnsatisfiedParameterConstraintMessage, GenericRoot, genericParamNames, resolvableReferenceIn, writeUnresolvableMessage, writeNonSubmoduleDotMessage, emptyBrandNameMessage, writeUnboundableMessage, writeUnassignableDefaultValueMessage, writeIndivisibleMessage, writeNonStructuralOperandMessage, PrivateDeclaration, writeMissingSubmoduleAccessMessage, UndeclaredKeyBehavior, writeInvalidPropertyKeyMessage, Morph, unwrapDefault, Predicate, Sequence, postfixAfterOptionalOrDefaultableMessage, BaseMappedPropInner, OptionalMappedPropInner, Prop, InclusiveNumericRangeSchema, ExclusiveNumericRangeSchema, ExactLength, InclusiveDateRangeSchema, ExclusiveDateRangeSchema, Divisor, Pattern, ArkErrors, RootSchema, BaseParseOptions, ArkSchemaScopeConfig, BaseNode, exportedNameOf, toInternalScope, NodeKind, RootKind, NodeSchema, nodeOfKind, reducibleKindOf, PreparsedNodeResolution, writeDuplicateAliasError, BaseScope, ResolvedScopeConfig, AliasDefEntry, GenericParamDef, BaseParseContextInput, JsonSchema, Disjoint, StandardSchemaV1, flatResolutionsOf, LazyGenericBody, RootModule, ArkError } from '@ark/schema';\nexport { ArkError, ArkErrors, ArkSchemaConfig, ArkSchemaScopeConfig, JsonSchema } from '@ark/schema';\nimport * as util from '@ark/util';\nimport { anyOrNever, Scanner, EscapeChar, WhitespaceChar, requireKeys, ErrorMessage, Completion, defined, Stringifiable, Hkt, array, typeToString, NumberLiteral, join, lastOf, BigintLiteral, trim as trim$1, writeMalformedNumericLiteralMessage, ErrorType, Key, show, merge, Constructor, satisfy, conform, ifEmptyObjectLiteral, Fn, Primitive, objectKindOrDomainOf, equals, requiredKeyOf, optionalKeyOf, arkKeyOf, arkIndexableOf, arkGet, toArkKey, listable, intersectUnion, inferred, JsonStructure, Callable, flattenListable, Brand, noSuggest, unset, numericStringKeyOf, isDisjoint, unionToTuple, propValueOf, Json, omit, pick, Digit, liftArray, EcmascriptObjects, PlatformObjects, isSafelyMappable, intersectArrays } from '@ark/util';\nexport { Hkt, inferred } from '@ark/util';\nimport { ArkSchemaConfig } from '@ark/schema/config';\n\ntype TypeMeta = Omit<ArkEnv.meta, \"onFail\">;\ntype TypeMetaInput = string | TypeMeta;\ntype KeywordConfig = {\n    [k in keyof Ark.flat as parseConfigurableFlatAlias<k, Ark.flat[k]>]?: TypeMetaInput;\n};\ntype parseConfigurableFlatAlias<k extends string, v> = [\n    v\n] extends [anyOrNever] ? k : v extends {\n    [arkKind]: \"generic\" | \"module\";\n} ? never : k extends `${infer prefix}.root` ? prefix : k;\ninterface ArkConfig extends ArkSchemaConfig {\n    keywords?: KeywordConfig;\n}\ndeclare const configure: <config extends ArkConfig>(config: config) => config;\ndeclare global {\n    export interface ArkEnv {\n        $(): Ark;\n    }\n}\n/**\n * This mirrors the global ArkEnv namespace as a local export. We use it instead\n * of the global internally due to a bug in twoslash that prevents `ark/docs`\n * from building if we refer to the global directly.\n *\n * If, in the future, docs can build while arktype refers to `ArkEnv.$` directly,\n * this can be removed.\n */\ndeclare namespace ArkAmbient {\n    type $ = ReturnType<ArkEnv[\"$\"]>;\n    type meta = ArkEnv.meta;\n    type prototypes = ArkEnv.prototypes;\n}\n\ntype StringifiablePrefixOperator = \"keyof\";\ndeclare const minComparators: {\n    readonly \">\": true;\n    readonly \">=\": true;\n};\ntype MinComparator = keyof typeof minComparators;\ndeclare const maxComparators: {\n    readonly \"<\": true;\n    readonly \"<=\": true;\n};\ntype MaxComparator = keyof typeof maxComparators;\ndeclare const comparators: {\n    \">\": boolean;\n    \">=\": boolean;\n    \"<\": boolean;\n    \"<=\": boolean;\n    \"==\": boolean;\n};\ntype Comparator = keyof typeof comparators;\ntype InvertedComparators = {\n    \"<\": \">\";\n    \">\": \"<\";\n    \"<=\": \">=\";\n    \">=\": \"<=\";\n    \"==\": \"==\";\n};\ntype BranchOperator = \"&\" | \"|\" | \"|>\";\ntype OpenLeftBound = {\n    limit: LimitLiteral;\n    comparator: MinComparator;\n};\ndeclare const writeUnmatchedGroupCloseMessage: <unscanned extends string>(unscanned: unscanned) => writeUnmatchedGroupCloseMessage<unscanned>;\ntype writeUnmatchedGroupCloseMessage<unscanned extends string> = `Unmatched )${unscanned extends \"\" ? \"\" : ` before ${unscanned}`}`;\ndeclare const writeUnclosedGroupMessage: <missingChar extends string>(missingChar: missingChar) => writeUnclosedGroupMessage<missingChar>;\ntype writeUnclosedGroupMessage<missingChar extends string> = `Missing ${missingChar}`;\ndeclare const writeOpenRangeMessage: <min extends LimitLiteral, comparator extends MinComparator>(min: min, comparator: comparator) => writeOpenRangeMessage<min, comparator>;\ntype writeOpenRangeMessage<min extends LimitLiteral, comparator extends MinComparator> = `Left bounds are only valid when paired with right bounds (try ...${comparator}${min})`;\ntype writeUnpairableComparatorMessage<comparator extends Comparator> = `Left-bounded expressions must specify their limits using < or <= (was ${comparator})`;\ndeclare const writeUnpairableComparatorMessage: <comparator extends Comparator>(comparator: comparator) => writeUnpairableComparatorMessage<comparator>;\ndeclare const writeMultipleLeftBoundsMessage: <openLimit extends LimitLiteral, openComparator extends MinComparator, limit extends LimitLiteral, comparator extends MinComparator>(openLimit: openLimit, openComparator: openComparator, limit: limit, comparator: comparator) => writeMultipleLeftBoundsMessage<openLimit, openComparator, limit, comparator>;\ntype writeMultipleLeftBoundsMessage<openLimit extends LimitLiteral, openComparator extends MinComparator, limit extends LimitLiteral, comparator extends MinComparator> = `An expression may have at most one left bound (parsed ${openLimit}${InvertedComparators[openComparator]}, ${limit}${InvertedComparators[comparator]})`;\n\ndeclare class ArkTypeScanner<lookahead extends string = string> extends Scanner<lookahead> {\n    shiftUntilNextTerminator(): string;\n    static terminatingChars: {\n        readonly \" \": 1;\n        readonly \"\\n\": 1;\n        readonly \"\\t\": 1;\n        readonly \"<\": 1;\n        readonly \">\": 1;\n        readonly \"=\": 1;\n        readonly \"|\": 1;\n        readonly \"&\": 1;\n        readonly \")\": 1;\n        readonly \"[\": 1;\n        readonly \"%\": 1;\n        readonly \",\": 1;\n        readonly \":\": 1;\n        readonly \"?\": 1;\n        readonly \"#\": 1;\n    };\n    static finalizingLookaheads: {\n        readonly \">\": 1;\n        readonly \",\": 1;\n        readonly \"\": 1;\n        readonly \"=\": 1;\n        readonly \"?\": 1;\n    };\n    static lookaheadIsFinalizing: (lookahead: string, unscanned: string) => lookahead is \">\" | \",\" | \"=\" | \"?\";\n}\ndeclare namespace ArkTypeScanner {\n    type lookaheadIsFinalizing<lookahead extends string, unscanned extends string> = lookahead extends \">\" ? unscanned extends `=${infer nextUnscanned}` ? nextUnscanned extends `=${string}` ? true : false : ArkTypeScanner.skipWhitespace<unscanned> extends (\"\" | `${TerminatingChar}${string}`) ? true : false : lookahead extends \"=\" ? unscanned extends `=${string}` ? false : true : lookahead extends \",\" | \"?\" ? true : false;\n    type TerminatingChar = keyof typeof ArkTypeScanner.terminatingChars;\n    type FinalizingLookahead = keyof typeof ArkTypeScanner.finalizingLookaheads;\n    type InfixToken = Comparator | \"|\" | \"&\" | \"%\" | \":\" | \"=>\" | \"|>\" | \"#\" | \"@\" | \"=\";\n    type PostfixToken = \"[]\" | \"?\";\n    type OperatorToken = InfixToken | PostfixToken;\n    type shift<lookahead extends string, unscanned extends string> = `${lookahead}${unscanned}`;\n    type shiftUntil<unscanned extends string, terminator extends string, scanned extends string = \"\"> = unscanned extends shift<infer lookahead, infer nextUnscanned> ? lookahead extends terminator ? scanned extends `${infer base}${EscapeChar}` ? shiftUntil<nextUnscanned, terminator, `${base}${lookahead}`> : [scanned, unscanned] : shiftUntil<nextUnscanned, terminator, `${scanned}${lookahead}`> : [scanned, \"\"];\n    type shiftUntilNot<unscanned extends string, nonTerminator extends string, scanned extends string = \"\"> = unscanned extends shift<infer lookahead, infer nextUnscanned> ? lookahead extends nonTerminator ? shiftUntilNot<nextUnscanned, nonTerminator, `${scanned}${lookahead}`> : [scanned, unscanned] : [scanned, \"\"];\n    type shiftUntilNextTerminator<unscanned extends string> = shiftUntil<unscanned, TerminatingChar>;\n    type skipWhitespace<unscanned extends string> = shiftUntilNot<unscanned, WhitespaceChar>[1];\n    type shiftResult<scanned extends string, unscanned extends string> = [\n        scanned,\n        unscanned\n    ];\n}\n\ntype BranchState$1 = {\n    prefixes: StringifiablePrefixOperator[];\n    leftBound: OpenLeftBound | null;\n    intersection: BaseRoot | null;\n    union: BaseRoot | null;\n    pipe: BaseRoot | null;\n};\ntype DynamicStateWithRoot = requireKeys<DynamicState, \"root\">;\ndeclare class DynamicState {\n    root: BaseRoot | undefined;\n    branches: BranchState$1;\n    finalizer: ArkTypeScanner.FinalizingLookahead | undefined;\n    groups: BranchState$1[];\n    scanner: ArkTypeScanner;\n    ctx: BaseParseContext;\n    constructor(scanner: ArkTypeScanner, ctx: BaseParseContext);\n    error(message: string): never;\n    hasRoot(): this is DynamicStateWithRoot;\n    setRoot(root: BaseRoot): void;\n    unsetRoot(): this[\"root\"];\n    constrainRoot(...args: Parameters<BaseRoot<any>[\"constrain\"]>): void;\n    finalize(finalizer: ArkTypeScanner.FinalizingLookahead): void;\n    reduceLeftBound(limit: LimitLiteral, comparator: Comparator): void;\n    finalizeBranches(): void;\n    finalizeGroup(): void;\n    addPrefix(prefix: StringifiablePrefixOperator): void;\n    applyPrefixes(): void;\n    pushRootToBranch(token: BranchOperator): void;\n    parseUntilFinalizer(): DynamicStateWithRoot;\n    parseOperator(this: DynamicStateWithRoot): void;\n    parseOperand(): void;\n    private assertRangeUnset;\n    reduceGroupOpen(): void;\n    previousOperator(): MinComparator | StringifiablePrefixOperator | ArkTypeScanner.InfixToken | undefined;\n    shiftedByOne(): this;\n}\n\ntype StaticState = {\n    root: unknown;\n    branches: BranchState;\n    groups: BranchState[];\n    finalizer: ArkTypeScanner.FinalizingLookahead | ErrorMessage | undefined;\n    scanned: string;\n    unscanned: string;\n};\ntype BranchState = {\n    prefixes: StringifiablePrefixOperator[];\n    leftBound: OpenLeftBound | undefined;\n    intersection: unknown;\n    pipe: unknown;\n    union: unknown;\n};\ndeclare namespace state {\n    type initialize<def extends string> = from<{\n        root: undefined;\n        branches: initialBranches;\n        groups: [];\n        finalizer: undefined;\n        scanned: \"\";\n        unscanned: def;\n    }>;\n    type error<message extends string> = from<{\n        root: ErrorMessage<message>;\n        branches: initialBranches;\n        groups: [];\n        finalizer: ErrorMessage<message>;\n        scanned: \"\";\n        unscanned: \"\";\n    }>;\n    type completion<text extends string> = from<{\n        root: Completion<text>;\n        branches: initialBranches;\n        groups: [];\n        finalizer: Completion<text>;\n        scanned: \"\";\n        unscanned: \"\";\n    }>;\n    type initialBranches = branchesFrom<{\n        prefixes: [];\n        leftBound: undefined;\n        intersection: undefined;\n        pipe: undefined;\n        union: undefined;\n    }>;\n    type updateScanned<previousScanned extends string, previousUnscanned extends string, updatedUnscanned extends string> = previousUnscanned extends `${infer justScanned}${updatedUnscanned}` ? `${previousScanned}${justScanned}` : previousScanned;\n    type setRoot<s extends StaticState, root, unscanned extends string = s[\"unscanned\"]> = from<{\n        root: root;\n        branches: s[\"branches\"];\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type addPrefix<s extends StaticState, prefix extends StringifiablePrefixOperator, unscanned extends string = s[\"unscanned\"]> = from<{\n        root: s[\"root\"];\n        branches: {\n            prefixes: [...s[\"branches\"][\"prefixes\"], prefix];\n            leftBound: s[\"branches\"][\"leftBound\"];\n            intersection: s[\"branches\"][\"intersection\"];\n            pipe: s[\"branches\"][\"pipe\"];\n            union: s[\"branches\"][\"union\"];\n        };\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type reduceBranch<s extends StaticState, token extends BranchOperator, unscanned extends string> = s[\"branches\"][\"leftBound\"] extends {} ? openRangeError<s[\"branches\"][\"leftBound\"]> : from<{\n        root: undefined;\n        branches: {\n            prefixes: [];\n            leftBound: undefined;\n            intersection: token extends \"&\" ? mergeToIntersection<s> : undefined;\n            union: token extends \"|\" ? mergeToUnion<s> : token extends \"|>\" ? undefined : s[\"branches\"][\"union\"];\n            pipe: token extends \"|>\" ? mergeToPipe<s> : s[\"branches\"][\"pipe\"];\n        };\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type reduceLeftBound<s extends StaticState, limit extends LimitLiteral, comparator extends Comparator, unscanned extends string> = comparator extends \"<\" | \"<=\" ? s[\"branches\"][\"leftBound\"] extends {} ? state.error<writeMultipleLeftBoundsMessage<s[\"branches\"][\"leftBound\"][\"limit\"], s[\"branches\"][\"leftBound\"][\"comparator\"], limit, InvertedComparators[comparator]>> : from<{\n        root: undefined;\n        branches: {\n            prefixes: s[\"branches\"][\"prefixes\"];\n            leftBound: {\n                limit: limit;\n                comparator: InvertedComparators[comparator];\n            };\n            intersection: s[\"branches\"][\"intersection\"];\n            pipe: s[\"branches\"][\"pipe\"];\n            union: s[\"branches\"][\"union\"];\n        };\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }> : state.error<writeUnpairableComparatorMessage<comparator>>;\n    type reduceRange<s extends StaticState, minLimit extends LimitLiteral, minComparator extends MinComparator, maxComparator extends MaxComparator, maxLimit extends LimitLiteral, unscanned extends string> = state.from<{\n        root: [minLimit, minComparator, [s[\"root\"], maxComparator, maxLimit]];\n        branches: {\n            prefixes: s[\"branches\"][\"prefixes\"];\n            leftBound: undefined;\n            intersection: s[\"branches\"][\"intersection\"];\n            pipe: s[\"branches\"][\"pipe\"];\n            union: s[\"branches\"][\"union\"];\n        };\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type reduceSingleBound<s extends StaticState, comparator extends Comparator, limit extends number | string, unscanned extends string> = state.from<{\n        root: [s[\"root\"], comparator, limit];\n        branches: {\n            prefixes: s[\"branches\"][\"prefixes\"];\n            leftBound: undefined;\n            intersection: s[\"branches\"][\"intersection\"];\n            pipe: s[\"branches\"][\"pipe\"];\n            union: s[\"branches\"][\"union\"];\n        };\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type mergeToIntersection<s extends StaticState> = s[\"branches\"][\"intersection\"] extends undefined ? mergePrefixes<s> : [s[\"branches\"][\"intersection\"], \"&\", mergePrefixes<s>];\n    type mergeToUnion<s extends StaticState> = s[\"branches\"][\"union\"] extends undefined ? mergeToIntersection<s> : [s[\"branches\"][\"union\"], \"|\", mergeToIntersection<s>];\n    type mergeToPipe<s extends StaticState> = s[\"branches\"][\"pipe\"] extends undefined ? mergeToUnion<s> : [s[\"branches\"][\"pipe\"], \"|>\", mergeToUnion<s>];\n    type mergePrefixes<s extends StaticState, remaining extends unknown[] = s[\"branches\"][\"prefixes\"]> = remaining extends [infer head, ...infer tail] ? [\n        head,\n        mergePrefixes<s, tail>\n    ] : s[\"root\"];\n    type popGroup<stack extends BranchState[], top extends BranchState> = [\n        ...stack,\n        top\n    ];\n    type finalizeGroup<s extends StaticState, unscanned extends string> = s[\"branches\"][\"leftBound\"] extends {} ? openRangeError<s[\"branches\"][\"leftBound\"]> : s[\"groups\"] extends popGroup<infer stack, infer top> ? from<{\n        groups: stack;\n        branches: top;\n        root: mergeToPipe<s>;\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }> : state.error<writeUnmatchedGroupCloseMessage<unscanned>>;\n    type reduceGroupOpen<s extends StaticState, unscanned extends string> = from<{\n        groups: [...s[\"groups\"], s[\"branches\"]];\n        branches: initialBranches;\n        root: undefined;\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type finalize<s extends StaticState, finalizer extends ArkTypeScanner.FinalizingLookahead> = s[\"groups\"] extends [] ? s[\"branches\"][\"leftBound\"] extends {} ? openRangeError<s[\"branches\"][\"leftBound\"]> : from<{\n        root: mergeToPipe<s>;\n        groups: s[\"groups\"];\n        branches: initialBranches;\n        finalizer: finalizer;\n        scanned: s[\"scanned\"];\n        unscanned: s[\"unscanned\"];\n    }> : state.error<writeUnclosedGroupMessage<\")\">>;\n    type openRangeError<range extends defined<BranchState[\"leftBound\"]>> = state.error<writeOpenRangeMessage<range[\"limit\"], range[\"comparator\"]>>;\n    type previousOperator<s extends StaticState> = s[\"branches\"][\"leftBound\"] extends {} ? s[\"branches\"][\"leftBound\"][\"comparator\"] : s[\"branches\"][\"prefixes\"] extends ([\n        ...unknown[],\n        infer tail extends string\n    ]) ? tail : s[\"branches\"][\"intersection\"] extends {} ? \"&\" : s[\"branches\"][\"union\"] extends {} ? \"|\" : undefined;\n    type scanTo<s extends StaticState, unscanned extends string> = from<{\n        root: s[\"root\"];\n        branches: s[\"branches\"];\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type from<s extends StaticState> = s;\n    type branchesFrom<b extends BranchState> = b;\n}\n\ntype StringLiteral<Text extends string = string> = DoubleQuotedStringLiteral<Text> | SingleQuotedStringLiteral<Text>;\ntype DoubleQuotedStringLiteral<Text extends string = string> = `\"${Text}\"`;\ntype SingleQuotedStringLiteral<Text extends string = string> = `'${Text}'`;\ndeclare const parseEnclosed: (s: DynamicState, enclosing: EnclosingStartToken) => void;\ntype parseEnclosed<s extends StaticState, enclosingStart extends EnclosingStartToken, unscanned extends string> = ArkTypeScanner.shiftUntil<unscanned, EnclosingTokens[enclosingStart]> extends ArkTypeScanner.shiftResult<infer scanned, infer nextUnscanned> ? nextUnscanned extends \"\" ? state.error<writeUnterminatedEnclosedMessage<scanned, enclosingStart>> : state.setRoot<s, InferredAst<enclosingStart extends EnclosingQuote ? scanned : enclosingStart extends \"/\" ? string : Date, `${enclosingStart}${scanned}${EnclosingTokens[enclosingStart]}`>, nextUnscanned extends ArkTypeScanner.shift<string, infer unscanned> ? unscanned : \"\"> : never;\ndeclare const enclosingQuote: {\n    readonly \"'\": 1;\n    readonly '\"': 1;\n};\ntype EnclosingQuote = keyof typeof enclosingQuote;\ndeclare const enclosingTokens: {\n    readonly \"d'\": \"'\";\n    readonly 'd\"': \"\\\"\";\n    readonly \"'\": \"'\";\n    readonly '\"': \"\\\"\";\n    readonly \"/\": \"/\";\n};\ntype EnclosingTokens = typeof enclosingTokens;\ntype EnclosingStartToken = keyof EnclosingTokens;\ndeclare const enclosingCharDescriptions: {\n    readonly '\"': \"double-quote\";\n    readonly \"'\": \"single-quote\";\n    readonly \"/\": \"forward slash\";\n};\ntype enclosingCharDescriptions = typeof enclosingCharDescriptions;\ndeclare const writeUnterminatedEnclosedMessage: <fragment extends string, enclosingStart extends EnclosingStartToken>(fragment: fragment, enclosingStart: enclosingStart) => writeUnterminatedEnclosedMessage<fragment, enclosingStart>;\ntype writeUnterminatedEnclosedMessage<fragment extends string, enclosingStart extends EnclosingStartToken> = `${enclosingStart}${fragment} requires a closing ${enclosingCharDescriptions[EnclosingTokens[enclosingStart]]}`;\n\ntype astToString<ast> = ast extends InferredAst | DefAst ? ast[2] : ast extends PostfixExpression<infer operator, infer operand> ? operator extends \"[]\" ? `${astToString<operand>}[]` : never : ast extends InfixExpression<infer operator, infer l, infer r> ? operator extends \"&\" | \"|\" | \"%\" | Comparator ? `${astToString<l>} ${operator} ${astToString<r>}` : never : ast extends Stringifiable ? `${ast extends bigint ? `${ast}n` : ast}` : \"...\";\ntype writeConstrainedMorphMessage<constrainedAst> = `To constrain the output of ${astToString<constrainedAst>}, pipe like myMorph.to('number > 0').\nTo constrain the input, intersect like myMorph.and('number > 0').`;\n\ntype GenericInstantiationAst<generic extends GenericAst = GenericAst, argAsts extends unknown[] = unknown[]> = [generic, \"<>\", argAsts];\ntype inferGenericInstantiation<g extends GenericAst, argAsts extends unknown[], $, args> = g[\"bodyDef\"] extends Hkt ? Hkt.apply<g[\"bodyDef\"], {\n    [i in keyof argAsts]: inferExpression<argAsts[i], $, args>;\n}> : inferDefinition<g[\"bodyDef\"], resolveScope<g[\"$\"], $>, {\n    [i in keyof g[\"names\"] & `${number}` as g[\"names\"][i]]: inferExpression<argAsts[i & keyof argAsts], resolveScope<g[\"arg$\"], $>, args>;\n}>;\ntype validateGenericInstantiation<g extends GenericAst, argAsts extends unknown[], $, args> = validateGenericArgs<g[\"paramsAst\"], argAsts, $, args, []>;\ntype validateGenericArgs<params extends array<GenericParamAst>, argAsts extends array, $, args, indices extends 1[]> = argAsts extends readonly [infer arg, ...infer argsTail] ? validateAst<arg, $, args> extends infer e extends ErrorMessage ? e : inferAstRoot<arg, $, args> extends params[indices[\"length\"]][1] ? validateGenericArgs<params, argsTail, $, args, [...indices, 1]> : ErrorMessage<writeUnsatisfiedParameterConstraintMessage<params[indices[\"length\"]][0], typeToString<params[indices[\"length\"]][1]>, astToString<arg>>> : undefined;\ntype resolveScope<g$, $> = g$ extends UnparsedScope ? $ : g$;\n\ndeclare const parseUnenclosed: (s: DynamicState) => void;\ntype parseUnenclosed<s extends StaticState, $, args> = ArkTypeScanner.shiftUntilNextTerminator<s[\"unscanned\"]> extends (ArkTypeScanner.shiftResult<infer token, infer unscanned>) ? tryResolve<s, unscanned, token, $, args> extends state.from<infer s> ? s : never : never;\ntype parseResolution<s extends StaticState, unscanned extends string, alias extends string, resolution, $, args> = resolutionToAst<alias, resolution> extends infer ast ? ast extends GenericAst ? parseGenericInstantiation<alias, ast, state.scanTo<s, unscanned>, $, args> : state.setRoot<s, ast, unscanned> : never;\ndeclare const parseGenericInstantiation: (name: string, g: GenericRoot, s: DynamicState) => BaseRoot;\ntype parseGenericInstantiation<name extends string, g extends GenericAst, s extends StaticState, $, args> = ArkTypeScanner.skipWhitespace<s[\"unscanned\"]> extends `<${infer unscanned}` ? parseGenericArgs<name, g, unscanned, $, args> extends infer result ? result extends ParsedArgs<infer argAsts, infer nextUnscanned> ? state.setRoot<s, GenericInstantiationAst<g, argAsts>, nextUnscanned> : result : never : state.error<writeInvalidGenericArgCountMessage<name, genericParamNames<g[\"paramsAst\"]>, [\n]>>;\ntype tryResolve<s extends StaticState, unscanned extends string, token extends string, $, args> = token extends keyof args ? parseResolution<s, unscanned, token, args[token], $, args> : token extends keyof $ ? parseResolution<s, unscanned, token, $[token], $, args> : `#${token}` extends keyof $ ? parseResolution<s, unscanned, token, $[`#${token}`], $, args> : token extends keyof ArkAmbient.$ ? parseResolution<s, unscanned, token, ArkAmbient.$[token], $, args> : token extends NumberLiteral<infer n> ? state.setRoot<s, InferredAst<n, token>, unscanned> : token extends (`${infer submodule extends keyof $ & string}.${infer reference}`) ? tryResolveSubmodule<token, $[submodule], reference, s, unscanned, $, args, [\n    submodule\n]> : token extends (`${infer submodule extends keyof ArkAmbient.$ & string}.${infer reference}`) ? tryResolveSubmodule<token, ArkAmbient.$[submodule], reference, s, unscanned, $, args, [\n    submodule\n]> : token extends BigintLiteral<infer b> ? state.setRoot<s, InferredAst<b, token>, unscanned> : token extends \"keyof\" ? state.addPrefix<s, \"keyof\", unscanned> : unresolvableState<s, token, $, args, []>;\ntype tryResolveSubmodule<token extends string, resolution, reference extends string, s extends StaticState, unscanned extends string, $, args, submodulePath extends string[]> = resolution extends {\n    [arkKind]: \"module\";\n} ? reference extends keyof resolution ? parseResolution<s, unscanned, token, resolution[reference], $, args> : reference extends (`${infer nestedSubmodule extends keyof resolution & string}.${infer nestedReference}`) ? tryResolveSubmodule<token, resolution[nestedSubmodule], nestedReference, s, unscanned, $, args, [\n    ...submodulePath,\n    nestedSubmodule\n]> : unresolvableState<s, reference, resolution, {}, submodulePath> : state.error<writeNonSubmoduleDotMessage<lastOf<submodulePath>>>;\n/** Provide valid completions for the current token, or fallback to an\n * unresolvable error if there are none */\ntype unresolvableState<s extends StaticState, token extends string, resolutions, args, submodulePath extends string[]> = [\n    token,\n    s[\"unscanned\"]\n] extends ([\n    \"\",\n    ArkTypeScanner.shift<\"#\", infer unscanned>\n]) ? ArkTypeScanner.shiftUntilNextTerminator<unscanned> extends (ArkTypeScanner.shiftResult<infer name, string>) ? state.error<writePrefixedPrivateReferenceMessage<name>> : never : validReferenceFromToken<token, resolutions, args, submodulePath> extends (never) ? state.error<writeUnresolvableMessage<qualifiedReference<token, submodulePath>>> : state.completion<`${s[\"scanned\"]}${qualifiedReference<validReferenceFromToken<token, resolutions, args, submodulePath>, submodulePath>}`>;\ntype qualifiedReference<reference extends string, submodulePath extends string[]> = join<[...submodulePath, reference], \".\">;\ntype validReferenceFromToken<token extends string, $, args, submodulePath extends string[]> = Extract<submodulePath[\"length\"] extends 0 ? BaseCompletions<$, args> : resolvableReferenceIn<$>, `${token}${string}`>;\ntype writeMissingRightOperandMessage<token extends string, unscanned extends string = \"\"> = `Token '${token}' requires a right operand${unscanned extends \"\" ? \"\" : ` before '${unscanned}'`}`;\ndeclare const writeMissingRightOperandMessage: <token extends string, unscanned extends string>(token: token, unscanned?: unscanned) => writeMissingRightOperandMessage<token, unscanned>;\n\ndeclare const parseOperand: (s: DynamicState) => void;\ntype parseOperand<s extends StaticState, $, args> = s[\"unscanned\"] extends (ArkTypeScanner.shift<infer lookahead, infer unscanned>) ? lookahead extends \"(\" ? state.reduceGroupOpen<s, unscanned> : lookahead extends EnclosingStartToken ? parseEnclosed<s, lookahead, unscanned> : lookahead extends WhitespaceChar ? parseOperand<state.scanTo<s, unscanned>, $, args> : lookahead extends \"d\" ? unscanned extends (ArkTypeScanner.shift<infer enclosing extends EnclosingQuote, infer nextUnscanned>) ? parseEnclosed<s, `d${enclosing}`, nextUnscanned> : parseUnenclosed<s, $, args> : parseUnenclosed<s, $, args> : state.completion<`${s[\"scanned\"]}${BaseCompletions<$, args>}`>;\n\ntype UnitLiteralKeyword = \"null\" | \"undefined\" | \"true\" | \"false\";\ntype UnitLiteral = StringLiteral | BigintLiteral | NumberLiteral | DateLiteral | UnitLiteralKeyword;\ntype ParsedDefaultableProperty = readonly [BaseRoot, \"=\", unknown];\ndeclare const parseDefault: (s: DynamicStateWithRoot) => ParsedDefaultableProperty;\ntype parseDefault<root, unscanned extends string> = trim$1<unscanned> extends infer defaultValue extends UnitLiteral ? [\n    root,\n    \"=\",\n    defaultValue\n] : ErrorMessage<writeNonLiteralDefaultMessage<trim$1<unscanned>>>;\ndeclare const writeNonLiteralDefaultMessage: <defaultDef extends string>(defaultDef: defaultDef) => writeNonLiteralDefaultMessage<defaultDef>;\ntype writeNonLiteralDefaultMessage<defaultDef extends string> = `Default value '${defaultDef}' must a literal value`;\n\ndeclare const parseBound: (s: DynamicStateWithRoot, start: ComparatorStartChar) => void;\ntype parseBound<s extends StaticState, start extends ComparatorStartChar, unscanned extends string, $, args> = shiftComparator<start, unscanned> extends infer shiftResultOrError ? shiftResultOrError extends (ArkTypeScanner.shiftResult<infer comparator extends Comparator, infer nextUnscanned>) ? s[\"root\"] extends (InferredAst<Date | number, `${infer limit extends number | DateLiteral}`>) ? state.reduceLeftBound<s, limit, comparator, nextUnscanned> : parseRightBound<state.scanTo<s, nextUnscanned>, comparator, $, args> : shiftResultOrError : never;\ntype OneCharComparator = \">\" | \"<\";\ntype ComparatorStartChar = Comparator extends `${infer char}${string}` ? char : never;\ndeclare const shiftComparator: (s: DynamicState, start: ComparatorStartChar) => Comparator;\ntype shiftComparator<start extends ComparatorStartChar, unscanned extends string> = unscanned extends `=${infer nextUnscanned}` ? [`${start}=`, nextUnscanned] : [start & OneCharComparator, unscanned];\ndeclare const parseRightBound: (s: DynamicStateWithRoot, comparator: Comparator) => void;\ntype parseRightBound<s extends StaticState, comparator extends Comparator, $, args> = parseOperand<s, $, args> extends infer nextState extends StaticState ? nextState[\"root\"] extends (InferredAst<unknown, `${infer limit extends number | DateLiteral}`>) ? s[\"branches\"][\"leftBound\"] extends {} ? comparator extends MaxComparator ? state.reduceRange<s, s[\"branches\"][\"leftBound\"][\"limit\"], s[\"branches\"][\"leftBound\"][\"comparator\"], comparator, limit, nextState[\"unscanned\"]> : state.error<writeUnpairableComparatorMessage<comparator>> : state.reduceSingleBound<s, comparator, limit, nextState[\"unscanned\"]> : state.error<writeInvalidLimitMessage<comparator, astToString<nextState[\"root\"]>, \"right\">> : never;\ndeclare const writeInvalidLimitMessage: <comparator extends Comparator, limit extends string | number, boundKind extends BoundExpressionKind>(comparator: comparator, limit: limit, boundKind: boundKind) => writeInvalidLimitMessage<comparator, limit, boundKind>;\ntype writeInvalidLimitMessage<comparator extends Comparator, limit extends string | number, boundKind extends BoundExpressionKind> = `Comparator ${boundKind extends \"left\" ? InvertedComparators[comparator] : comparator} must be ${boundKind extends \"left\" ? \"preceded\" : \"followed\"} by a corresponding literal (was ${limit})`;\ntype BoundExpressionKind = \"left\" | \"right\";\n\ndeclare const parseBrand: (s: DynamicStateWithRoot) => void;\ntype parseBrand<s extends StaticState, unscanned extends string> = ArkTypeScanner.shiftUntilNextTerminator<ArkTypeScanner.skipWhitespace<unscanned>> extends (ArkTypeScanner.shiftResult<`${infer brandName}`, infer nextUnscanned>) ? brandName extends \"\" ? state.error<emptyBrandNameMessage> : state.setRoot<s, [s[\"root\"], \"#\", brandName], nextUnscanned> : never;\n\ndeclare const parseDivisor: (s: DynamicStateWithRoot) => void;\ntype parseDivisor<s extends StaticState, unscanned extends string> = ArkTypeScanner.shiftUntilNextTerminator<ArkTypeScanner.skipWhitespace<unscanned>> extends ArkTypeScanner.shiftResult<infer scanned, infer nextUnscanned> ? scanned extends `${infer divisor extends number}` ? divisor extends 0 ? state.error<writeInvalidDivisorMessage<0>> : state.setRoot<s, [s[\"root\"], \"%\", divisor], nextUnscanned> : state.error<writeInvalidDivisorMessage<scanned>> : never;\ndeclare const writeInvalidDivisorMessage: <divisor extends string | number>(divisor: divisor) => writeInvalidDivisorMessage<divisor>;\ntype writeInvalidDivisorMessage<divisor extends string | number> = `% operator must be followed by a non-zero integer literal (was ${divisor})`;\n\ndeclare const parseOperator: (s: DynamicStateWithRoot) => void;\ntype parseOperator<s extends StaticState, $, args> = s[\"unscanned\"] extends (ArkTypeScanner.shift<infer lookahead, infer unscanned>) ? lookahead extends \"[\" ? unscanned extends ArkTypeScanner.shift<\"]\", infer nextUnscanned> ? state.setRoot<s, [s[\"root\"], \"[]\"], nextUnscanned> : state.error<incompleteArrayTokenMessage> : lookahead extends \"|\" ? unscanned extends ArkTypeScanner.shift<\">\", infer nextUnscanned> ? state.reduceBranch<s, \"|>\", nextUnscanned> : state.reduceBranch<s, lookahead, unscanned> : lookahead extends \"&\" ? state.reduceBranch<s, lookahead, unscanned> : lookahead extends \")\" ? state.finalizeGroup<s, unscanned> : ArkTypeScanner.lookaheadIsFinalizing<lookahead, unscanned> extends true ? state.finalize<state.scanTo<s, unscanned>, lookahead & ArkTypeScanner.FinalizingLookahead> : lookahead extends ComparatorStartChar ? parseBound<s, lookahead, unscanned, $, args> : lookahead extends \"%\" ? parseDivisor<s, unscanned> : lookahead extends \"#\" ? parseBrand<s, unscanned> : lookahead extends WhitespaceChar ? parseOperator<state.scanTo<s, unscanned>, $, args> : state.error<writeUnexpectedCharacterMessage<lookahead>> : state.finalize<s, \"\">;\ndeclare const writeUnexpectedCharacterMessage: <char extends string, shouldBe extends string>(char: char, shouldBe?: shouldBe) => writeUnexpectedCharacterMessage<char, shouldBe>;\ntype writeUnexpectedCharacterMessage<char extends string, shouldBe extends string = \"\"> = `'${char}' is not allowed here${shouldBe extends \"\" ? \"\" : ` (should be ${shouldBe})`}`;\ndeclare const incompleteArrayTokenMessage = \"Missing expected ']'\";\ntype incompleteArrayTokenMessage = typeof incompleteArrayTokenMessage;\n\ndeclare const parseString: (def: string, ctx: BaseParseContext) => InnerParseResult;\n/**\n * Try to parse the definition from right to left using the most common syntax.\n * This can be much more efficient for simple definitions.\n */\ntype parseString<def extends string, $, args> = def extends keyof $ ? resolutionToAst<def, $[def]> : def extends `${infer child}[]` ? child extends keyof $ ? [\n    resolutionToAst<child, $[child]>,\n    \"[]\"\n] : fullStringParse<state.initialize<def>, $, args> : fullStringParse<state.initialize<def>, $, args>;\ntype inferString<def extends string, $, args> = inferAstRoot<parseString<def, $, args>, $, args>;\ntype BaseCompletions<$, args, otherSuggestions extends string = never> = resolvableReferenceIn<$> | resolvableReferenceIn<ArkAmbient.$> | (keyof args & string) | StringifiablePrefixOperator | otherSuggestions;\ndeclare const fullStringParse: (s: DynamicState) => InnerParseResult;\ntype fullStringParse<s extends StaticState, $, args> = extractFinalizedResult<parseUntilFinalizer<s, $, args>>;\ndeclare const parseUntilFinalizer: (s: DynamicState) => DynamicStateWithRoot;\ntype parseUntilFinalizer<s extends StaticState, $, args> = s[\"finalizer\"] extends undefined ? parseUntilFinalizer<next<s, $, args>, $, args> : s;\ndeclare const next: (s: DynamicState) => void;\ntype next<s extends StaticState, $, args> = s[\"root\"] extends undefined ? parseOperand<s, $, args> : parseOperator<s, $, args>;\ntype extractFinalizedResult<s extends StaticState> = s[\"finalizer\"] extends \"\" ? s[\"root\"] : s[\"finalizer\"] extends ErrorMessage ? s[\"finalizer\"] : s[\"finalizer\"] extends \"?\" ? [s[\"root\"], \"?\"] : s[\"finalizer\"] extends \"=\" ? parseDefault<s[\"root\"], s[\"unscanned\"]> : ErrorMessage<writeUnexpectedCharacterMessage<s[\"finalizer\"] & string>>;\n\ndeclare const parseGenericArgs: (name: string, g: GenericRoot, s: DynamicState) => BaseRoot[];\ntype parseGenericArgs<name extends string, g extends GenericAst, unscanned extends string, $, args> = _parseGenericArgs<name, g, unscanned, $, args, [], []>;\ntype ParsedArgs<result extends unknown[] = unknown[], unscanned extends string = string> = {\n    result: result;\n    unscanned: unscanned;\n};\ndeclare const _parseGenericArgs: (name: string, g: GenericRoot, s: DynamicState, argNodes: BaseRoot[]) => BaseRoot[];\ntype _parseGenericArgs<name extends string, g extends GenericAst, unscanned extends string, $, args, argDefs extends string[], argAsts extends unknown[]> = parseUntilFinalizer<state.initialize<unscanned>, $, args> extends (infer finalArgState extends StaticState) ? {\n    defs: [\n        ...argDefs,\n        finalArgState[\"scanned\"] extends `${infer def}${\",\" | \">\"}` ? def : finalArgState[\"scanned\"]\n    ];\n    asts: [...argAsts, finalArgState[\"root\"]];\n    unscanned: finalArgState[\"unscanned\"];\n} extends ({\n    defs: infer nextDefs extends string[];\n    asts: infer nextAsts extends unknown[];\n    unscanned: infer nextUnscanned extends string;\n}) ? finalArgState[\"finalizer\"] extends \">\" ? nextAsts[\"length\"] extends g[\"paramsAst\"][\"length\"] ? ParsedArgs<nextAsts, nextUnscanned> : state.error<writeInvalidGenericArgCountMessage<name, genericParamNames<g[\"paramsAst\"]>, nextDefs>> : finalArgState[\"finalizer\"] extends \",\" ? _parseGenericArgs<name, g, nextUnscanned, $, args, nextDefs, nextAsts> : finalArgState[\"finalizer\"] extends ErrorMessage ? finalArgState : state.error<writeUnclosedGroupMessage<\">\">> : never : never;\ndeclare const writeInvalidGenericArgCountMessage: <name extends string, params extends array<string>, argDefs extends array<string>>(name: name, params: params, argDefs: argDefs) => writeInvalidGenericArgCountMessage<name, params, argDefs>;\ntype writeInvalidGenericArgCountMessage<name extends string, params extends array<string>, argDefs extends array<string>> = `${name}<${join<params, \", \">}> requires exactly ${params[\"length\"]} args (got ${argDefs[\"length\"]}${argDefs[\"length\"] extends (0) ? \"\" : `: ${join<argDefs, \",\">}`})`;\n\ntype validateRange<l, comparator extends Comparator, r, $, args> = [\n    l\n] extends [LimitLiteral] ? validateBound<r, comparator, l, \"left\", $, args> : [l] extends [[infer leftAst, Comparator, unknown]] ? ErrorMessage<writeDoubleRightBoundMessage<astToString<leftAst>>> : validateBound<l, comparator, r & LimitLiteral, \"right\", $, args>;\ntype validateBound<boundedAst, comparator extends Comparator, limit extends LimitLiteral, boundKind extends BoundExpressionKind, $, args> = inferAstRoot<boundedAst, $, args> extends infer bounded ? isNumericallyBoundable<bounded> extends true ? limit extends number ? validateAst<boundedAst, $, args> : ErrorMessage<writeInvalidLimitMessage<comparator, limit, boundKind>> : [bounded] extends [Date] ? validateAst<boundedAst, $, args> : [bounded] extends [InferredMorph] ? ErrorMessage<writeConstrainedMorphMessage<boundedAst>> : ErrorMessage<writeUnboundableMessage<typeToString<bounded>>> : never;\ntype isNumericallyBoundable<bounded> = [\n    bounded\n] extends [number] ? true : [bounded] extends [string] ? true : [bounded] extends [array] ? true : false;\ndeclare const writeDoubleRightBoundMessage: <root extends string>(root: root) => writeDoubleRightBoundMessage<root>;\ntype writeDoubleRightBoundMessage<root extends string> = `Expression ${root} must have at most one right bound`;\n\ntype validateDefault<baseAst, unitLiteral extends UnitLiteral, $, args> = validateAst<baseAst, $, args> extends infer e extends ErrorMessage ? e : type.infer<unitLiteral> extends inferAstIn<baseAst, $, args> ? undefined : ErrorMessage<writeUnassignableDefaultValueMessage<astToString<baseAst>, unitLiteral>>;\n\ntype validateDivisor<l, $, args> = inferAstRoot<l, $, args> extends infer data ? [\n    data\n] extends [number] ? validateAst<l, $, args> : [data] extends [InferredMorph] ? ErrorMessage<writeConstrainedMorphMessage<l>> : ErrorMessage<writeIndivisibleMessage<data>> : never;\n\ntype validateKeyof<operandAst, $, args> = inferAstRoot<operandAst, $, args> extends infer data ? [\n    data\n] extends [object] ? validateAst<operandAst, $, args> : ErrorMessage<writeNonStructuralOperandMessage<\"keyof\", typeToString<data>>> : never;\n\ntype validateAst<ast, $, args> = ast extends ErrorMessage ? ast : ast extends InferredAst ? validateInferredAst<ast[0], ast[2]> : ast extends DefAst ? ast[2] extends PrivateDeclaration<infer name> ? ErrorMessage<writePrefixedPrivateReferenceMessage<name>> : undefined : ast extends PostfixExpression<\"[]\" | \"?\", infer operand> ? validateAst<operand, $, args> : ast extends InfixExpression<infer operator, infer l, infer r> ? operator extends BranchOperator ? validateInfix<ast, $, args> : operator extends Comparator ? validateRange<l, operator, r, $, args> : operator extends \"%\" ? validateDivisor<l, $, args> : operator extends \"=\" ? validateDefault<l, r & UnitLiteral, $, args> : operator extends \"#\" ? validateAst<l, $, args> : ErrorMessage<writeUnexpectedExpressionMessage<astToString<ast>>> : ast extends [\"keyof\", infer operand] ? validateKeyof<operand, $, args> : ast extends GenericInstantiationAst<infer g, infer argAsts> ? validateGenericInstantiation<g, argAsts, $, args> : ErrorMessage<writeUnexpectedExpressionMessage<astToString<ast>>> & {\n    ast: ast;\n};\ntype writeUnexpectedExpressionMessage<expression extends string> = `Failed to parse the expression resulting from ${expression}`;\ndeclare const writePrefixedPrivateReferenceMessage: <name extends string>(name: name) => writePrefixedPrivateReferenceMessage<name>;\ntype writePrefixedPrivateReferenceMessage<name extends string> = `Private type references should not include '#'. Use '${name}' instead.`;\ntype validateInferredAst<inferred, def extends string> = def extends NumberLiteral ? number extends inferred ? ErrorMessage<writeMalformedNumericLiteralMessage<def, \"number\">> : undefined : def extends BigintLiteral ? bigint extends inferred ? ErrorMessage<writeMalformedNumericLiteralMessage<def, \"bigint\">> : undefined : [inferred] extends [anyOrNever] ? undefined : def extends PrivateDeclaration<infer name> ? ErrorMessage<writePrefixedPrivateReferenceMessage<name>> : inferred extends Generic ? ErrorMessage<writeInvalidGenericArgCountMessage<def, inferred[\"names\"], []>> : inferred extends {\n    [arkKind]: \"module\";\n} ? \"root\" extends keyof inferred ? undefined : ErrorMessage<writeMissingSubmoduleAccessMessage<def>> : def extends ErrorMessage ? def : undefined;\ntype validateString<def extends string, $, args> = parseString<def, $, args> extends infer ast ? validateAst<ast, $, args> extends infer result extends ErrorMessage ? result extends Completion<infer text> ? text : result : def : never;\ntype validateInfix<ast extends InfixExpression, $, args> = validateAst<ast[0], $, args> extends infer e extends ErrorMessage ? e : validateAst<ast[2], $, args> extends infer e extends ErrorMessage ? e : undefined;\ndeclare const shallowOptionalMessage = \"Optional definitions like 'string?' are only valid as properties in an object or tuple\";\ntype shallowOptionalMessage = typeof shallowOptionalMessage;\ndeclare const shallowDefaultableMessage = \"Defaultable definitions like 'number = 0' are only valid as properties in an object or tuple\";\ntype shallowDefaultableMessage = typeof shallowDefaultableMessage;\n\ntype ParsedOptionalProperty = readonly [BaseRoot, \"?\"];\ntype validateProperty<def, keyKind extends ParsedKeyKind, $, args> = [\n    def\n] extends [anyOrNever] ? \n/** this extra [anyOrNever] check is required to ensure that nested `type` invocations\n * like the following are not prematurely validated by the outer call:\n *\n * ```ts\n * type({\n * \t\"test?\": type(\"string\").pipe(x => x === \"true\")\n * })\n * ```\n */\ndef : keyKind extends \"spread\" ? def extends validateInnerDefinition<def, $, args> ? inferDefinition<def, $, args> extends object ? def : ErrorType<writeInvalidSpreadTypeMessage<typeToString<inferDefinition<def, $, args>>>> : validateInnerDefinition<def, $, args> : keyKind extends \"undeclared\" ? UndeclaredKeyBehavior : keyKind extends \"required\" ? validateInnerDefinition<def, $, args> : def extends OptionalPropertyDefinition ? ErrorMessage<invalidOptionalKeyKindMessage> : isDefaultable<def, $, args> extends true ? ErrorMessage<invalidDefaultableKeyKindMessage> : validateInnerDefinition<def, $, args>;\ntype isDefaultable<def, $, args> = def extends DefaultablePropertyTuple ? true : def extends PossibleDefaultableStringDefinition ? parseString<def, $, args> extends DefaultablePropertyTuple ? true : false : false;\ntype OptionalPropertyDefinition<baseDef = unknown> = OptionalPropertyTuple<baseDef> | OptionalPropertyString<baseDef & string>;\ntype OptionalPropertyString<baseDef extends string = string> = `${baseDef}?`;\ntype OptionalPropertyTuple<baseDef = unknown> = readonly [baseDef, \"?\"];\ntype PossibleDefaultableStringDefinition = `${string}=${string}`;\ntype DefaultablePropertyTuple<baseDef = unknown, thunkableProperty = unknown> = readonly [baseDef, \"=\", thunkableProperty];\ndeclare const invalidOptionalKeyKindMessage = \"Only required keys may make their values optional, e.g. { [mySymbol]: ['number', '?'] }\";\ntype invalidOptionalKeyKindMessage = typeof invalidOptionalKeyKindMessage;\ndeclare const invalidDefaultableKeyKindMessage = \"Only required keys may specify default values, e.g. { value: 'number = 0' }\";\ntype invalidDefaultableKeyKindMessage = typeof invalidDefaultableKeyKindMessage;\n\ntype inferObjectLiteral<def extends object, $, args> = show<\"...\" extends keyof def ? merge<inferDefinition<def[\"...\"], $, args>, _inferObjectLiteral<def, $, args>> : _inferObjectLiteral<def, $, args>>;\n/**\n * Infers the contents of an object literal, ignoring a spread definition\n */\ntype _inferObjectLiteral<def extends object, $, args> = {\n    -readonly [k in keyof def as nonOptionalKeyFromEntry<k, def[k], $, args>]: inferDefinition<def[k], $, args>;\n} & {\n    -readonly [k in keyof def as optionalKeyFromEntry<k, def[k]>]?: def[k] extends OptionalPropertyDefinition<infer baseDef> ? inferDefinition<baseDef, $, args> : inferDefinition<def[k], $, args>;\n};\ntype validateObjectLiteral<def, $, args> = {\n    [k in keyof def]: preparseKey<k> extends (infer parsedKey extends PreparsedKey) ? parsedKey extends PreparsedEntryKey<\"index\"> ? validateString<parsedKey[\"normalized\"], $, args> extends (ErrorMessage<infer message>) ? ErrorType<message> : inferDefinition<parsedKey[\"normalized\"], $, args> extends Key ? validateProperty<def[k], parsedKey[\"kind\"], $, args> : ErrorMessage<writeInvalidPropertyKeyMessage<parsedKey[\"normalized\"]>> : validateProperty<def[k], parsedKey[\"kind\"], $, args> : never;\n};\ntype nonOptionalKeyFromEntry<k extends PropertyKey, v, $, args> = preparseKey<k> extends infer parsedKey ? parsedKey extends PreparsedEntryKey<\"required\"> ? [\n    v\n] extends [OptionalPropertyDefinition] ? [\n    v\n] extends [anyOrNever] ? parsedKey[\"normalized\"] : never : parsedKey[\"normalized\"] : parsedKey extends PreparsedEntryKey<\"index\"> ? inferDefinition<parsedKey[\"normalized\"], $, args> & Key : never : never;\ntype optionalKeyFromEntry<k extends PropertyKey, v> = preparseKey<k> extends infer parsedKey ? parsedKey extends PreparsedEntryKey<\"optional\"> ? parsedKey[\"normalized\"] : v extends OptionalPropertyDefinition ? k : never : never;\ntype normalizedKeyKind<kind extends EntryKeyKind> = kind extends \"index\" ? string : Key;\ntype PreparsedEntryKey<kind extends EntryKeyKind = EntryKeyKind, normalized extends normalizedKeyKind<kind> = normalizedKeyKind<kind>> = {\n    kind: kind;\n    normalized: normalized;\n};\ntype PreparsedSpecialKey<kind extends SpecialKeyKind = SpecialKeyKind> = {\n    kind: kind;\n};\ntype PreparsedKey = PreparsedEntryKey | PreparsedSpecialKey;\ndeclare namespace PreparsedKey {\n    type from<t extends PreparsedKey> = t;\n}\ntype ParsedKeyKind = EntryKeyKind | SpecialKeyKind;\ntype EntryKeyKind = \"required\" | \"optional\" | \"index\";\ntype SpecialKeyKind = \"spread\" | \"undeclared\";\ntype MetaKey = \"...\" | \"+\";\ntype IndexKey<def extends string = string> = `[${def}]`;\ndeclare const preparseKey: (key: Key) => PreparsedKey;\ntype preparseKey<k> = k extends symbol ? PreparsedKey.from<{\n    kind: \"required\";\n    normalized: k;\n}> : k extends `${infer inner}?` ? inner extends `${infer baseName}${EscapeChar}` ? PreparsedKey.from<{\n    kind: \"required\";\n    normalized: `${baseName}?`;\n}> : PreparsedKey.from<{\n    kind: \"optional\";\n    normalized: inner;\n}> : k extends \"+\" ? {\n    kind: \"undeclared\";\n} : k extends \"...\" ? {\n    kind: \"spread\";\n} : k extends `${EscapeChar}${infer escapedMeta extends MetaKey}` ? PreparsedKey.from<{\n    kind: \"required\";\n    normalized: escapedMeta;\n}> : k extends IndexKey<infer def> ? PreparsedKey.from<{\n    kind: \"index\";\n    normalized: def;\n}> : PreparsedKey.from<{\n    kind: \"required\";\n    normalized: k extends (`${EscapeChar}${infer escapedIndexKey extends IndexKey}`) ? escapedIndexKey : k extends Key ? k : `${k & number}`;\n}>;\ndeclare const writeInvalidSpreadTypeMessage: <def extends string>(def: def) => writeInvalidSpreadTypeMessage<def>;\ntype writeInvalidSpreadTypeMessage<def extends string> = `Spread operand must resolve to an object literal type (was ${def})`;\n\ntype maybeValidateTupleExpression<def extends array, $, args> = def extends IndexZeroExpression ? validatePrefixExpression<def, $, args> : def extends IndexOneExpression ? validateIndexOneExpression<def, $, args> : def extends (readonly [\"\", ...unknown[]] | readonly [unknown, \"\", ...unknown[]]) ? readonly [\n    def[0] extends \"\" ? BaseCompletions<$, args, IndexZeroOperator | \"...\"> : def[0],\n    def[1] extends \"\" ? BaseCompletions<$, args, IndexOneOperator | \"...\"> : def[1]\n] : null;\ntype inferTupleExpression<def extends TupleExpression, $, args> = def[1] extends \"[]\" ? inferDefinition<def[0], $, args>[] : def[1] extends \"?\" ? inferDefinition<def[0], $, args> : def[1] extends \"&\" ? inferIntersection<inferDefinition<def[0], $, args>, inferDefinition<def[2], $, args>> : def[1] extends \"|\" ? inferDefinition<def[0], $, args> | inferDefinition<def[2], $, args> : def[1] extends \":\" ? inferPredicate<inferDefinition<def[0], $, args>, def[2]> : def[1] extends \"=>\" ? parseMorph<def[0], def[2], $, args> : def[1] extends \"|>\" ? parseTo<def[0], def[2], $, args> : def[1] extends \"=\" ? withDefault<inferDefinition<def[0], $, args>, unwrapDefault<def[2]>> : def[1] extends \"@\" ? inferDefinition<def[0], $, args> : def extends readonly [\"===\", ...infer values] ? values[number] : def extends (readonly [\"instanceof\", ...infer constructors extends Constructor[]]) ? InstanceType<constructors[number]> : def[0] extends \"keyof\" ? inferKeyOfExpression<def[1], $, args> : never;\ntype validatePrefixExpression<def extends IndexZeroExpression, $, args> = def[\"length\"] extends 1 ? readonly [writeMissingRightOperandMessage<def[0]>] : def[0] extends \"keyof\" ? readonly [def[0], validateDefinition<def[1], $, args>] : def[0] extends \"===\" ? readonly [def[0], ...unknown[]] : def[0] extends \"instanceof\" ? readonly [def[0], ...Constructor[]] : never;\ntype validateIndexOneExpression<def extends IndexOneExpression, $, args> = def[1] extends TuplePostfixOperator ? readonly [validateDefinition<def[0], $, args>, def[1]] : readonly [\n    validateDefinition<def[0], $, args>,\n    def[\"length\"] extends 2 ? writeMissingRightOperandMessage<def[1]> : def[1],\n    def[1] extends \"|\" ? validateDefinition<def[2], $, args> : def[1] extends \"&\" ? validateDefinition<def[2], $, args> : def[1] extends \":\" ? Predicate<type.infer.Out<def[0], $, args>> : def[1] extends \"=>\" ? Morph<type.infer.Out<def[0], $, args>> : def[1] extends \"|>\" ? validateDefinition<def[2], $, args> : def[1] extends \"=\" ? defaultFor<type.infer.In<def[0], $, args>> : def[1] extends \"@\" ? TypeMetaInput : validateDefinition<def[2], $, args>\n];\ntype inferKeyOfExpression<operandDef, $, args> = show<keyof inferDefinition<operandDef, $, args>>;\ntype TupleExpression = IndexZeroExpression | IndexOneExpression;\ntype ArgTwoOperator = Exclude<IndexOneOperator, \"?\" | \"=\">;\ntype parseTo<inDef, outDef, $, args> = inferPipe<inferDefinition<inDef, $, args>, inferDefinition<outDef, $, args>>;\ntype parseMorph<inDef, morph, $, args> = morph extends Morph ? inferMorphOut<morph> extends infer out ? (In: distill.In<inferDefinition<inDef, $, args>>) => Out<out> : never : never;\ntype IndexOneExpression<token extends string = IndexOneOperator> = readonly [unknown, token, ...unknown[]];\ntype IndexOneParser<token extends string> = (def: IndexOneExpression<token>, ctx: BaseParseContext) => BaseRoot;\ndeclare const postfixParsers: {\n    \"?\": IndexOneParser<\"?\">;\n    \"[]\": IndexOneParser<\"[]\">;\n};\ntype TuplePostfixOperator = keyof typeof postfixParsers;\ndeclare const infixParsers: {\n    \"|\": IndexOneParser<\"|\">;\n    \"=\": IndexOneParser<\"=\">;\n    \"|>\": IndexOneParser<\"|>\">;\n    \"&\": IndexOneParser<\"&\">;\n    \"=>\": IndexOneParser<\"=>\">;\n    \":\": IndexOneParser<\":\">;\n    \"@\": IndexOneParser<\"@\">;\n};\ntype TupleInfixOperator = keyof typeof infixParsers;\ndeclare const indexOneParsers: {\n    \"|\": IndexOneParser<\"|\">;\n    \"=\": IndexOneParser<\"=\">;\n    \"|>\": IndexOneParser<\"|>\">;\n    \"&\": IndexOneParser<\"&\">;\n    \"=>\": IndexOneParser<\"=>\">;\n    \":\": IndexOneParser<\":\">;\n    \"@\": IndexOneParser<\"@\">;\n    \"?\": IndexOneParser<\"?\">;\n    \"[]\": IndexOneParser<\"[]\">;\n};\ntype IndexOneOperator = keyof typeof indexOneParsers;\ntype IndexZeroParser<token extends string> = (def: IndexZeroExpression<token>, ctx: BaseParseContext) => BaseRoot;\ntype IndexZeroExpression<token extends string = IndexZeroOperator> = readonly [\n    token,\n    ...unknown[]\n];\ndeclare const indexZeroParsers: {\n    keyof: IndexZeroParser<\"keyof\">;\n    instanceof: IndexZeroParser<\"instanceof\">;\n    \"===\": IndexZeroParser<\"===\">;\n};\ntype IndexZeroOperator = keyof typeof indexZeroParsers;\n\ntype validateTupleLiteral<def extends array, $, args> = parseSequence<def, $, args> extends infer s extends SequenceParseState ? Readonly<s[\"validated\"]> : never;\ntype inferTupleLiteral<def extends array, $, args> = parseSequence<def, $, args> extends infer s extends SequenceParseState ? s[\"inferred\"] : never;\ntype SequencePhase = satisfy<keyof Sequence.Inner, SequencePhase.prefix | SequencePhase.optionals | SequencePhase.defaultables | SequencePhase.postfix>;\ndeclare namespace SequencePhase {\n    type prefix = \"prefix\";\n    type optionals = \"optionals\";\n    type defaultables = \"defaultables\";\n    type postfix = \"postfix\";\n}\ntype SequenceParseState = {\n    unscanned: array;\n    inferred: array;\n    validated: array;\n    phase: SequencePhase;\n};\ntype parseSequence<def extends array, $, args> = parseNextElement<{\n    unscanned: def;\n    inferred: [];\n    validated: [];\n    phase: SequencePhase.prefix;\n}, $, args>;\ntype PreparsedElementKind = \"required\" | SequencePhase.optionals | SequencePhase.defaultables;\ntype PreparsedElement = {\n    head: unknown;\n    tail: array;\n    inferred: unknown;\n    validated: unknown;\n    kind: PreparsedElementKind;\n    spread: boolean;\n};\ndeclare namespace PreparsedElement {\n    type from<result extends PreparsedElement> = result;\n    type required = \"required\";\n    type optionals = \"optionals\";\n    type defaultables = \"defaultables\";\n}\ntype preparseNextState<s extends SequenceParseState, $, args> = s[\"unscanned\"] extends readonly [\"...\", infer head, ...infer tail] ? preparseNextElement<head, tail, true, $, args> : s[\"unscanned\"] extends readonly [infer head, ...infer tail] ? preparseNextElement<head, tail, false, $, args> : null;\ntype preparseNextElement<head, tail extends array, spread extends boolean, $, args> = PreparsedElement.from<{\n    head: head;\n    tail: tail;\n    inferred: inferDefinition<head, $, args>;\n    validated: validateInnerDefinition<head, $, args>;\n    kind: head extends OptionalPropertyDefinition ? PreparsedElement.optionals : head extends DefaultablePropertyTuple ? PreparsedElement.defaultables : isDefaultable<head, $, args> extends true ? PreparsedElement.defaultables : PreparsedElement.required;\n    spread: spread;\n}>;\ntype parseNextElement<s extends SequenceParseState, $, args> = preparseNextState<s, $, args> extends infer next extends PreparsedElement ? parseNextElement<{\n    unscanned: next[\"tail\"];\n    inferred: nextInferred<s, next>;\n    validated: nextValidated<s, next>;\n    phase: next[\"kind\"] extends (SequencePhase.optionals | SequencePhase.defaultables) ? next[\"kind\"] : number extends nextInferred<s, next>[\"length\"] ? s[\"phase\"] : SequencePhase.prefix;\n}, $, args> : s;\ntype nextInferred<s extends SequenceParseState, next extends PreparsedElement> = next[\"spread\"] extends true ? [\n    ...s[\"inferred\"],\n    ...conform<next[\"inferred\"], array>\n] : next[\"kind\"] extends SequencePhase.optionals ? [\n    ...s[\"inferred\"],\n    next[\"inferred\"]?\n] : [...s[\"inferred\"], next[\"inferred\"]];\ntype nextValidated<s extends SequenceParseState, next extends PreparsedElement> = [\n    ...s[\"validated\"],\n    ...nextValidatedSpreadOperatorIfPresent<s, next>,\n    nextValidatedElement<s, next>\n];\ntype nextValidatedSpreadOperatorIfPresent<s extends SequenceParseState, next extends PreparsedElement> = next[\"spread\"] extends true ? [\n    next[\"inferred\"] extends infer spreadOperand extends array ? [\n        number,\n        number\n    ] extends ([\n        s[\"inferred\"][\"length\"],\n        spreadOperand[\"length\"]\n    ]) ? ErrorMessage<multipleVariadicMessage> : \"...\" : ErrorMessage<writeNonArraySpreadMessage<next[\"head\"]>>\n] : [];\ntype nextValidatedElement<s extends SequenceParseState, next extends PreparsedElement> = next[\"kind\"] extends SequencePhase.optionals ? next[\"spread\"] extends true ? ErrorMessage<spreadOptionalMessage> : s[\"phase\"] extends SequencePhase.postfix ? ErrorMessage<optionalOrDefaultableAfterVariadicMessage> : next[\"validated\"] : next[\"kind\"] extends SequencePhase.defaultables ? next[\"spread\"] extends true ? ErrorMessage<spreadDefaultableMessage> : s[\"phase\"] extends SequencePhase.optionals ? ErrorMessage<defaultablePostOptionalMessage> : s[\"phase\"] extends SequencePhase.postfix ? ErrorMessage<optionalOrDefaultableAfterVariadicMessage> : next[\"validated\"] : [s[\"phase\"], next[\"spread\"]] extends ([\n    SequencePhase.optionals | SequencePhase.defaultables,\n    false\n]) ? ErrorMessage<postfixAfterOptionalOrDefaultableMessage> : next[\"validated\"];\ndeclare const writeNonArraySpreadMessage: <operand extends string>(operand: operand) => writeNonArraySpreadMessage<operand>;\ntype writeNonArraySpreadMessage<operand> = `Spread element must be an array${operand extends string ? ` (was ${operand})` : \"\"}`;\ndeclare const multipleVariadicMesage = \"A tuple may have at most one variadic element\";\ntype multipleVariadicMessage = typeof multipleVariadicMesage;\ndeclare const optionalOrDefaultableAfterVariadicMessage = \"An optional element may not follow a variadic element\";\ntype optionalOrDefaultableAfterVariadicMessage = typeof optionalOrDefaultableAfterVariadicMessage;\ndeclare const spreadOptionalMessage = \"A spread element cannot be optional\";\ntype spreadOptionalMessage = typeof spreadOptionalMessage;\ndeclare const spreadDefaultableMessage = \"A spread element cannot have a default\";\ntype spreadDefaultableMessage = typeof spreadDefaultableMessage;\ndeclare const defaultablePostOptionalMessage = \"A defaultable element may not follow an optional element without a default\";\ntype defaultablePostOptionalMessage = typeof defaultablePostOptionalMessage;\n\ntype inferDefinition<def, $, args> = [\n    def\n] extends [anyOrNever] ? def : def extends type.cast<infer t> ? ifEmptyObjectLiteral<def, object, t> : def extends ThunkCast<infer t> ? t : def extends string ? inferString<def, $, args> : def extends array ? inferTuple<def, $, args> : def extends RegExp ? string : def extends object ? inferObjectLiteral<def, $, args> : never;\ntype validateDefinition<def, $, args> = null extends undefined ? ErrorMessage<`'strict' or 'strictNullChecks' must be set to true in your tsconfig's 'compilerOptions'`> : [def] extends [anyOrNever] ? def : def extends OptionalPropertyDefinition ? ErrorMessage<shallowOptionalMessage> : isDefaultable<def, $, args> extends true ? ErrorMessage<shallowDefaultableMessage> : validateInnerDefinition<def, $, args>;\ntype validateInnerDefinition<def, $, args> = [\n    def\n] extends [Terminal] ? def : def extends string ? validateString<def, $, args> : def extends array ? validateTuple<def, $, args> : def extends BadDefinitionType ? ErrorMessage<writeBadDefinitionTypeMessage<objectKindOrDomainOf<def>>> : unknown extends def ? BaseCompletions<$, args> | {} : RegExp extends def ? def : validateObjectLiteral<def, $, args>;\ntype validateTuple<def extends array, $, args> = maybeValidateTupleExpression<def, $, args> extends infer result ? result extends null ? validateTupleLiteral<def, $, args> : result : never;\ntype inferTuple<def extends array, $, args> = def extends TupleExpression ? inferTupleExpression<def, $, args> : inferTupleLiteral<def, $, args>;\ntype validateDeclared<declared, def, $, args> = def extends type.validate<def, $, args> ? validateInference<def, declared, $, args> : type.validate<def, $, args>;\ntype validateInference<def, declared, $, args> = def extends RegExp | type.cast<unknown> | ThunkCast | TupleExpression ? validateShallowInference<def, declared, $, args> : def extends array ? declared extends array ? {\n    [i in keyof declared]: i extends keyof def ? validateInference<def[i], declared[i], $, args> : declared[i];\n} : show<declarationMismatch<def, declared, $, args>> : def extends object ? show<{\n    [k in requiredKeyOf<declared>]: k extends keyof def ? validateInference<def[k], declared[k], $, args> : declared[k];\n} & {\n    [k in optionalKeyOf<declared> & string as `${k}?`]: `${k}?` extends (keyof def) ? validateInference<def[`${k}?`], defined<declared[k]>, $, args> : declared[k];\n}> : validateShallowInference<def, declared, $, args>;\ntype validateShallowInference<def, declared, $, args> = equals<inferDefinition<def, $, args>, declared> extends true ? def : show<declarationMismatch<def, declared, $, args>>;\ntype declarationMismatch<def, declared, $, args> = {\n    declared: declared;\n    inferred: inferDefinition<def, $, args>;\n};\ntype Terminal = type.cast<unknown> | Fn;\ntype ThunkCast<t = unknown> = () => type.cast<t>;\ntype BadDefinitionType = Exclude<Primitive, string>;\ndeclare const writeBadDefinitionTypeMessage: <actual extends string>(actual: actual) => writeBadDefinitionTypeMessage<actual>;\ntype writeBadDefinitionTypeMessage<actual extends string> = `Type definitions must be strings or objects (was ${actual})`;\n\ntype inferAstRoot<ast, $, args> = ast extends array ? inferExpression<ast, $, args> : never;\ntype inferAstIn<ast, $, args> = distill.In<inferAstRoot<ast, $, args>>;\ntype DefAst<def = unknown, alias extends string = string> = [\n    def,\n    \"def\",\n    alias\n];\ntype InferredAst<t = unknown, def extends string = string> = [\n    t,\n    \"inferred\",\n    def\n];\ntype inferExpression<ast, $, args> = ast extends array ? ast extends InferredAst<infer resolution> ? resolution : ast extends DefAst<infer def> ? inferDefinition<def, $, args> : ast extends GenericInstantiationAst<infer g, infer argAsts> ? inferGenericInstantiation<g, argAsts, $, args> : ast[1] extends \"[]\" ? inferExpression<ast[0], $, args>[] : ast[1] extends \"|\" ? inferExpression<ast[0], $, args> | inferExpression<ast[2], $, args> : ast[1] extends \"&\" ? inferIntersection<inferExpression<ast[0], $, args>, inferExpression<ast[2], $, args>> : ast[1] extends \"|>\" ? inferPipe<inferExpression<ast[0], $, args>, inferExpression<ast[2], $, args>> : ast[1] extends \"=\" ? type.infer<ast[2]> extends infer defaultValue ? withDefault<inferExpression<ast[0], $, args>, defaultValue> : never : ast[1] extends \"#\" ? type.brand<inferExpression<ast[0], $, args>, ast[2]> : ast[1] extends Comparator ? ast[0] extends LimitLiteral ? inferExpression<ast[2], $, args> : inferExpression<ast[0], $, args> : ast[1] extends \"%\" ? inferExpression<ast[0], $, args> : ast[1] extends \"?\" ? inferExpression<ast[0], $, args> : ast[0] extends \"keyof\" ? arkKeyOf<inferExpression<ast[1], $, args>> : never : never;\ntype PostfixExpression<operator extends ArkTypeScanner.PostfixToken = ArkTypeScanner.PostfixToken, operand = unknown> = readonly [operand, operator];\ntype InfixExpression<operator extends ArkTypeScanner.InfixToken = ArkTypeScanner.InfixToken, l = unknown, r = unknown> = [l, operator, r];\n\n/** @ts-ignore cast variance */\ninterface Type$6<out t extends object = object, $ = {}> extends Type<t, $> {\n    readonly(): t extends array ? Type$5<{\n        readonly [i in keyof t]: t[i];\n    }, $> : Type$6<{\n        readonly [k in keyof t]: t[k];\n    }, $>;\n    keyof(): instantiateType<arkKeyOf<t>, $>;\n    /**\n     * Get the `Type` of a property of this `Type<object>`.\n     * @example type({ foo: \"string\" }).get(\"foo\") // Type<string>\n     */\n    get<const k1 extends arkIndexableOf<t>, r = instantiateType<arkGet<t, k1>, $>>(k1: k1 | type.cast<k1>): r extends infer _ ? _ : never;\n    get<const k1 extends arkIndexableOf<t>, const k2 extends arkIndexableOf<arkGet<t, k1>>, r = instantiateType<arkGet<arkGet<t, k1>, k2>, $>>(k1: k1 | type.cast<k1>, k2: k2 | type.cast<k2>): r extends infer _ ? _ : never;\n    get<const k1 extends arkIndexableOf<t>, const k2 extends arkIndexableOf<arkGet<t, k1>>, const k3 extends arkIndexableOf<arkGet<arkGet<t, k1>, k2>>, r = instantiateType<arkGet<arkGet<arkGet<t, k1>, k2>, k3>, $>>(k1: k1 | type.cast<k1>, k2: k2 | type.cast<k2>, k3: k3 | type.cast<k3>): r extends infer _ ? _ : never;\n    /**\n     * Create a copy of this `Type` with only the specified properties.\n     * @example type({ foo: \"string\", bar: \"number\" }).pick(\"foo\") // Type<{ foo: string }>\n     */\n    pick<const key extends arkKeyOf<t> = never>(...keys: (key | type.cast<key>)[]): Type$6<{\n        [k in keyof t as Extract<toArkKey<t, k>, key>]: t[k];\n    }, $>;\n    /**\n     * Create a copy of this `Type` with all properties except the specified ones.\n     * @example type({ foo: \"string\", bar: \"number\" }).omit(\"foo\") // Type<{ bar: number }>\n     */\n    omit<const key extends arkKeyOf<t> = never>(...keys: (key | type.cast<key>)[]): Type$6<{\n        [k in keyof t as Exclude<toArkKey<t, k>, key>]: t[k];\n    }, $>;\n    /**\n     * Merge another `Type` definition, overriding properties of this `Type` with the duplicate keys.\n     * @example type({ a: \"1\", b: \"2\" }).merge({ b: \"3\", c: \"4\" }) // Type<{ a: 1, b: 3, c: 4 }>\n     */\n    merge<const def, inferredDef = type.infer<def, $>, r = Type$6<merge<t, inferredDef>, $>>(def: type.validate<def, $> & (inferredDef extends object ? unknown : ErrorType<\"Merged type must be an object\", [actual: inferredDef]>)): r extends infer _ ? _ : never;\n    /**\n     * Create a copy of this `Type` with all properties required.\n     * @example const T = type({ \"foo?\"\": \"string\" }).required() // Type<{ foo: string }>\n     */\n    required(): Type$6<{\n        [k in keyof t]-?: t[k];\n    }, $>;\n    /**\n     * Create a copy of this `Type` with all properties optional.\n     * @example: const T = type({ foo: \"string\" }).optional() // Type<{ foo?: string }>\n     */\n    partial(): Type$6<{\n        [k in keyof t]?: t[k];\n    }, $>;\n    map<transformed extends listable<MappedTypeProp>, r = Type$6<constructMapped<t, transformed>, $>>(flatMapEntry: (entry: typePropOf<t, $>) => transformed): r extends infer _ ? _ : never;\n    /**\n     * List of property info of this `Type<object>`.\n     * @example type({ foo: \"string = \"\" }).props // [{ kind: \"required\", key: \"foo\", value: Type<string>, default: \"\" }]\n     */\n    props: array<typePropOf<t, $>>;\n}\ntype typePropOf<o, $> = keyof o extends infer k ? k extends keyof o ? typeProp<o, k, $> : never : never;\ntype typeProp<o, k extends keyof o, $, t = o[k] & ({} | null)> = t extends Default<infer t, infer defaultValue> ? DefaultedTypeProp<k & Key, t, defaultValue, $> : BaseTypeProp<k extends optionalKeyOf<o> ? \"optional\" : \"required\", k & Key, t, $>;\ninterface BaseTypeProp<kind extends Prop.Kind = Prop.Kind, k extends Key = Key, \n/** @ts-ignore cast variance */\nout v = unknown, $ = {}> {\n    kind: kind;\n    key: k;\n    value: instantiateType<v, $>;\n    meta: ArkEnv.meta;\n    toJSON: () => JsonStructure;\n}\ninterface DefaultedTypeProp<k extends Key = Key, v = unknown, defaultValue = v, $ = {}> extends BaseTypeProp<\"optional\", k, v, $> {\n    default: defaultValue;\n}\ntype MappedTypeProp<k extends Key = Key, v = unknown> = BaseMappedTypeProp<k, v> | OptionalMappedTypeProp<k, v>;\ntype BaseMappedTypeProp<k extends Key, v> = merge<BaseMappedPropInner, {\n    key: k;\n    value: type.cast<v>;\n}>;\ntype OptionalMappedTypeProp<k extends Key, v> = merge<OptionalMappedPropInner, {\n    key: k;\n    value: type.cast<v>;\n    default?: v;\n}>;\ntype constructMapped<t, transformed extends listable<MappedTypeProp>> = show<intersectUnion<fromTypeProps<t, transformed extends array ? transformed : [transformed]>>>;\ntype fromTypeProps<t, props extends array<MappedTypeProp>> = show<{\n    [prop in props[number] as Extract<applyHomomorphicOptionality<t, prop>, {\n        kind: \"required\";\n    }>[\"key\"]]: prop[\"value\"][inferred];\n} & {\n    [prop in props[number] as Extract<applyHomomorphicOptionality<t, prop>, {\n        kind: \"optional\";\n        default?: never;\n    }>[\"key\"]]?: prop[\"value\"][inferred];\n} & {\n    [prop in props[number] as Extract<applyHomomorphicOptionality<t, prop>, {\n        kind: \"optional\";\n        default: unknown;\n    }>[\"key\"]]: withDefault<prop[\"value\"][inferred], prop[\"default\" & keyof prop]>;\n}>;\ntype applyHomomorphicOptionality<t, prop extends MappedTypeProp> = prop[\"kind\"] extends string ? prop : prop & {\n    kind: prop[\"key\"] extends optionalKeyOf<t> ? \"optional\" : \"required\";\n};\n\ninterface Type$5<\n/** @ts-ignore cast variance */\nout t extends readonly unknown[] = readonly unknown[], $ = {}> extends Type$6<t, $> {\n    atLeastLength(schema: InclusiveNumericRangeSchema): this;\n    atMostLength(schema: InclusiveNumericRangeSchema): this;\n    moreThanLength(schema: ExclusiveNumericRangeSchema): this;\n    lessThanLength(schema: ExclusiveNumericRangeSchema): this;\n    exactlyLength(schema: ExactLength.Schema): this;\n}\n\n/** @ts-ignore cast variance */\ninterface Type$4<out t extends globalThis.Date = globalThis.Date, $ = {}> extends Type$6<t, $> {\n    atOrAfter(schema: InclusiveDateRangeSchema): this;\n    atOrBefore(schema: InclusiveDateRangeSchema): this;\n    laterThan(schema: ExclusiveDateRangeSchema): this;\n    earlierThan(schema: ExclusiveDateRangeSchema): this;\n}\n\n/** @ts-ignore cast variance */\ninterface Type$3<out t extends number = number, $ = {}> extends Type<t, $> {\n    divisibleBy(schema: Divisor.Schema): this;\n    atLeast(schema: InclusiveNumericRangeSchema): this;\n    atMost(schema: InclusiveNumericRangeSchema): this;\n    moreThan(schema: ExclusiveNumericRangeSchema): this;\n    lessThan(schema: ExclusiveNumericRangeSchema): this;\n}\n\n/** @ts-ignore cast variance */\ninterface Type$2<out t extends string = string, $ = {}> extends Type<t, $> {\n    matching(schema: Pattern.Schema): this;\n    atLeastLength(schema: InclusiveNumericRangeSchema): this;\n    atMostLength(schema: InclusiveNumericRangeSchema): this;\n    moreThanLength(schema: ExclusiveNumericRangeSchema): this;\n    lessThanLength(schema: ExclusiveNumericRangeSchema): this;\n    exactlyLength(schema: ExactLength.Schema): this;\n}\n\ntype instantiateType<t, $> = [\n    t\n] extends [anyOrNever] ? Type<t, $> : [t] extends [object] ? [\n    t\n] extends [array] ? Type$5<t, $> : [t] extends [Date] ? Type$4<t, $> : Type$6<t, $> : [t] extends [string] ? Type$2<t, $> : [t] extends [number] ? Type$3<t, $> : Type<t, $>;\n\n/** The convenience properties attached to `type` */\ntype TypeParserAttachments = Omit<TypeParser, never>;\ninterface TypeParser<$ = {}> extends Ark.boundTypeAttachments<$> {\n    /**\n     * Create a {@link Type} from your definition.\n     *\n     * @example const person = type({ name: \"string\" })\n     */\n    <const def, r = type.instantiate<def, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * Create a {@link Generic} from a parameter string and body definition.\n     *\n     * @param params A string like \"<t, n extends number>\" specifying the\n     * {@link Generic}'s parameters and any associated constraints via `extends`.\n     *\n     * @param def The definition for the body of the {@link Generic}. Can reference the\n     * parameter names specified in the previous argument in addition to aliases\n     * from its {@link Scope}.\n     *\n     * @example const boxOf = type(\"<t extends string | number>\", { contents: \"t\" })\n     */\n    <const params extends ParameterString, const def, r = Generic<parseValidGenericParams<params, $>, def, $>>(params: validateParameterString<params, $>, def: type.validate<def, $, baseGenericConstraints<parseValidGenericParams<params, $>>>): r extends infer _ ? _ : never;\n    /**\n     * Create a {@link Type} from a [tuple expression](http://localhost:3000/docs/expressions)\n     * spread as this function's arguments.\n     *\n     * @example type(\"string\", \"|\", { foo: \"number\" })\n     */\n    <const zero, const one, const rest extends array, r = type.instantiate<[zero, one, ...rest], $>>(_0: zero extends IndexZeroOperator ? zero : type.validate<zero, $>, _1: zero extends \"keyof\" ? type.validate<one, $> : zero extends \"instanceof\" ? conform<one, Constructor> : zero extends \"===\" ? conform<one, unknown> : conform<one, ArgTwoOperator>, ..._2: zero extends \"===\" ? rest : zero extends \"instanceof\" ? conform<rest, readonly Constructor[]> : one extends TupleInfixOperator ? one extends \":\" ? [Predicate<distill.In<type.infer<zero, $>>>] : one extends \"=>\" ? [Morph<distill.Out<type.infer<zero, $>>, unknown>] : one extends \"|>\" ? [type.validate<rest[0], $>] : one extends \"@\" ? [TypeMetaInput] : [type.validate<rest[0], $>] : []): r extends infer _ ? _ : never;\n    /**\n     * An alias of the {@link ArkErrors} class, an instance of which is returned when a {@link Type}\n     * is invoked with invalid input.\n     *\n     * @example\n     * const out = myType(data)\n     *\n     * if(out instanceof type.errors) console.log(out.summary)\n     *\n     */\n    errors: typeof ArkErrors;\n    hkt: typeof Hkt;\n    keywords: typeof keywords;\n    /**\n     * The {@link Scope} in which definitions passed to this function will be parsed.\n     */\n    $: Scope<$>;\n    /**\n     * An alias of `type` with no type-level validation or inference.\n     *\n     * Useful when wrapping `type` or using it to parse a dynamic definition.\n     */\n    raw(def: unknown): Type<any, $>;\n    module: ModuleParser;\n    scope: ScopeParser;\n    define: DefinitionParser<$>;\n    generic: GenericParser<$>;\n    match: MatchParser<$>;\n    schema: SchemaParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by a value strictly equal (`===`) to the argument passed to this function.\n     * @example const foo = type.unit('foo') // {@link Type}<'foo'>\n     * @example const sym: unique symbol = Symbol(); type.unit(sym) // {@link Type}<typeof sym>\n     */\n    unit: UnitTypeParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by a value strictly equal (`===`) to one of the arguments passed to this function.\n     * @example const enum = type.enumerated('foo', 'bar', obj) // obj is a by-reference object\n     * @example const tupleForm = type(['===', 'foo', 'bar', obj])\n     * @example const argsForm = type('===', 'foo', 'bar', obj)\n     */\n    enumerated: EnumeratedTypeParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by a value of a specific class.\n     * @example const array = type.instanceOf(Array)\n     */\n    instanceOf: InstanceOfTypeParser<$>;\n}\ndeclare class InternalTypeParser extends Callable<(...args: unknown[]) => BaseRoot | Generic, TypeParserAttachments> {\n    constructor($: InternalScope);\n}\ntype DeclarationParser<$> = <preinferred>() => {\n    type: <const def>(def: validateDeclared<preinferred, def, $, bindThis<def>>) => Type$1<preinferred, $>;\n};\ntype UnitTypeParser<$> = <const t>(value: t) => Type$1<t, $>;\ntype InstanceOfTypeParser<$> = <const t extends object>(ctor: Constructor<t>) => Type$1<t, $>;\ntype EnumeratedTypeParser<$> = <const values extends readonly unknown[]>(...values: values) => Type$1<values[number], $>;\ntype DefinitionParser<$> = <const def>(def: type.validate<def, $>) => def;\ntype SchemaParser<$> = (schema: RootSchema, opts?: BaseParseOptions) => Type$1<unknown, $>;\ntype TypeConstructor<t = unknown, $ = {}> = new (def: unknown, $: Scope<$>) => Type$1<t, $>;\ntype Type$1<t = unknown, $ = {}> = instantiateType<t, $>;\ndeclare const Type$1: TypeConstructor;\n\ninterface ArkScopeConfig extends ArkSchemaScopeConfig {\n}\ninterface ScopeParser {\n    <const def>(def: scope.validate<def>, config?: ArkScopeConfig): Scope<scope.infer<def>>;\n    define: <const def>(def: scope.validate<def>) => def;\n}\ntype ModuleParser = <const def>(def: scope.validate<def>, config?: ArkScopeConfig) => scope.infer<def> extends infer $ ? Module<{\n    [k in exportedNameOf<$>]: $[k];\n}> : never;\ntype bindThis<def> = {\n    this: Def<def>;\n};\n/** nominal type for an unparsed definition used during scope bootstrapping */\ntype Def<def = {}> = Brand<def, \"unparsed\">;\n/** sentinel indicating a scope that will be associated with a generic has not yet been parsed */\ntype UnparsedScope = \"$\";\n/** These are legal as values of a scope but not as definitions in other contexts */\ntype PreparsedResolution = PreparsedNodeResolution;\ntype bootstrapAliases<def> = {\n    [k in Exclude<keyof def, GenericDeclaration>]: def[k] extends (PreparsedResolution) ? def[k] extends {\n        t: infer g extends GenericAst;\n    } ? g : def[k] extends Module<infer $> | BoundModule<infer $, any> ? Submodule<$> : def[k] : def[k] extends (() => infer thunkReturn extends PreparsedResolution) ? thunkReturn extends {\n        t: infer g extends GenericAst;\n    } ? g : thunkReturn extends Module<infer $> | BoundModule<infer $, any> ? Submodule<$> : thunkReturn : Def<def[k]>;\n} & {\n    [k in keyof def & GenericDeclaration as extractGenericName<k>]: GenericAst<parseValidGenericParams<extractGenericParameters<k>, bootstrapAliases<def>>, def[k], UnparsedScope>;\n};\ntype inferBootstrapped<$> = {\n    [name in keyof $]: $[name] extends Def<infer def> ? inferDefinition<def, $, {}> : $[name] extends {\n        t: infer g extends GenericAst;\n    } ? bindGenericToScope<g, $> : $[name];\n} & unknown;\ntype bindGenericToScope<g extends GenericAst, $> = GenericAst<g[\"paramsAst\"], g[\"bodyDef\"], g[\"$\"] extends UnparsedScope ? $ : g[\"$\"], $>;\ntype extractGenericName<k> = k extends GenericDeclaration<infer name> ? name : never;\ntype extractGenericParameters<k> = k extends `${string}<${infer params}>` ? ParameterString<params> : never;\ntype resolutionToAst<alias extends string, resolution> = [\n    resolution\n] extends [anyOrNever] ? InferredAst<resolution, alias> : resolution extends Def<infer def> ? DefAst<def, alias> : resolution extends {\n    [arkKind]: \"module\";\n    root: infer root;\n} ? InferredAst<root, alias> : resolution extends GenericAst ? resolution : InferredAst<resolution, alias>;\ninterface ResolvedTypeScopeConfig extends ResolvedScopeConfig {\n    keywords?: Record<string, TypeMetaInput>;\n}\ninterface InternalScope {\n    constructor: typeof InternalScope;\n}\ndeclare class InternalScope<$ extends {} = {}> extends BaseScope<$> {\n    resolvedConfig: ResolvedTypeScopeConfig;\n    get ambientAttachments(): Ark.boundTypeAttachments<$> | undefined;\n    protected preparseOwnAliasEntry(alias: string, def: unknown): AliasDefEntry;\n    parseGenericParams(def: string, opts: BaseParseOptions): array<GenericParamDef>;\n    protected normalizeRootScopeValue(resolution: unknown): unknown;\n    protected preparseOwnDefinitionFormat(def: unknown, opts: BaseParseOptions): BaseRoot | BaseParseContextInput;\n    parseOwnDefinitionFormat(def: unknown, ctx: BaseParseContext): BaseRoot;\n    unit: UnitTypeParser<$>;\n    enumerated: EnumeratedTypeParser<$>;\n    instanceOf: InstanceOfTypeParser<$>;\n    match: InternalMatchParser;\n    declare: () => {\n        type: InternalTypeParser;\n    };\n    define<def>(def: def): def;\n    type: InternalTypeParser;\n    static scope: ScopeParser;\n    static module: ModuleParser;\n}\ndeclare const scope: ScopeParser;\ndeclare namespace scope {\n    type validate<def> = {\n        [k in keyof def]: k extends noSuggest ? unknown : parseScopeKey<k, def>[\"params\"] extends infer params ? params extends array<GenericParamAst> ? params[\"length\"] extends 0 ? def[k] extends type.Any | PreparsedResolution ? def[k] : k extends (PrivateDeclaration<infer name extends keyof def & string>) ? ErrorType<writeDuplicateAliasError<name>> : type.validate<def[k], bootstrapAliases<def>, {}> : type.validate<def[k], bootstrapAliases<def>, baseGenericConstraints<params>> : params : never;\n    };\n    type infer<def> = inferBootstrapped<bootstrapAliases<def>>;\n}\ninterface ScopeConstructor {\n    new <$ = {}>(...args: ConstructorParameters<typeof InternalScope>): Scope<$>;\n    scope: ScopeParser;\n    module: ModuleParser;\n}\ninterface Scope<$ = {}> {\n    t: $;\n    [arkKind]: \"scope\";\n    config: ArkScopeConfig;\n    references: readonly BaseNode[];\n    json: JsonStructure;\n    exportedNames: array<exportedNameOf<$>>;\n    /** The set of names defined at the root-level of the scope mapped to their\n     * corresponding definitions.**/\n    aliases: Record<string, unknown>;\n    internal: toInternalScope<$>;\n    defineSchema<const def extends RootSchema>(schema: def): def;\n    node<kinds extends NodeKind | array<RootKind>>(kinds: kinds, schema: NodeSchema<flattenListable<kinds>>, opts?: BaseParseOptions): nodeOfKind<reducibleKindOf<flattenListable<kinds>>>;\n    unit: UnitTypeParser<$>;\n    enumerated: EnumeratedTypeParser<$>;\n    type: TypeParser<$>;\n    match: MatchParser<$>;\n    declare: DeclarationParser<$>;\n    define: DefinitionParser<$>;\n    generic: GenericParser<$>;\n    schema: SchemaParser<$>;\n    import(): Module<{\n        [k in exportedNameOf<$> as PrivateDeclaration<k>]: $[k];\n    }>;\n    import<names extends exportedNameOf<$>[]>(...names: names): BoundModule<{\n        [k in names[number] as PrivateDeclaration<k>]: $[k];\n    } & unknown, $>;\n    export(): Module<{\n        [k in exportedNameOf<$>]: $[k];\n    }>;\n    export<names extends exportedNameOf<$>[]>(...names: names): BoundModule<{\n        [k in names[number]]: $[k];\n    } & unknown, $>;\n    resolve<name extends exportedNameOf<$>>(name: name): instantiateExport<$[name], $>;\n}\ndeclare const Scope: ScopeConstructor;\ntype parseScopeKey<k, def> = k extends `${infer name}<${infer params}>` ? parseGenericScopeKey<name, params, def> : {\n    name: k;\n    params: [];\n};\ntype parseGenericScopeKey<name extends string, params extends string, def> = {\n    name: name;\n    params: parseGenericParams<params, bootstrapAliases<def>>;\n};\ntype InnerParseResult = BaseRoot | ParsedOptionalProperty | ParsedDefaultableProperty;\n\n/** @ts-ignore cast variance */\ninterface Inferred<out t = unknown, $ = {}> {\n    internal: BaseRoot;\n    [inferred]: t;\n    /**\n     * precompiled JS used to optimize validation\n     *\n     * ‚ö†Ô∏è will be `undefined` in [jitless](https://arktype.io/docs/configuration#jitless) mode\n     */\n    precompilation: string | undefined;\n    /**\n     * generic parameter representing this Type\n     *\n     * @typeonly\n     *\n     * ‚ö†Ô∏è May contain types representing morphs or default values that would\n     * be inaccurate if used directly for runtime values. In those cases,\n     * you should use {@link infer} or {@link inferIn} on this object instead.\n     */\n    t: t;\n    /**\n     * #### {@link Scope} in which chained methods are parsed\n     */\n    $: Scope<$>;\n    /**\n     * #### type of output this returns\n     *\n     * @typeonly\n     *\n     * @example\n     * const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\n     * type ParsedNumber = typeof parseNumber.infer // number\n     */\n    infer: this[\"inferOut\"];\n    /**\n     * type of output this returns\n     *\n     * üîó alias of {@link infer}\n     * @typeonly\n     *\n     *\n     * @example\n     * const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\n     * type ParsedNumber = typeof parseNumber.infer // number\n     */\n    inferOut: distill.Out<t>;\n    /**\n     * type of output that can be introspected at runtime (e.g. via {@link out})\n     *\n     * ‚ö†Ô∏è If your Type contains morphs, they will be inferred as `unknown` unless\n     * they are an ArkType keyword or have an explicitly defined output validator.\n     *\n     * @typeonly\n     *\n     * @example\n     * const unmorphed = type(\"string\")\n     * // with no morphs, we can introspect the input and output as a single Type\n     * type UnmorphedOut = typeof unmorphed.inferIntrospectableOut // string\n     *\n     * const morphed = type(\"string\").pipe(s => s.length)\n     * // with a standard user-defined morph, TypeScript can infer a\n     * // return type from your function, but we have no way to\n     * // know the shape at runtime\n     * type MorphOut = typeof morphed.inferIntrospectableOut  // unknown\n     *\n     * const validated = type(\"string\").pipe(s => s.length).to(\"number\")\n     * // morphs with validated output, including all morph keywords, are introspectable\n     * type ValidatedMorphOut = typeof validated.inferIntrospectableOut\n     */\n    inferIntrospectableOut: distill.introspectable.Out<t>;\n    /**\n     * #### type of input this allows\n     *\n     * @typeonly\n     *\n     * @example\n     * const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\n     * type UnparsedNumber = typeof parseNumber.inferIn // string\n     */\n    inferIn: distill.In<t>;\n    /**\n     * #### internal JSON representation\n     */\n    json: JsonStructure;\n    /**\n     * alias of {@link json} for `JSON.stringify` compatibility\n     */\n    toJSON(): JsonStructure;\n    /**\n     * #### generate a JSON Schema\n     *\n     * @throws {JsonSchema.UnjsonifiableError} if this cannot be converted to JSON Schema\n     */\n    toJsonSchema(): JsonSchema;\n    /**\n     * #### metadata like custom descriptions and error messages\n     *\n     * ‚úÖ type {@link https://arktype.io/docs/configuration#custom | can be customized} for your project\n     */\n    meta: ArkAmbient.meta;\n    /**\n     * #### human-readable English description\n     *\n     * ‚úÖ works best for primitive values\n     *\n     * @example\n     * const n = type(\"0 < number <= 100\")\n     * console.log(n.description) // positive and at most 100\n     */\n    description: string;\n    /**\n     * #### syntax string similar to native TypeScript\n     *\n     * ‚úÖ works well for both primitives and structures\n     *\n     * @example\n     * const loc = type({ coords: [\"number\", \"number\"] })\n     * console.log(loc.expression) // { coords: [number, number] }\n     */\n    expression: string;\n    /**\n     * #### validate and return transformed data or throw\n     *\n     * ‚úÖ sugar to avoid checking for {@link type.errors} if they are unrecoverable\n     *\n     * @example\n     * const criticalPayload = type({\n     *     superImportantValue: \"string\"\n     * })\n     * // throws TraversalError: superImportantValue must be a string (was missing)\n     * const data = criticalPayload.assert({ irrelevantValue: \"whoops\" })\n     * console.log(data.superImportantValue) // valid output can be accessed directly\n     *\n     * @throws {TraversalError}\n     */\n    assert(data: unknown): this[\"infer\"];\n    /**\n     * #### check input without applying morphs\n     *\n     * ‚úÖ good for stuff like filtering that doesn't benefit from detailed errors\n     *\n     * @example\n     * const numeric = type(\"number | bigint\")\n     * // [0, 2n]\n     * const numerics = [0, \"one\", 2n].filter(numeric.allows)\n     */\n    allows(data: unknown): data is this[\"inferIn\"];\n    /**\n     * #### add metadata to shallow references\n     *\n     * ‚ö†Ô∏è does not affect error messages within properties of an object\n     *\n     * @example\n     * const notOdd = type(\"number % 2\").configure({ description: \"not odd\" })\n     * // all constraints at the root are affected\n     * const odd = notOdd(3) // must be not odd (was 3)\n     * const nonNumber = notOdd(\"two\") // must be not odd (was \"two\")\n     *\n     * const notOddBox = type({\n     *    // we should have referenced notOdd or added meta here\n     *    notOdd: \"number % 2\",\n     * // but instead chained from the root object\n     * }).configure({ description: \"not odd\" })\n     * // error message at path notOdd is not affected\n     * const oddProp = notOddBox({ notOdd: 3 }) // notOdd must be even (was 3)\n     * // error message at root is affected, leading to a misleading description\n     * const nonObject = notOddBox(null) // must be not odd (was null)\n     */\n    configure<meta extends TypeMetaInput>(meta: meta): this;\n    /**\n     * #### add description to shallow references\n     *\n     * üîó equivalent to `.configure({ description })` (see {@link configure})\n     * ‚ö†Ô∏è does not affect error messages within properties of an object\n     *\n     * @example\n     * const aToZ = type(/^a.*z$/).describe(\"a string like 'a...z'\")\n     * const good = aToZ(\"alcatraz\") // \"alcatraz\"\n     * // ArkErrors: must be a string like 'a...z' (was \"albatross\")\n     * const badPattern = aToZ(\"albatross\")\n     */\n    describe(description: string): this;\n    /**\n     * #### apply undeclared key behavior\n     *\n     * {@inheritDoc UndeclaredKeyBehavior}\n     */\n    onUndeclaredKey(behavior: UndeclaredKeyBehavior): this;\n    /**\n     * #### deeply apply undeclared key behavior\n     *\n     * {@inheritDoc UndeclaredKeyBehavior}\n     **/\n    onDeepUndeclaredKey(behavior: UndeclaredKeyBehavior): this;\n    /**\n     * #### alias for {@link assert} with typed input\n     *\n     * @example\n     * const t = type({ foo: \"string\" });\n     * // TypeScript: foo must be a string (was 5)\n     * const data = t.from({ foo: 5 });\n     */\n    from(literal: this[\"inferIn\"]): this[\"infer\"];\n    /**\n     * #### deeply extract inputs\n     *\n     * ‚úÖ will never include morphs\n     * ‚úÖ good for generating JSON Schema or other non-transforming formats\n     *\n     * @example\n     * const createUser = type({\n     *    age: \"string.numeric.parse\"\n     * })\n     * // { age: 25 } (age parsed to a number)\n     * const out = createUser({ age: \"25\" })\n     * // { age: \"25\" } (age is still a string)\n     * const inOut = createUser.in({ age: \"25\" })\n     */\n    get in(): instantiateType<this[\"inferIn\"], $>;\n    /**\n     * #### deeply extract outputs\n     *\n     * ‚úÖ will never include morphs\n     * ‚ö†Ô∏è if your type includes morphs, their output will likely be unknown unless they\n     * were defined with an explicit output validator via `.to(outputDef)` or `.pipe(morph, outputType)`\n     *\n     * @example\n     * const userMorph = type(\"string[]\").pipe(a => a.join(\",\"))\n     *\n     * const t = type({\n     *    // all keywords have introspectable output\n     *    keyword: \"string.numeric.parse\",\n     *    // TypeScript knows this returns a boolean, but we can't introspect that at runtime\n     *    unvalidated: userMorph,\n     *    // if needed, it can be made introspectable with an output validator\n     *    validated: userMorph.to(\"string\")\n     * })\n     *\n     * // Type<{ keyword: number; unvalidated: unknown; validated: string }>\n     * const baseOut = base.out\n     */\n    get out(): instantiateType<this[\"inferIntrospectableOut\"], $>;\n    /**\n     * #### add a compile-time brand to output\n     *\n     * @typenoop\n     *\n     * @example\n     * const palindrome = type(\"string\")\n     *     .narrow(s => s === [...s].reverse().join(\"\"))\n     *     .brand(\"palindrome\")\n     * // Brand<string, \"palindrome\">\n     * const out = palindrome.assert(\"racecar\")\n     */\n    brand<const name extends string, r = instantiateType<type.brand<t, name>, $>>(name: name): r extends infer _ ? _ : never;\n    /**\n     * #### an array of this\n     *\n     * @example\n     * // Type<{ rebmun: number }[]>\n     * const t = type({ rebmun: \"number\" }).array();\n     */\n    array(): Type$5<t[], $>;\n    /**\n     * #### {@link https://arktype.io/docs/objects#properties-optional | optional definition}\n     *\n     * @chainedDefinition\n     *\n     * @example\n     * const prop = type({ foo: \"number\" })\n     * // Type<{ bar?: { foo: number } }>\n     * const obj = type({ bar: prop.optional() })\n     */\n    optional(): [this, \"?\"];\n    /**\n     * #### {@link https://arktype.io/docs/objects#properties-defaultable | defaultable definition}\n     *\n     * ‚úÖ object defaults can be returned from a function\n     * ‚ö†Ô∏è throws if the default value is not allowed\n     * @chainedDefinition\n     *\n     * @example\n     * // Type<{ count: Default<number, 0> }>\n     * const state = type({ count: type.number.default(0) })\n     * const prop = type({ nested: \"boolean\" })\n     * const forObj = type({\n     *     key: nested.default(() => ({ nested: false }))\n     * })\n     */\n    default<const value extends defaultFor<this[\"inferIn\"]>>(value: value): [this, \"=\", value];\n    /**\n     * #### apply a predicate function to input\n     *\n     * ‚ö†Ô∏è the behavior of {@link narrow}, this method's output counterpart, is usually more desirable\n     * ‚úÖ most useful for morphs with input types that are re-used externally\n     * @predicateCast\n     *\n     * @example\n     * const stringifyUser = type({ name: \"string\" }).pipe(user => JSON.stringify(user))\n     * const stringifySafe = stringifyUser.filter(user => user.name !== \"Bobby Tables\")\n     * // Type<(In: `${string}Z`) => To<Date>>\n     * const withPredicate = type(\"string.date.parse\").filter((s): s is `${string}Z` =>\n     *     s.endsWith(\"Z\")\n     * )\n     */\n    filter<narrowed extends this[\"inferIn\"] = never, r = instantiateType<[\n        narrowed\n    ] extends [never] ? t : t extends InferredMorph<any, infer o> ? (In: narrowed) => o : narrowed, $>>(predicate: Predicate.Castable<this[\"inferIn\"], narrowed>): r extends infer _ ? _ : never;\n    /**\n     * #### apply a predicate function to output\n     *\n     * ‚úÖ go-to fallback for validation not composable via builtin types and operators\n     * ‚úÖ runs after all other validators and morphs, if present\n     * @predicateCast\n     *\n     * @example\n     * const palindrome = type(\"string\").narrow(s => s === [...s].reverse().join(\"\"))\n     *\n     * const palindromicEmail = type(\"string.date.parse\").narrow((date, ctx) =>\n     *\t\tdate.getFullYear() === 2025 || ctx.mustBe(\"the current year\")\n     * )\n     * // Type<`${string}.tsx`>\n     * const withPredicate = type(\"string\").narrow((s): s is `${string}.tsx` => /\\.tsx?$/.test(s))\n     */\n    narrow<narrowed extends this[\"infer\"] = never, r = instantiateType<[\n        narrowed\n    ] extends [never] ? t : t extends InferredMorph<infer i, infer o> ? o extends To ? (In: i) => To<narrowed> : (In: i) => Out<narrowed> : narrowed, $>>(predicate: Predicate.Castable<this[\"infer\"], narrowed>): r extends infer _ ? _ : never;\n    /**\n     * #### pipe output through arbitrary transformations or other Types\n     *\n     * @example\n     * const user = type({ name: \"string\" })\n     *\n     * // parse a string and validate that the result as a user\n     * const parseUser = type(\"string\").pipe(s => JSON.parse(s), user)\n     */\n    pipe: ChainedPipe<t, $>;\n    /**\n     * #### parse a definition as an output validator\n     *\n     * üîó `to({ name: \"string\" })` is equivalent to `.pipe(type({ name: \"string\" }))`\n     *\n     * @example\n     * // parse a string and validate that the result as a user\n     * const parseUser = type(\"string\").pipe(s => JSON.parse(s)).to({ name: \"string\" })\n     */\n    to<const def, r = instantiateType<inferPipe<t, type.infer<def, $>>, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n}\n/** @ts-ignore cast variance */\ninterface Type<out t = unknown, $ = {}> extends Callable<(data: unknown) => distill.Out<t> | ArkEnv.onFail>, Inferred<t, $> {\n    /**\n     * #### cast the way this is inferred\n     *\n     * @typenoop\n     *\n     * @example\n     * // Type<`LEEEEEEEE${string}ROY`>\n     * const leeroy = type(/^LE{8,}ROY$/).as<`LEEEEEEEE${string}ROY`>()\n     */\n    as<castTo = unset>(...args: validateChainedAsArgs<castTo>): instantiateType<castTo, $>;\n    /**\n     * #### intersect the parsed Type, throwing if the result is unsatisfiable\n     *\n     * @example\n     * // Type<{ foo: number; bar: string }>\n     * const t = type({ foo: \"number\" }).and({ bar: \"string\" })\n     * // ParseError: Intersection at foo of number and string results in an unsatisfiable type\n     * const bad = type({ foo: \"number\" }).and({ foo: \"string\" })\n     */\n    and<const def, r = instantiateType<inferIntersection<t, type.infer<def, $>>, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * #### union with the parsed Type\n     *\n     * ‚ö†Ô∏è a union that could apply different morphs to the same data is a ParseError ([docs](https://arktype.io/docs/expressions/union-morphs))\n     *\n     * @example\n     * // Type<string | { box: string }>\n     * const t = type(\"string\").or({ box: \"string\" })\n     */\n    or<const def, r = instantiateType<t | type.infer<def, $>, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * #### intersect the parsed Type, returning an introspectable {@link Disjoint} if the result is unsatisfiable\n     *\n     * @example\n     * // Type<{ foo: number; bar: string }>\n     * const t = type({ foo: \"number\" }).intersect({ bar: \"string\" })\n     * const bad = type(\"number > 10\").intersect(\"number < 5\")\n     * // logs \"Intersection of > 10 and < 5 results in an unsatisfiable type\"\n     * if (bad instanceof Disjoint) console.log(`${bad.summary}`)\n     */\n    intersect<const def, r = instantiateType<inferIntersection<t, type.infer<def, $>>, $>>(def: type.validate<def, $>): r extends infer _ ? _ | Disjoint : never;\n    /**\n     * #### check if the parsed Type's constraints are identical\n     *\n     * ‚úÖ equal types have identical input and output constraints and transforms\n     * @ignoresMeta\n     *\n     * @example\n     * const divisibleBy6 = type.number.divisibleBy(6).moreThan(0)\n     * // false (left side must also be positive)\n     * divisibleBy6.equals(\"number % 6\")\n     * // false (right side has an additional <100 constraint)\n     * console.log(divisibleBy6.equals(\"0 < (number % 6) < 100\"))\n     * const thirdTry = type(\"(number % 2) > 0\").divisibleBy(3)\n     * // true (types are normalized and reduced)\n     * console.log(divisibleBy6.equals(thirdTry))\n     */\n    equals<const def>(def: type.validate<def, $>): boolean;\n    /**\n     * #### narrow this based on an {@link equals} check\n     *\n     * @ignoresMeta\n     *\n     * @example\n     * const n = type.raw(`${Math.random()}`)\n     * // Type<0.5> | undefined\n     * const ez = n.ifEquals(\"0.5\")\n     */\n    ifEquals<const def, r = type.instantiate<def, $>>(def: type.validate<def, $>): r extends infer _ ? _ | undefined : never;\n    /**\n     * #### check if this is a subtype of the parsed Type\n     *\n     * ‚úÖ a subtype must include all constraints from the base type\n     * ‚úÖ unlike {@link equals}, additional constraints may be present\n     * @ignoresMeta\n     *\n     * @example\n     * type.string.extends(\"unknown\") // true\n     * type.string.extends(/^a.*z$/) // false\n     */\n    extends<const def>(other: type.validate<def, $>): boolean;\n    /**\n     * #### narrow this based on an {@link extends} check\n     *\n     * @ignoresMeta\n     *\n     * @example\n     * const n = type(Math.random() > 0.5 ? \"true\" : \"0\") // Type<0 | true>\n     * const ez = n.ifExtends(\"boolean\") // Type<true> | undefined\n     */\n    ifExtends<const def, r = type.instantiate<def, $>>(other: type.validate<def, $>): r extends infer _ ? _ | undefined : never;\n    /**\n     * #### check if a value could satisfy this and the parsed Type\n     *\n     * ‚ö†Ô∏è will return true unless a {@link Disjoint} can be proven\n     *\n     * @example\n     * type.string.overlaps(\"string | number\") // true (e.g. \"foo\")\n     * type(\"string | number\").overlaps(\"1\") // true (1)\n     * type(\"number > 0\").overlaps(\"number < 0\") // false (no values exist)\n     *\n     * const noAt = type(\"string\").narrow(s => !s.includes(\"@\"))\n     * noAt.overlaps(\"string.email\") // true (no values exist, but not provable)\n     */\n    overlaps<const def>(r: type.validate<def, $>): boolean;\n    /**\n     * #### extract branches {@link extend}ing the parsed Type\n     *\n     * @example\n     * // Type<true | 0 | 2>\n     * const t = type(\"boolean | 0 | 'one' | 2 | bigint\").extract(\"number | 0n | true\")\n     */\n    extract<const def, r = instantiateType<t extends type.infer<def, $> ? t : never, $>>(r: type.validate<def, $>): r extends infer _ extends r ? _ : never;\n    /**\n     * #### exclude branches {@link extend}ing the parsed Type\n     *\n     * @example\n     *\n     * // Type<false | 'one' | bigint>\n     * const t = type(\"boolean | 0 | 'one' | 2 | bigint\").exclude(\"number | 0n | true\")\n     */\n    exclude<const def, r = instantiateType<t extends type.infer<def, $> ? never : t, $>>(r: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * @experimental\n     * Map and optionally reduce branches of a union. Types that are not unions\n     * are treated as a single branch.\n     *\n     * @param mapBranch - the mapping function, accepting a branch Type\n     *     Returning another `Type` is common, but any value can be returned and\n     *     inferred as part of the output.\n     *\n     * @param [reduceMapped] - an operation to perform on the mapped branches\n     *     Can be used to e.g. merge an array of returned Types representing\n     *     branches back to a single union.\n     */\n    distribute<mapOut, reduceOut = mapOut[]>(mapBranch: (branch: Type, i: number, branches: array<Type>) => mapOut, reduceMapped?: (mappedBranches: mapOut[]) => reduceOut): reduceOut;\n    /** The Type's [StandardSchema](https://github.com/standard-schema/standard-schema) properties */\n    \"~standard\": StandardSchemaV1.ArkTypeProps<this[\"inferIn\"], this[\"inferOut\"]>;\n    /** @deprecated */\n    apply: Function[\"apply\"];\n    /** @deprecated */\n    bind: Function[\"bind\"];\n    /** @deprecated */\n    call: Function[\"call\"];\n    /** @deprecated */\n    caller: Function;\n    /** @deprecated */\n    length: number;\n    /** @deprecated */\n    name: string;\n    /** @deprecated */\n    prototype: Function[\"prototype\"];\n    /** @deprecated */\n    arguments: Function[\"arguments\"];\n    /** @deprecated */\n    Symbol: never;\n}\ninterface ChainedPipeSignature<t, $> {\n    <a extends Morph<distill.Out<t>>, r = instantiateType<inferPipes<t, [a]>, $>>(a: a): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<t>>, b extends Morph<inferMorphOut<a>>, r = instantiateType<inferPipes<t, [a, b]>, $>>(a: a, b: b): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<t>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, r = instantiateType<inferPipes<t, [a, b, c]>, $>>(a: a, b: b, c: c): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<t>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, r = instantiateType<inferPipes<t, [a, b, c, d]>, $>>(a: a, b: b, c: c, d: d): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<t>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, r = instantiateType<inferPipes<t, [a, b, c, d, e]>, $>>(a: a, b: b, c: c, d: d, e: e): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<t>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, r = instantiateType<inferPipes<t, [a, b, c, d, e, f]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<t>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, r = instantiateType<inferPipes<t, [a, b, c, d, e, f, g]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g): r extends infer _ ? _ : never;\n}\ninterface ChainedPipe<t, $> extends ChainedPipeSignature<t, $> {\n    try: ChainedPipeSignature<t, $>;\n}\ntype validateChainedAsArgs<t> = [\n    t\n] extends [unset] ? [\n    t\n] extends [anyOrNever] ? [\n] : [\n    ErrorMessage<\"as requires an explicit type parameter like myType.as<t>()\">\n] : [];\n\ntype MatchParserContext<input = unknown> = {\n    cases: Morph[];\n    $: unknown;\n    input: input;\n    checked: boolean;\n    key: PropertyKey | null;\n};\ndeclare namespace ctx {\n    type from<ctx extends MatchParserContext> = ctx;\n    type init<$, input = unknown, checked extends boolean = false> = from<{\n        cases: [];\n        $: $;\n        input: input;\n        checked: checked;\n        key: null;\n    }>;\n    type atKey<ctx extends MatchParserContext, key extends string> = from<{\n        cases: ctx[\"cases\"];\n        $: ctx[\"$\"];\n        input: ctx[\"input\"];\n        checked: ctx[\"checked\"];\n        key: key;\n    }>;\n}\ninterface MatchParser<$> extends CaseMatchParser<ctx.init<$>> {\n    in<const def>(def: type.validate<def, $>): ChainableMatchParser<ctx.init<$, type.infer<def, $>, true>>;\n    in<const typedInput = never>(...args: [typedInput] extends [never] ? [\n        ErrorMessage<\"in requires a definition or type argument (in('string') or in<string>())\">\n    ] : []): ChainableMatchParser<ctx.init<$, typedInput>>;\n    in<const def>(def: type.validate<def, $>): ChainableMatchParser<ctx.init<$, type.infer<def, $>, true>>;\n    case: CaseParser<ctx.init<$>>;\n    at: AtParser<ctx.init<$>>;\n}\ntype addCasesToContext<ctx extends MatchParserContext, cases extends unknown[]> = cases extends Morph[] ? ctx.from<{\n    $: ctx[\"$\"];\n    input: ctx[\"input\"];\n    cases: [...ctx[\"cases\"], ...cases];\n    checked: ctx[\"checked\"];\n    key: ctx[\"key\"];\n}> : never;\ntype addDefaultToContext<ctx extends MatchParserContext, defaultCase extends DefaultCase<ctx>> = ctx.from<{\n    $: ctx[\"$\"];\n    input: defaultCase extends \"never\" ? Morph.In<ctx[\"cases\"][number]> : ctx[\"input\"];\n    cases: defaultCase extends \"never\" | \"assert\" ? ctx[\"cases\"] : defaultCase extends Morph ? ctx[\"checked\"] extends true ? [\n        (In: unknown) => ArkErrors,\n        ...ctx[\"cases\"],\n        defaultCase\n    ] : [...ctx[\"cases\"], defaultCase] : [\n        ...ctx[\"cases\"],\n        (In: ctx[\"input\"]) => ArkErrors\n    ];\n    checked: ctx[\"checked\"];\n    key: ctx[\"key\"];\n}>;\ntype CaseKeyKind = \"def\" | \"string\";\ntype casesToMorphTuple<cases, ctx extends MatchParserContext, kind extends CaseKeyKind> = unionToTuple<propValueOf<{\n    [def in Exclude<keyof cases, \"default\">]: cases[def] extends (Morph<never, infer o>) ? kind extends \"def\" ? (In: inferCaseArg<def extends number ? `${number}` : def, ctx, \"in\">) => o : (In: maybeLiftToKey<def, ctx>) => o : never;\n}>>;\ntype addCasesToParser<cases, ctx extends MatchParserContext, kind extends CaseKeyKind> = cases extends {\n    default: infer defaultDef extends DefaultCase<ctx>;\n} ? finalizeMatchParser<addCasesToContext<ctx, casesToMorphTuple<cases, ctx, kind>>, defaultDef> : ChainableMatchParser<addCasesToContext<ctx, casesToMorphTuple<cases, ctx, kind>>>;\ntype inferCaseArg<def, ctx extends MatchParserContext, endpoint extends \"in\" | \"out\"> = _finalizeCaseArg<maybeLiftToKey<type.infer<def, ctx[\"$\"]>, ctx>, ctx, endpoint>;\ntype maybeLiftToKey<t, ctx extends MatchParserContext> = ctx[\"key\"] extends PropertyKey ? {\n    [k in ctx[\"key\"]]: t;\n} : t;\ntype _finalizeCaseArg<t, ctx extends MatchParserContext, endpoint extends \"in\" | \"out\"> = [\n    distill<t, \"in\">,\n    distill<t, endpoint>\n] extends [infer i, infer result] ? i extends ctx[\"input\"] ? result : Extract<ctx[\"input\"], i> extends never ? result : Extract<ctx[\"input\"], result> : never;\ntype CaseParser<ctx extends MatchParserContext> = <const def, ret>(def: type.validate<def, ctx[\"$\"]>, resolve: (In: inferCaseArg<def, ctx, \"out\">) => ret) => ChainableMatchParser<addCasesToContext<ctx, [(In: inferCaseArg<def, ctx, \"in\">) => ret]>>;\ntype validateKey<key extends Key, ctx extends MatchParserContext> = ctx[\"key\"] extends Key ? ErrorMessage<doubleAtMessage> : ctx[\"cases\"][\"length\"] extends 0 ? keyof ctx[\"input\"] extends never ? key : conform<key, keyof ctx[\"input\"]> : ErrorMessage<chainedAtMessage>;\ninterface StringsParser<ctx extends MatchParserContext> {\n    <const cases>(def: cases extends validateStringCases<cases, ctx> ? cases : validateStringCases<cases, ctx>): addCasesToParser<cases, ctx, \"string\">;\n}\ntype validateStringCases<cases, ctx extends MatchParserContext> = {\n    [k in keyof cases | stringValue<ctx> | \"default\"]?: k extends \"default\" ? DefaultCase<ctx> : k extends stringValue<ctx> ? (In: _finalizeCaseArg<maybeLiftToKey<k, ctx>, ctx, \"out\">) => unknown : ErrorType<`${k & string} must be a possible string value`>;\n};\ntype stringValue<ctx extends MatchParserContext> = ctx[\"key\"] extends keyof ctx[\"input\"] ? ctx[\"input\"][ctx[\"key\"]] extends string ? ctx[\"input\"][ctx[\"key\"]] : never : ctx[\"input\"] extends string ? ctx[\"input\"] : never;\ninterface AtParser<ctx extends MatchParserContext> {\n    <const key extends string>(key: validateKey<key, ctx>): ChainableMatchParser<ctx.atKey<ctx, key>>;\n    <const key extends string, const cases, ctxAtKey extends MatchParserContext = ctx.atKey<ctx, key>>(key: validateKey<key, ctx>, cases: cases extends validateCases<cases, ctxAtKey> ? cases : errorCases<cases, ctxAtKey>): addCasesToParser<cases, ctxAtKey, \"def\">;\n}\ninterface ChainableMatchParser<ctx extends MatchParserContext> {\n    case: CaseParser<ctx>;\n    match: CaseMatchParser<ctx>;\n    default: DefaultMethod<ctx>;\n    at: AtParser<ctx>;\n    /** @experimental */\n    strings: StringsParser<ctx>;\n}\ntype DefaultCaseKeyword = \"never\" | \"assert\" | \"reject\";\ntype DefaultCase<ctx extends MatchParserContext = MatchParserContext<any>> = DefaultCaseKeyword | Morph<ctx[\"input\"]>;\ntype DefaultMethod<ctx extends MatchParserContext> = <const def extends DefaultCase<ctx>>(def: def) => finalizeMatchParser<ctx, def>;\ntype validateCases<cases, ctx extends MatchParserContext> = {\n    [def in keyof cases | BaseCompletions<ctx[\"$\"], {}, \"default\">]?: def extends \"default\" ? DefaultCase<ctx> : def extends number ? (In: inferCaseArg<`${def}`, ctx, \"out\">) => unknown : def extends type.validate<def, ctx[\"$\"]> ? (In: inferCaseArg<def, ctx, \"out\">) => unknown : type.validate<def, ctx[\"$\"]>;\n};\ntype errorCases<cases, ctx extends MatchParserContext> = {\n    [def in keyof cases]?: def extends \"default\" ? DefaultCase<ctx> : def extends number ? (In: inferCaseArg<`${def}`, ctx, \"out\">) => unknown : def extends type.validate<def, ctx[\"$\"]> ? (In: inferCaseArg<def, ctx, \"out\">) => unknown : ErrorType<type.validate<def, ctx[\"$\"]>>;\n} & {\n    [k in BaseCompletions<ctx[\"$\"], {}>]?: (In: inferCaseArg<k, ctx, \"out\">) => unknown;\n} & {\n    default?: DefaultCase<ctx>;\n};\ntype CaseMatchParser<ctx extends MatchParserContext> = <const cases>(def: cases extends validateCases<cases, ctx> ? cases : errorCases<cases, ctx>) => addCasesToParser<cases, ctx, \"def\">;\ntype finalizeMatchParser<ctx extends MatchParserContext, defaultCase extends DefaultCase<ctx>> = addDefaultToContext<ctx, defaultCase> extends (infer ctx extends MatchParserContext) ? Match<ctx[\"input\"], ctx[\"cases\"]> : never;\ninterface Match<In = any, cases extends Morph[] = Morph[]> extends Inferred<(In: Morph.In<cases[number]>) => Out<ReturnType<cases[number]>>> {\n    <const data extends In>(data: data): {\n        [i in numericStringKeyOf<cases>]: isDisjoint<data, Morph.In<cases[i]>> extends true ? never : Morph.Out<cases[i]>;\n    }[numericStringKeyOf<cases>];\n}\ndeclare class InternalMatchParser extends Callable<InternalCaseParserFn> {\n    $: InternalScope;\n    constructor($: InternalScope);\n    in(def?: unknown): InternalChainedMatchParser;\n    at(key: Key, cases?: InternalCases): InternalChainedMatchParser | Match;\n    case(when: unknown, then: Morph): InternalChainedMatchParser;\n}\ntype InternalCases = Record<string, Morph | DefaultCase>;\ntype InternalCaseParserFn = (cases: InternalCases) => InternalChainedMatchParser | Match;\ntype CaseEntry = [BaseRoot, Morph] | [\"default\", DefaultCase];\ndeclare class InternalChainedMatchParser extends Callable<InternalCaseParserFn> {\n    $: InternalScope;\n    in: BaseRoot | undefined;\n    protected key: Key | undefined;\n    protected branches: BaseRoot[];\n    constructor($: InternalScope, In?: BaseRoot);\n    at(key: Key, cases?: InternalCases): InternalChainedMatchParser | Match;\n    case(def: unknown, resolver: Morph): InternalChainedMatchParser;\n    protected caseEntry(node: BaseRoot, resolver: Morph): InternalChainedMatchParser;\n    match(cases: InternalCases): InternalChainedMatchParser | Match;\n    strings(cases: InternalCases): InternalChainedMatchParser | Match;\n    protected caseEntries(entries: CaseEntry[]): InternalChainedMatchParser | Match;\n    default(defaultCase: DefaultCase): Match;\n}\ndeclare const chainedAtMessage = \"A key matcher must be specified before the first case i.e. match.at('foo') or match.in<object>().at('bar')\";\ntype chainedAtMessage = typeof chainedAtMessage;\ndeclare const doubleAtMessage = \"At most one key matcher may be specified per expression\";\ntype doubleAtMessage = typeof doubleAtMessage;\n\ndeclare class MergeHkt extends Hkt<[base: object, props: object]> {\n    body: util.merge<this[0], this[1]>;\n}\ndeclare const Merge: _ark_schema.GenericRoot<readonly [[\"base\", object], [\"props\", object]], MergeHkt>;\ndeclare const arkBuiltins: arkBuiltins;\ntype arkBuiltins = Module<arkBuiltins.$>;\ndeclare namespace arkBuiltins {\n    type submodule = Submodule<$>;\n    type $ = {\n        Key: Key;\n        Merge: typeof Merge.t;\n    };\n}\n\ndeclare const number: number.module;\ndeclare namespace number {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: number;\n        epoch: number;\n        integer: number;\n        safe: number;\n        NaN: number;\n        Infinity: number;\n        NegativeInfinity: number;\n    };\n}\n\ndeclare const stringInteger: stringInteger.module;\ndeclare namespace stringInteger {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        parse: (In: string) => To<number>;\n    };\n}\ndeclare const base64: Module<{\n    root: unknown;\n    url: unknown;\n}>;\ndeclare namespace base64 {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        url: string;\n    };\n}\ndeclare const capitalize: capitalize.module;\ndeclare namespace capitalize {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: (In: string) => To<string>;\n        preformatted: string;\n    };\n}\ndeclare const stringDate: stringDate.module;\ndeclare namespace stringDate {\n    type module = Module<stringDate.submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        parse: (In: string) => To<Date>;\n        iso: iso.submodule;\n        epoch: epoch.submodule;\n    };\n    namespace iso {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: string;\n            parse: (In: string) => To<Date>;\n        };\n    }\n    namespace epoch {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: string;\n            parse: (In: string) => To<Date>;\n        };\n    }\n}\ndeclare const ip: ip.module;\ndeclare namespace ip {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        v4: string;\n        v6: string;\n    };\n}\ndeclare namespace stringJson {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        parse: (In: string) => To<Json>;\n    };\n}\ndeclare namespace lower {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: (In: string) => To<string>;\n        preformatted: string;\n    };\n}\ndeclare const normalize: Module<{\n    root: unknown;\n    NFC: Submodule<{\n        root: unknown;\n        preformatted: unknown;\n    }>;\n    NFD: Submodule<{\n        root: unknown;\n        preformatted: unknown;\n    }>;\n    NFKC: Submodule<{\n        root: unknown;\n        preformatted: unknown;\n    }>;\n    NFKD: Submodule<{\n        root: unknown;\n        preformatted: unknown;\n    }>;\n}>;\ndeclare namespace normalize {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: (In: string) => To<string>;\n        NFC: NFC.submodule;\n        NFD: NFD.submodule;\n        NFKC: NFKC.submodule;\n        NFKD: NFKD.submodule;\n    };\n    namespace NFC {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: (In: string) => To<string>;\n            preformatted: string;\n        };\n    }\n    namespace NFD {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: (In: string) => To<string>;\n            preformatted: string;\n        };\n    }\n    namespace NFKC {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: (In: string) => To<string>;\n            preformatted: string;\n        };\n    }\n    namespace NFKD {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: (In: string) => To<string>;\n            preformatted: string;\n        };\n    }\n}\ndeclare namespace stringNumeric {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        parse: (In: string) => To<number>;\n    };\n}\ndeclare namespace trim {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: (In: string) => To<string>;\n        preformatted: string;\n    };\n}\ndeclare const upper: upper.module;\ndeclare namespace upper {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: (In: string) => To<string>;\n        preformatted: string;\n    };\n}\ndeclare const url: url.module;\ndeclare namespace url {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        parse: (In: string) => To<URL>;\n    };\n}\ndeclare const uuid: Module<{\n    root: string;\n    v4: unknown;\n    v6: unknown;\n    v1: unknown;\n    v2: unknown;\n    v3: unknown;\n    v5: unknown;\n    v7: unknown;\n    v8: unknown;\n}>;\ndeclare namespace uuid {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        v1: string;\n        v2: string;\n        v3: string;\n        v4: string;\n        v5: string;\n        v6: string;\n        v7: string;\n        v8: string;\n    };\n    namespace $ {\n        type flat = {};\n    }\n}\ndeclare const string: Module<{\n    integer: Submodule<stringInteger.submodule>;\n    trim: Submodule<trim.submodule>;\n    normalize: Submodule<{\n        root: unknown;\n        NFC: Submodule<{\n            root: unknown;\n            preformatted: unknown;\n        }>;\n        NFD: Submodule<{\n            root: unknown;\n            preformatted: unknown;\n        }>;\n        NFKC: Submodule<{\n            root: unknown;\n            preformatted: unknown;\n        }>;\n        NFKD: Submodule<{\n            root: unknown;\n            preformatted: unknown;\n        }>;\n    }>;\n    root: unknown;\n    json: Submodule<stringJson.submodule>;\n    date: Submodule<stringDate.submodule>;\n    lower: Submodule<lower.submodule>;\n    upper: Submodule<upper.submodule>;\n    alpha: unknown;\n    alphanumeric: unknown;\n    hex: unknown;\n    base64: Submodule<{\n        root: unknown;\n        url: unknown;\n    }>;\n    capitalize: Submodule<capitalize.submodule>;\n    creditCard: unknown;\n    digits: unknown;\n    email: unknown;\n    ip: Submodule<ip.submodule>;\n    numeric: Submodule<stringNumeric.submodule>;\n    semver: unknown;\n    url: Submodule<url.submodule>;\n    uuid: Submodule<{\n        root: string;\n        v4: unknown;\n        v6: unknown;\n        v1: unknown;\n        v2: unknown;\n        v3: unknown;\n        v5: unknown;\n        v7: unknown;\n        v8: unknown;\n    }>;\n}>;\ndeclare namespace string {\n    type module = Module<string.submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        alpha: string;\n        alphanumeric: string;\n        hex: string;\n        base64: base64.submodule;\n        capitalize: capitalize.submodule;\n        creditCard: string;\n        date: stringDate.submodule;\n        digits: string;\n        email: string;\n        integer: stringInteger.submodule;\n        ip: ip.submodule;\n        json: stringJson.submodule;\n        lower: lower.submodule;\n        normalize: normalize.submodule;\n        numeric: stringNumeric.submodule;\n        semver: string;\n        trim: trim.submodule;\n        upper: upper.submodule;\n        url: url.submodule;\n        uuid: uuid.submodule;\n    };\n}\n\ndeclare const arkTsKeywords: arkTsKeywords;\ntype arkTsKeywords = Module<arkTsKeywords.$>;\ndeclare namespace arkTsKeywords {\n    type submodule = Submodule<$>;\n    type $ = {\n        bigint: bigint;\n        boolean: boolean;\n        false: false;\n        never: never;\n        null: null;\n        number: number;\n        object: object;\n        string: string;\n        symbol: symbol;\n        true: true;\n        unknown: unknown;\n        undefined: undefined;\n    };\n}\ndeclare const unknown: Module<{\n    any: unknown;\n    root: unknown;\n}>;\ndeclare namespace unknown {\n    type submodule = Submodule<$>;\n    type $ = {\n        root: unknown;\n        any: any;\n    };\n}\ndeclare const json: Module<{\n    stringify: unknown;\n    root: unknown;\n}>;\ndeclare namespace json {\n    type submodule = Submodule<$>;\n    type $ = {\n        root: Json;\n        stringify: (In: Json) => To<string>;\n    };\n}\ndeclare const object: Module<{\n    root: unknown;\n    json: Submodule<{\n        stringify: unknown;\n        root: unknown;\n    }>;\n}>;\ndeclare namespace object {\n    type submodule = Submodule<$>;\n    type $ = {\n        root: object;\n        json: json.submodule;\n    };\n}\ndeclare class RecordHkt extends Hkt<[Key, unknown]> {\n    body: Record$1<this[0], this[1]>;\n    description: string;\n}\ndeclare const Record$1: _ark_schema.GenericRoot<readonly [[\"K\", Key], [\"V\", unknown]], RecordHkt>;\ndeclare class PickHkt extends Hkt<[object, Key]> {\n    body: pick<this[0], this[1] & keyof this[0]>;\n}\ndeclare const Pick: _ark_schema.GenericRoot<readonly [[\"T\", object], [\"K\", Key]], PickHkt>;\ndeclare class OmitHkt extends Hkt<[object, Key]> {\n    body: omit<this[0], this[1] & keyof this[0]>;\n}\ndeclare const Omit$1: _ark_schema.GenericRoot<readonly [[\"T\", object], [\"K\", Key]], OmitHkt>;\ndeclare class PartialHkt extends Hkt<[object]> {\n    body: show<Partial<this[0]>>;\n}\ndeclare const Partial: _ark_schema.GenericRoot<readonly [[\"T\", object]], PartialHkt>;\ndeclare class RequiredHkt extends Hkt<[object]> {\n    body: show<Required<this[0]>>;\n}\ndeclare const Required: _ark_schema.GenericRoot<readonly [[\"T\", object]], RequiredHkt>;\ndeclare class ExcludeHkt extends Hkt<[unknown, unknown]> {\n    body: Exclude$1<this[0], this[1]>;\n}\ndeclare const Exclude$1: _ark_schema.GenericRoot<readonly [[\"T\", unknown], [\"U\", unknown]], ExcludeHkt>;\ndeclare class ExtractHkt extends Hkt<[unknown, unknown]> {\n    body: Extract$1<this[0], this[1]>;\n}\ndeclare const Extract$1: _ark_schema.GenericRoot<readonly [[\"T\", unknown], [\"U\", unknown]], ExtractHkt>;\ndeclare const arkTsGenerics: arkTsGenerics.module;\ndeclare namespace arkTsGenerics {\n    type module = Module<arkTsGenerics.$>;\n    type submodule = Submodule<$>;\n    type $ = {\n        Exclude: typeof Exclude$1.t;\n        Extract: typeof Extract$1.t;\n        Omit: typeof Omit$1.t;\n        Partial: typeof Partial.t;\n        Pick: typeof Pick.t;\n        Record: typeof Record$1.t;\n        Required: typeof Required.t;\n    };\n}\n\ninterface Ark extends Omit<Ark.keywords, keyof Ark.wrapped>, Ark.wrapped {\n}\ndeclare namespace Ark {\n    interface keywords extends arkTsKeywords.$, arkTsGenerics.$, arkPrototypes.keywords, arkBuiltins.$ {\n    }\n    interface wrapped extends arkPrototypes.wrapped {\n        string: string.submodule;\n        number: number.submodule;\n        object: object.submodule;\n        unknown: unknown.submodule;\n    }\n    type flat = flatResolutionsOf<Ark>;\n    interface typeAttachments extends arkTsKeywords.$ {\n        arrayIndex: arkPrototypes.$[\"Array\"][\"index\"];\n        Key: arkBuiltins.$[\"Key\"];\n        Record: arkTsGenerics.$[\"Record\"];\n        Date: arkPrototypes.$[\"Date\"];\n        Array: arkPrototypes.$[\"Array\"][\"root\"];\n    }\n    interface boundTypeAttachments<$> extends Omit<BoundModule<typeAttachments, $>, arkKind> {\n    }\n}\ndeclare const ark: Scope<Ark>;\ndeclare const keywords: Module<Ark>;\ndeclare const type: TypeParser<{}>;\ndeclare namespace type {\n    interface cast<to> {\n        [inferred]?: to;\n    }\n    type errors = ArkErrors;\n    type infer<def, $ = {}, args = bindThis<def>> = inferDefinition<def, $, args>;\n    namespace infer {\n        type In<def, $ = {}, args = {}> = distill.In<inferDefinition<def, $, args>>;\n        type Out<def, $ = {}, args = {}> = distill.Out<inferDefinition<def, $, args>>;\n        namespace introspectable {\n            type Out<def, $ = {}, args = {}> = distill.introspectable.Out<inferDefinition<def, $, args>>;\n        }\n    }\n    type validate<def, $ = {}, args = bindThis<def>> = validateDefinition<def, $, args>;\n    type instantiate<def, $ = {}, args = bindThis<def>> = instantiateType<inferDefinition<def, $, args>, $>;\n    type brand<t, id> = t extends InferredMorph<infer i, infer o> ? o[\"introspectable\"] extends true ? (In: i) => To<Brand<o[\"t\"], id>> : (In: i) => Out<Brand<o[\"t\"], id>> : Brand<t, id>;\n    /** @ts-ignore cast variance */\n    interface Any<out t = any> extends Type<t, any> {\n    }\n}\ntype type<t = unknown, $ = {}> = Type$1<t, $>;\ndeclare const match: MatchParser<{}>;\ndeclare const generic: GenericParser<{}>;\ndeclare const define: DefinitionParser<{}>;\ndeclare const declare: DeclarationParser<{}>;\n\ntype ParameterString<params extends string = string> = `<${params}>`;\ntype extractParams<s extends ParameterString> = s extends ParameterString<infer params> ? params : never;\ntype validateParameterString<s extends ParameterString, $> = parseGenericParams<extractParams<s>, $> extends infer e extends ErrorMessage ? e : s;\ntype validateGenericArg<arg, param extends GenericParamAst, $> = type.infer<arg, $> extends param[1] ? unknown : ErrorType<`Invalid argument for ${param[0]}`, [expected: param[1]]>;\ntype GenericInstantiator<params extends array<GenericParamAst>, def, $, args$> = params[\"length\"] extends 1 ? {\n    <const a, r = instantiateGeneric<def, params, [a], $, args$>>(a: type.validate<a, args$> & validateGenericArg<a, params[0], args$>): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 2 ? {\n    <const a, const b, r = instantiateGeneric<def, params, [a, b], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 3 ? {\n    <const a, const b, const c, r = instantiateGeneric<def, params, [a, b, c], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 4 ? {\n    <const a, const b, const c, const d, r = instantiateGeneric<def, params, [a, b, c, d], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>,\n        type.validate<d, args$> & validateGenericArg<d, params[3], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 5 ? {\n    <const a, const b, const c, const d, const e, r = instantiateGeneric<def, params, [a, b, c, d, e], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>,\n        type.validate<d, args$> & validateGenericArg<d, params[3], args$>,\n        type.validate<e, args$> & validateGenericArg<e, params[4], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 6 ? {\n    <const a, const b, const c, const d, const e, const f, r = instantiateGeneric<def, params, [a, b, c, d, e, f], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>,\n        type.validate<d, args$> & validateGenericArg<d, params[3], args$>,\n        type.validate<e, args$> & validateGenericArg<e, params[4], args$>,\n        type.validate<f, args$> & validateGenericArg<f, params[5], args$>\n    ]): r extends infer _ ? _ : never;\n} : (error: ErrorMessage<`You may not define more than 6 positional generic parameters`>) => never;\ntype instantiateGeneric<def, params extends array<GenericParamAst>, args, $, args$> = Type$1<[\n    def\n] extends [Hkt] ? Hkt.apply<def, {\n    [i in keyof args]: type.infer<args[i], args$>;\n}> : inferDefinition<def, $, bindGenericArgs<params, args$, args>>, args$>;\ntype bindGenericArgs<params extends array<GenericParamAst>, $, args> = {\n    [i in keyof params & `${number}` as params[i][0]]: type.infer<args[i & keyof args], $>;\n};\ntype baseGenericResolutions<params extends array<GenericParamAst>, $> = baseGenericConstraints<params> extends infer baseConstraints ? {\n    [k in keyof baseConstraints]: Type$1<baseConstraints[k], $>;\n} : never;\ntype baseGenericConstraints<params extends array<GenericParamAst>> = {\n    [i in keyof params & `${number}` as params[i][0]]: params[i][1];\n};\ntype GenericConstructor<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown, $ = {}, arg$ = {}> = new () => Generic<params, bodyDef, $, arg$>;\ninterface Generic<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown, $ = {}, arg$ = $> extends Callable<GenericInstantiator<params, bodyDef, $, arg$>> {\n    [arkKind]: \"generic\";\n    t: GenericAst<params, bodyDef, $, arg$>;\n    bodyDef: bodyDef;\n    params: {\n        [i in keyof params]: [params[i][0], Type$1<params[i][1], $>];\n    };\n    names: genericParamNames<params>;\n    constraints: {\n        [i in keyof params]: Type$1<params[i][1], $>;\n    };\n    $: Scope<$>;\n    arg$: Scope<arg$>;\n    internal: GenericRoot;\n    json: JsonStructure;\n}\ndeclare const Generic: GenericConstructor;\ntype GenericDeclaration<name extends string = string, params extends ParameterString = ParameterString> = `${name}${params}`;\ntype parseValidGenericParams<def extends ParameterString, $> = conform<parseGenericParams<extractParams<def>, $>, array<GenericParamAst>>;\ndeclare const emptyGenericParameterMessage = \"An empty string is not a valid generic parameter name\";\ntype emptyGenericParameterMessage = typeof emptyGenericParameterMessage;\ntype parseGenericParams<def extends string, $> = parseNextNameChar<ArkTypeScanner.skipWhitespace<def>, \"\", [\n], $>;\ntype ParamsTerminator = WhitespaceChar | \",\";\ntype parseName<unscanned extends string, result extends array<GenericParamAst>, $> = parseNextNameChar<ArkTypeScanner.skipWhitespace<unscanned>, \"\", result, $>;\ntype parseNextNameChar<unscanned extends string, name extends string, result extends array<GenericParamAst>, $> = unscanned extends `${infer lookahead}${infer nextUnscanned}` ? lookahead extends ParamsTerminator ? name extends \"\" ? ErrorMessage<emptyGenericParameterMessage> : lookahead extends \",\" ? parseName<nextUnscanned, [...result, [name, unknown]], $> : lookahead extends WhitespaceChar ? _parseOptionalConstraint<nextUnscanned, name, result, $> : never : parseNextNameChar<nextUnscanned, `${name}${lookahead}`, result, $> : name extends \"\" ? result : [...result, [name, unknown]];\ndeclare const extendsToken = \"extends \";\ntype extendsToken = typeof extendsToken;\ndeclare const _parseOptionalConstraint: (scanner: ArkTypeScanner, name: string, result: GenericParamDef[], ctx: BaseParseContext) => GenericParamDef[];\ntype _parseOptionalConstraint<unscanned extends string, name extends string, result extends array<GenericParamAst>, $> = ArkTypeScanner.skipWhitespace<unscanned> extends (`${extendsToken}${infer nextUnscanned}`) ? parseUntilFinalizer<state.initialize<nextUnscanned>, $, {}> extends (infer finalArgState extends StaticState) ? validateAst<finalArgState[\"root\"], $, {}> extends (infer e extends ErrorMessage) ? e : parseName<finalArgState[\"unscanned\"], [\n    ...result,\n    [name, inferAstRoot<finalArgState[\"root\"], $, {}>]\n], $> : never : parseName<ArkTypeScanner.skipWhitespace<unscanned> extends (`,${infer nextUnscanned}`) ? nextUnscanned : unscanned, [\n    ...result,\n    [name, unknown]\n], $>;\ntype genericParamDefToAst<schema extends GenericParamDef, $> = schema extends string ? [schema, unknown] : schema extends readonly [infer name, infer def] ? [name, type.infer<def, $>] : never;\ntype genericParamDefsToAst<defs extends array<GenericParamDef>, $> = [\n    ...{\n        [i in keyof defs]: genericParamDefToAst<defs[i], $>;\n    }\n];\ntype GenericParser<$ = {}> = <const paramsDef extends array<GenericParamDef>>(...params: {\n    [i in keyof paramsDef]: paramsDef[i] extends (readonly [infer name, infer def]) ? readonly [name, type.validate<def, $>] : paramsDef[i];\n}) => GenericBodyParser<genericParamDefsToAst<paramsDef, $>, $>;\ninterface GenericBodyParser<params extends array<GenericParamAst>, $> {\n    <const body>(body: type.validate<body, $, baseGenericConstraints<params>>): Generic<params, body, $, $>;\n    <hkt extends Hkt.constructor>(instantiateDef: LazyGenericBody<baseGenericResolutions<params, $>>, hkt: hkt): Generic<params, InstanceType<hkt>, $, $>;\n}\n\ndeclare const Module: new <$ extends {}>(exports: exportScope<$>) => Module<$>;\ninterface Module<$ extends {} = {}> extends RootModule<exportScope<$>> {\n}\ntype exportScope<$> = bindExportsToScope<$, $>;\ndeclare const BoundModule: new <exports extends {}, $ extends {}>(exports: bindExportsToScope<exports, $>, $: $) => BoundModule<exports, $>;\ninterface BoundModule<exports extends {}, $> extends RootModule<bindExportsToScope<exports, $>> {\n}\ntype bindExportsToScope<exports, $> = {\n    [k in keyof exports]: instantiateExport<exports[k], $>;\n} & unknown;\ntype Submodule<exports extends {}> = RootModule<exports & (\"root\" extends keyof exports ? {\n    [inferred]: exports[\"root\"];\n} : {})>;\ntype instantiateExport<t, $> = [\n    t\n] extends [PreparsedNodeResolution] ? [\n    t\n] extends [anyOrNever] ? Type$1<t, $> : t extends GenericAst<infer params, infer body, infer body$> ? Generic<params, body, body$, $> : t extends Submodule<infer exports> ? BoundModule<exports, $> : never : Type$1<t, $>;\n\ndeclare class liftFromHkt extends Hkt<[element: unknown]> {\n    body: liftArray<this[0]> extends infer lifted ? (In: this[0] | lifted) => To<lifted> : never;\n}\ndeclare const liftFrom: _ark_schema.GenericRoot<readonly [[\"element\", unknown]], liftFromHkt>;\ndeclare const arkArray: arkArray.module;\ndeclare namespace arkArray {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: unknown[];\n        readonly: readonly unknown[];\n        index: NonNegativeIntegerString;\n        liftFrom: typeof liftFrom.t;\n    };\n}\ntype NonNegativeIntegerString = `${Digit}` | (`${Exclude<Digit, 0>}${string}` & `${bigint}`);\n\ntype FormDataValue = string | File;\ntype ParsedFormData = Record<string, FormDataValue | FormDataValue[]>;\ndeclare const arkFormData: arkFormData.module;\ndeclare namespace arkFormData {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: FormData;\n        value: FormDataValue;\n        parse: (In: FormData) => To<ParsedFormData>;\n        parsed: ParsedFormData;\n    };\n}\n\ndeclare const TypedArray: TypedArray.module;\ndeclare namespace TypedArray {\n    type module = Module<TypedArray.$>;\n    type submodule = Submodule<$>;\n    type $ = {\n        Int8: Int8Array;\n        Uint8: Uint8Array;\n        Uint8Clamped: Uint8ClampedArray;\n        Int16: Int16Array;\n        Uint16: Uint16Array;\n        Int32: Int32Array;\n        Uint32: Uint32Array;\n        Float32: Float32Array;\n        Float64: Float64Array;\n        BigInt64: BigInt64Array;\n        BigUint64: BigUint64Array;\n    };\n}\n\ndeclare const omittedPrototypes: {\n    Boolean: 1;\n    Number: 1;\n    String: 1;\n};\ndeclare const arkPrototypes: arkPrototypes.module;\ndeclare namespace arkPrototypes {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    interface keywords extends ecmascript, platform {\n    }\n    interface $ extends Omit<keywords, keyof wrapped>, wrapped {\n    }\n    interface wrapped {\n        Array: arkArray.submodule;\n        TypedArray: TypedArray.submodule;\n        FormData: arkFormData.submodule;\n    }\n    type ecmascript = Omit<EcmascriptObjects, keyof typeof omittedPrototypes>;\n    type platform = PlatformObjects;\n    interface instances extends ecmascript, platform {\n    }\n    type instanceOf<name extends keyof instances = keyof instances> = instances[name];\n}\n\ntype DateLiteral<source extends string = string> = `d\"${source}\"` | `d'${source}'`;\ntype LimitLiteral = number | DateLiteral;\ntype distill<t, endpoint extends distill.Endpoint> = finalizeDistillation<t, _distill<t, endpoint, never>>;\ndeclare namespace distill {\n    type Endpoint = \"in\" | \"out\" | \"out.introspectable\";\n    type In<t> = distill<t, \"in\">;\n    type Out<t> = distill<t, \"out\">;\n    namespace introspectable {\n        type Out<t> = distill<t, \"out.introspectable\">;\n    }\n}\ntype finalizeDistillation<t, distilled> = equals<t, distilled> extends true ? t : distilled;\ntype _distill<t, endpoint extends distill.Endpoint, seen> = t extends undefined ? t : [t] extends [anyOrNever | seen] ? t : unknown extends t ? unknown : t extends Brand<infer base> ? endpoint extends \"in\" ? base : t : t extends TerminallyInferredObject | Primitive ? t : t extends Function ? t extends (...args: never) => anyOrNever ? t : t extends InferredMorph<infer i, infer o> ? distillIo<i, o, endpoint, seen> : t : t extends Default<infer constraint> ? _distill<constraint, endpoint, seen> : t extends array ? distillArray<t, endpoint, seen | t> : isSafelyMappable<t> extends true ? distillMappable<t, endpoint, seen | t> : t;\ntype distillMappable<o, endpoint extends distill.Endpoint, seen> = endpoint extends \"in\" ? show<{\n    [k in keyof o as k extends inferredDefaultKeyOf<o> ? never : k]: _distill<o[k], endpoint, seen>;\n} & {\n    [k in inferredDefaultKeyOf<o>]?: _distill<o[k], endpoint, seen>;\n}> : {\n    [k in keyof o]: _distill<o[k], endpoint, seen>;\n};\ntype distillIo<i, o extends Out, endpoint extends distill.Endpoint, seen> = endpoint extends \"out\" ? _distill<o[\"t\"], endpoint, seen> : endpoint extends \"in\" ? _distill<i, endpoint, seen> : o extends To<infer validatedOut> ? _distill<validatedOut, endpoint, seen> : unknown;\ntype unwrapInput<t> = t extends InferredMorph<infer i> ? t extends anyOrNever ? t : i : t;\ntype inferredDefaultKeyOf<o> = keyof o extends infer k ? k extends keyof o ? unwrapInput<o[k]> extends Default<infer t> ? [\n    t\n] extends [anyOrNever] ? never : k : never : never : never;\ntype distillArray<t extends array, endpoint extends distill.Endpoint, seen> = t[number][] extends t ? alignReadonly<_distill<t[number], endpoint, seen>[], t> : distillNonArraykeys<t, alignReadonly<distillArrayFromPrefix<[...t], endpoint, seen, []>, t>, endpoint, seen>;\ntype alignReadonly<result extends unknown[], original extends array> = original extends unknown[] ? result : Readonly<result>;\ntype distillNonArraykeys<originalArray extends array, distilledArray, endpoint extends distill.Endpoint, seen> = keyof originalArray extends keyof distilledArray ? distilledArray : distilledArray & _distill<{\n    [k in keyof originalArray as k extends keyof distilledArray ? never : k]: originalArray[k];\n}, endpoint, seen>;\ntype distillArrayFromPrefix<t extends array, endpoint extends distill.Endpoint, seen, prefix extends array> = t extends readonly [infer head, ...infer tail] ? distillArrayFromPrefix<tail, endpoint, seen, [\n    ...prefix,\n    _distill<head, endpoint, seen>\n]> : [...prefix, ...distillArrayFromPostfix<t, endpoint, seen, []>];\ntype distillArrayFromPostfix<t extends array, endpoint extends distill.Endpoint, seen, postfix extends array> = t extends readonly [...infer init, infer last] ? distillArrayFromPostfix<init, endpoint, seen, [\n    _distill<last, endpoint, seen>,\n    ...postfix\n]> : [...{\n    [i in keyof t]: _distill<t[i], endpoint, seen>;\n}, ...postfix];\ntype BuiltinTerminalObjectKind = Exclude<keyof arkPrototypes.instances, \"Array\" | \"Function\">;\n/** Objects we don't want to expand during inference like Date or Promise */\ntype TerminallyInferredObject = arkPrototypes.instanceOf<BuiltinTerminalObjectKind> | ArkEnv.prototypes;\ntype inferPredicate<t, predicate> = predicate extends (data: any, ...args: any[]) => data is infer narrowed ? narrowed : t;\ntype inferPipes<t, pipes extends Morph[]> = pipes extends [infer head extends Morph, ...infer tail extends Morph[]] ? inferPipes<head extends type.cast<infer tPipe> ? inferPipe<t, tPipe> : inferMorphOut<head> extends infer out ? (In: distill.In<t>) => Out<out> : never, tail> : t;\ntype inferMorphOut<morph extends Morph> = Exclude<ReturnType<morph>, ArkError | ArkErrors>;\ndeclare const isMorphOutKey: \" isMorphOut\";\ninterface Out<o = any> {\n    [isMorphOutKey]: true;\n    t: o;\n    introspectable: boolean;\n}\ninterface To<o = any> extends Out<o> {\n    introspectable: true;\n}\ntype InferredMorph<i = any, o extends Out = Out> = (In: i) => o;\ndeclare const defaultsToKey: \" defaultsTo\";\ntype Default<t = unknown, v = unknown> = {\n    [defaultsToKey]: [t, v];\n};\ntype withDefault<t, v, undistributed = t> = t extends InferredMorph ? addDefaultToMorph<t, v> : Default<Exclude<undistributed, InferredMorph>, v>;\ntype addDefaultToMorph<t extends InferredMorph, v> = [\n    normalizeMorphDistribution<t>\n] extends [InferredMorph<infer i, infer o>] ? (In: Default<i, v>) => o : never;\ntype normalizeMorphDistribution<t, undistributedIn = t extends InferredMorph<infer i> ? i : never, undistributedOut extends Out = t extends InferredMorph<any, infer o> ? [\n    o\n] extends [To<infer unwrappedOut>] ? To<unwrappedOut> : o : never> = (Extract<t, InferredMorph> extends anyOrNever ? never : Extract<t, InferredMorph> extends InferredMorph<infer i, infer o> ? [\n    undistributedOut\n] extends [o] ? (In: undistributedIn) => undistributedOut : [undistributedIn] extends [i] ? (In: undistributedIn) => undistributedOut : t : never) | Exclude<t, InferredMorph> extends infer _ ? _ : never;\ntype defaultFor<t = unknown> = (Primitive extends t ? Primitive : t extends Primitive ? t : never) | (() => t);\ntype inferIntersection<l, r> = normalizeMorphDistribution<_inferIntersection<l, r, false>>;\ntype inferPipe<l, r> = normalizeMorphDistribution<_inferIntersection<l, r, true>>;\ntype _inferIntersection<l, r, piped extends boolean> = [\n    l & r\n] extends [infer t extends anyOrNever] ? t : l extends InferredMorph<infer lIn, infer lOut> ? r extends InferredMorph<any, infer rOut> ? piped extends true ? (In: lIn) => rOut : never : piped extends true ? (In: lIn) => To<r> : (In: _inferIntersection<lIn, r, false>) => lOut : r extends InferredMorph<infer rIn, infer rOut> ? (In: _inferIntersection<rIn, l, false>) => rOut : [l, r] extends [object, object] ? intersectObjects<l, r, piped> extends infer result ? result : never : l & r;\ninterface MorphableIntersection<piped extends boolean> extends Hkt<[unknown, unknown]> {\n    body: _inferIntersection<this[0], this[1], piped>;\n}\ntype intersectObjects<l, r, piped extends boolean> = l extends array ? r extends array ? intersectArrays<l, r, MorphableIntersection<piped>> : // for an intersection with exactly one array operand like { name: string } & string[],\nl & r : r extends array ? l & r : show<{\n    [k in keyof l]: k extends keyof r ? _inferIntersection<l[k], r[k], piped> : l[k];\n} & {\n    [k in keyof r]: k extends keyof l ? _inferIntersection<l[k], r[k], piped> : r[k];\n}>;\n\nexport { Ark, ArkAmbient, type ArkConfig, BoundModule, Generic, type KeywordConfig, Module, Scope, type Submodule, Type$1 as Type, type TypeMeta, type TypeMetaInput, ark, configure, declare, define, distill, generic, keywords, match, scope, type };\n"
