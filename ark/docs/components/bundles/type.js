/** AUTOGENERATED - DO NOT EDIT DIRECTLY **/
// Source: arktype
// Generated at: 2025-04-01T20:08:21.009Z

// index.ts
import {
  ArkError,
  ArkErrors as ArkErrors3
} from "@ark/schema";
import { Hkt as Hkt5, inferred } from "@ark/util";

// config.ts
import { configureSchema } from "@ark/schema/config";
var configure = configureSchema;

// generic.ts
import {
  GenericRoot
} from "@ark/schema";
import {
  throwParseError as throwParseError7
} from "@ark/util";

// parser/reduce/dynamic.ts
import {
  isKeyOf as isKeyOf5,
  throwInternalError as throwInternalError2,
  throwParseError as throwParseError6
} from "@ark/util";

// parser/shift/operand/operand.ts
import { whitespaceChars } from "@ark/util";

// parser/shift/operand/enclosed.ts
import { isKeyOf, throwParseError as throwParseError2 } from "@ark/util";

// parser/shift/operand/date.ts
import { throwParseError, tryParseNumber } from "@ark/util";
var isDateLiteral = (value2) => typeof value2 === "string" && value2[0] === "d" && (value2[1] === "'" || value2[1] === '"') && value2.at(-1) === value2[1];
var isValidDate = (d) => d.toString() !== "Invalid Date";
var extractDateLiteralSource = (literal) => literal.slice(2, -1);
var writeInvalidDateMessage = (source) => `'${source}' could not be parsed by the Date constructor`;
var tryParseDate = (source, errorOnFail) => maybeParseDate(source, errorOnFail);
var maybeParseDate = (source, errorOnFail) => {
  const stringParsedDate = new Date(source);
  if (isValidDate(stringParsedDate)) return stringParsedDate;
  const epochMillis = tryParseNumber(source);
  if (epochMillis !== void 0) {
    const numberParsedDate = new Date(epochMillis);
    if (isValidDate(numberParsedDate)) return numberParsedDate;
  }
  return errorOnFail ? throwParseError(
    errorOnFail === true ? writeInvalidDateMessage(source) : errorOnFail
  ) : void 0;
};

// parser/shift/operand/enclosed.ts
var parseEnclosed = (s, enclosing) => {
  const enclosed = s.scanner.shiftUntil(
    untilLookaheadIsClosing[enclosingTokens[enclosing]]
  );
  if (s.scanner.lookahead === "")
    return s.error(writeUnterminatedEnclosedMessage(enclosed, enclosing));
  s.scanner.shift();
  if (enclosing === "/") {
    try {
      new RegExp(enclosed);
    } catch (e) {
      throwParseError2(String(e));
    }
    s.root = s.ctx.$.node(
      "intersection",
      {
        domain: "string",
        pattern: enclosed
      },
      { prereduced: true }
    );
  } else if (isKeyOf(enclosing, enclosingQuote))
    s.root = s.ctx.$.node("unit", { unit: enclosed });
  else {
    const date = tryParseDate(enclosed, writeInvalidDateMessage(enclosed));
    s.root = s.ctx.$.node("unit", { meta: enclosed, unit: date });
  }
};
var enclosingQuote = {
  "'": 1,
  '"': 1
};
var enclosingChar = {
  "/": 1,
  "'": 1,
  '"': 1
};
var enclosingTokens = {
  "d'": "'",
  'd"': '"',
  "'": "'",
  '"': '"',
  "/": "/"
};
var untilLookaheadIsClosing = {
  "'": (scanner) => scanner.lookahead === `'`,
  '"': (scanner) => scanner.lookahead === `"`,
  "/": (scanner) => scanner.lookahead === `/`
};
var enclosingCharDescriptions = {
  '"': "double-quote",
  "'": "single-quote",
  "/": "forward slash"
};
var writeUnterminatedEnclosedMessage = (fragment, enclosingStart) => `${enclosingStart}${fragment} requires a closing ${enclosingCharDescriptions[enclosingTokens[enclosingStart]]}`;

// parser/shift/operand/unenclosed.ts
import {
  hasArkKind,
  writeUnresolvableMessage
} from "@ark/schema";
import {
  printable,
  throwParseError as throwParseError3,
  tryParseWellFormedBigint,
  tryParseWellFormedNumber
} from "@ark/util";

// parser/ast/validate.ts
var writePrefixedPrivateReferenceMessage = (name) => `Private type references should not include '#'. Use '${name}' instead.`;
var shallowOptionalMessage = "Optional definitions like 'string?' are only valid as properties in an object or tuple";
var shallowDefaultableMessage = "Defaultable definitions like 'number = 0' are only valid as properties in an object or tuple";

// parser/reduce/shared.ts
var minComparators = {
  ">": true,
  ">=": true
};
var maxComparators = {
  "<": true,
  "<=": true
};
var invertedComparators = {
  "<": ">",
  ">": "<",
  "<=": ">=",
  ">=": "<=",
  "==": "=="
};
var writeUnmatchedGroupCloseMessage = (unscanned) => `Unmatched )${unscanned === "" ? "" : ` before ${unscanned}`}`;
var writeUnclosedGroupMessage = (missingChar) => `Missing ${missingChar}`;
var writeOpenRangeMessage = (min, comparator) => `Left bounds are only valid when paired with right bounds (try ...${comparator}${min})`;
var writeUnpairableComparatorMessage = (comparator) => `Left-bounded expressions must specify their limits using < or <= (was ${comparator})`;
var writeMultipleLeftBoundsMessage = (openLimit, openComparator, limit, comparator) => `An expression may have at most one left bound (parsed ${openLimit}${invertedComparators[openComparator]}, ${limit}${invertedComparators[comparator]})`;

// parser/shift/operand/genericArgs.ts
var parseGenericArgs = (name, g, s) => _parseGenericArgs(name, g, s, []);
var _parseGenericArgs = (name, g, s, argNodes) => {
  const argState = s.parseUntilFinalizer();
  argNodes.push(argState.root);
  if (argState.finalizer === ">") {
    if (argNodes.length !== g.params.length) {
      return s.error(
        writeInvalidGenericArgCountMessage(
          name,
          g.names,
          argNodes.map((arg) => arg.expression)
        )
      );
    }
    return argNodes;
  }
  if (argState.finalizer === ",") return _parseGenericArgs(name, g, s, argNodes);
  return argState.error(writeUnclosedGroupMessage(">"));
};
var writeInvalidGenericArgCountMessage = (name, params, argDefs) => `${name}<${params.join(", ")}> requires exactly ${params.length} args (got ${argDefs.length}${argDefs.length === 0 ? "" : `: ${argDefs.join(", ")}`})`;

// parser/shift/operand/unenclosed.ts
var parseUnenclosed = (s) => {
  const token = s.scanner.shiftUntilNextTerminator();
  if (token === "keyof") s.addPrefix("keyof");
  else s.root = unenclosedToNode(s, token);
};
var parseGenericInstantiation = (name, g, s) => {
  s.scanner.shiftUntilNonWhitespace();
  const lookahead = s.scanner.shift();
  if (lookahead !== "<")
    return s.error(writeInvalidGenericArgCountMessage(name, g.names, []));
  const parsedArgs = parseGenericArgs(name, g, s);
  return g(...parsedArgs);
};
var unenclosedToNode = (s, token) => maybeParseReference(s, token) ?? maybeParseUnenclosedLiteral(s, token) ?? s.error(
  token === "" ? s.scanner.lookahead === "#" ? writePrefixedPrivateReferenceMessage(
    s.shiftedByOne().scanner.shiftUntilNextTerminator()
  ) : writeMissingOperandMessage(s) : writeUnresolvableMessage(token)
);
var maybeParseReference = (s, token) => {
  if (s.ctx.args?.[token]) {
    const arg = s.ctx.args[token];
    if (typeof arg !== "string") return arg;
    return s.ctx.$.node("alias", { reference: arg }, { prereduced: true });
  }
  const resolution = s.ctx.$.maybeResolve(token);
  if (hasArkKind(resolution, "root")) return resolution;
  if (resolution === void 0) return;
  if (hasArkKind(resolution, "generic"))
    return parseGenericInstantiation(token, resolution, s);
  return throwParseError3(`Unexpected resolution ${printable(resolution)}`);
};
var maybeParseUnenclosedLiteral = (s, token) => {
  const maybeNumber = tryParseWellFormedNumber(token);
  if (maybeNumber !== void 0)
    return s.ctx.$.node("unit", { unit: maybeNumber });
  const maybeBigint = tryParseWellFormedBigint(token);
  if (maybeBigint !== void 0)
    return s.ctx.$.node("unit", { unit: maybeBigint });
};
var writeMissingOperandMessage = (s) => {
  const operator = s.previousOperator();
  return operator ? writeMissingRightOperandMessage(operator, s.scanner.unscanned) : writeExpressionExpectedMessage(s.scanner.unscanned);
};
var writeMissingRightOperandMessage = (token, unscanned = "") => `Token '${token}' requires a right operand${unscanned ? ` before '${unscanned}'` : ""}`;
var writeExpressionExpectedMessage = (unscanned) => `Expected an expression${unscanned ? ` before '${unscanned}'` : ""}`;

// parser/shift/operand/operand.ts
var parseOperand = (s) => s.scanner.lookahead === "" ? s.error(writeMissingOperandMessage(s)) : s.scanner.lookahead === "(" ? s.shiftedByOne().reduceGroupOpen() : s.scanner.lookaheadIsIn(enclosingChar) ? parseEnclosed(s, s.scanner.shift()) : s.scanner.lookaheadIsIn(whitespaceChars) ? parseOperand(s.shiftedByOne()) : s.scanner.lookahead === "d" ? s.scanner.nextLookahead in enclosingQuote ? parseEnclosed(
  s,
  `${s.scanner.shift()}${s.scanner.shift()}`
) : parseUnenclosed(s) : parseUnenclosed(s);

// parser/shift/operator/operator.ts
import { isKeyOf as isKeyOf4, whitespaceChars as whitespaceChars3 } from "@ark/util";

// parser/shift/scanner.ts
import {
  isKeyOf as isKeyOf2,
  Scanner,
  whitespaceChars as whitespaceChars2
} from "@ark/util";
var ArkTypeScanner = class _ArkTypeScanner extends Scanner {
  shiftUntilNextTerminator() {
    this.shiftUntilNonWhitespace();
    return this.shiftUntil(
      () => this.lookahead in _ArkTypeScanner.terminatingChars
    );
  }
  static terminatingChars = {
    "<": 1,
    ">": 1,
    "=": 1,
    "|": 1,
    "&": 1,
    ")": 1,
    "[": 1,
    "%": 1,
    ",": 1,
    ":": 1,
    "?": 1,
    "#": 1,
    ...whitespaceChars2
  };
  static finalizingLookaheads = {
    ">": 1,
    ",": 1,
    "": 1,
    "=": 1,
    "?": 1
  };
  static lookaheadIsFinalizing = (lookahead, unscanned) => lookahead === ">" ? unscanned[0] === "=" ? (
    // >== would only occur in an expression like Array<number>==5
    // otherwise, >= would only occur as part of a bound like number>=5
    unscanned[1] === "="
  ) : unscanned.trimStart() === "" || isKeyOf2(unscanned.trimStart()[0], _ArkTypeScanner.terminatingChars) : lookahead === "=" ? unscanned[0] !== "=" : lookahead === "," || lookahead === "?";
};

// parser/shift/operator/bounds.ts
import {
  $ark,
  writeUnboundableMessage
} from "@ark/schema";
import { isKeyOf as isKeyOf3, throwParseError as throwParseError4 } from "@ark/util";
var parseBound = (s, start) => {
  const comparator = shiftComparator(s, start);
  if (s.root.hasKind("unit")) {
    if (typeof s.root.unit === "number") {
      s.reduceLeftBound(s.root.unit, comparator);
      s.unsetRoot();
      return;
    }
    if (s.root.unit instanceof Date) {
      const literal = `d'${s.root.description ?? s.root.unit.toISOString()}'`;
      s.unsetRoot();
      s.reduceLeftBound(literal, comparator);
      return;
    }
  }
  return parseRightBound(s, comparator);
};
var comparatorStartChars = {
  "<": 1,
  ">": 1,
  "=": 1
};
var shiftComparator = (s, start) => s.scanner.lookaheadIs("=") ? `${start}${s.scanner.shift()}` : start;
var getBoundKinds = (comparator, limit, root, boundKind) => {
  if (root.extends($ark.intrinsic.number)) {
    if (typeof limit !== "number") {
      return throwParseError4(
        writeInvalidLimitMessage(comparator, limit, boundKind)
      );
    }
    return comparator === "==" ? ["min", "max"] : comparator[0] === ">" ? ["min"] : ["max"];
  }
  if (root.extends($ark.intrinsic.lengthBoundable)) {
    if (typeof limit !== "number") {
      return throwParseError4(
        writeInvalidLimitMessage(comparator, limit, boundKind)
      );
    }
    return comparator === "==" ? ["exactLength"] : comparator[0] === ">" ? ["minLength"] : ["maxLength"];
  }
  if (root.extends($ark.intrinsic.Date)) {
    return comparator === "==" ? ["after", "before"] : comparator[0] === ">" ? ["after"] : ["before"];
  }
  return throwParseError4(writeUnboundableMessage(root.expression));
};
var openLeftBoundToRoot = (leftBound) => ({
  rule: isDateLiteral(leftBound.limit) ? extractDateLiteralSource(leftBound.limit) : leftBound.limit,
  exclusive: leftBound.comparator.length === 1
});
var parseRightBound = (s, comparator) => {
  const previousRoot = s.unsetRoot();
  const previousScannerIndex = s.scanner.location;
  s.parseOperand();
  const limitNode = s.unsetRoot();
  const limitToken = s.scanner.sliceChars(
    previousScannerIndex,
    s.scanner.location
  );
  s.root = previousRoot;
  if (!limitNode.hasKind("unit") || typeof limitNode.unit !== "number" && !(limitNode.unit instanceof Date))
    return s.error(writeInvalidLimitMessage(comparator, limitToken, "right"));
  const limit = limitNode.unit;
  const exclusive = comparator.length === 1;
  const boundKinds = getBoundKinds(
    comparator,
    typeof limit === "number" ? limit : limitToken,
    previousRoot,
    "right"
  );
  for (const kind of boundKinds) {
    s.constrainRoot(
      kind,
      comparator === "==" ? { rule: limit } : { rule: limit, exclusive }
    );
  }
  if (!s.branches.leftBound) return;
  if (!isKeyOf3(comparator, maxComparators))
    return s.error(writeUnpairableComparatorMessage(comparator));
  const lowerBoundKind = getBoundKinds(
    s.branches.leftBound.comparator,
    s.branches.leftBound.limit,
    previousRoot,
    "left"
  );
  s.constrainRoot(lowerBoundKind[0], openLeftBoundToRoot(s.branches.leftBound));
  s.branches.leftBound = null;
};
var writeInvalidLimitMessage = (comparator, limit, boundKind) => `Comparator ${boundKind === "left" ? invertedComparators[comparator] : comparator} must be ${boundKind === "left" ? "preceded" : "followed"} by a corresponding literal (was ${limit})`;

// parser/shift/operator/brand.ts
var parseBrand = (s) => {
  s.scanner.shiftUntilNonWhitespace();
  const brandName = s.scanner.shiftUntilNextTerminator();
  s.root = s.root.brand(brandName);
};

// parser/shift/operator/divisor.ts
import { tryParseInteger } from "@ark/util";
var parseDivisor = (s) => {
  const divisorToken = s.scanner.shiftUntilNextTerminator();
  const divisor = tryParseInteger(divisorToken, {
    errorOnFail: writeInvalidDivisorMessage(divisorToken)
  });
  if (divisor === 0) s.error(writeInvalidDivisorMessage(0));
  s.root = s.root.constrain("divisor", divisor);
};
var writeInvalidDivisorMessage = (divisor) => `% operator must be followed by a non-zero integer literal (was ${divisor})`;

// parser/shift/operator/operator.ts
var parseOperator = (s) => {
  const lookahead = s.scanner.shift();
  return lookahead === "" ? s.finalize("") : lookahead === "[" ? s.scanner.shift() === "]" ? s.setRoot(s.root.array()) : s.error(incompleteArrayTokenMessage) : lookahead === "|" ? s.scanner.lookahead === ">" ? s.shiftedByOne().pushRootToBranch("|>") : s.pushRootToBranch(lookahead) : lookahead === "&" ? s.pushRootToBranch(lookahead) : lookahead === ")" ? s.finalizeGroup() : ArkTypeScanner.lookaheadIsFinalizing(lookahead, s.scanner.unscanned) ? s.finalize(lookahead) : isKeyOf4(lookahead, comparatorStartChars) ? parseBound(s, lookahead) : lookahead === "%" ? parseDivisor(s) : lookahead === "#" ? parseBrand(s) : lookahead in whitespaceChars3 ? parseOperator(s) : s.error(writeUnexpectedCharacterMessage(lookahead));
};
var writeUnexpectedCharacterMessage = (char, shouldBe = "") => `'${char}' is not allowed here${shouldBe && ` (should be ${shouldBe})`}`;
var incompleteArrayTokenMessage = `Missing expected ']'`;

// parser/string.ts
import {
  throwInternalError,
  throwParseError as throwParseError5
} from "@ark/util";

// parser/shift/operator/default.ts
var parseDefault = (s) => {
  const baseNode = s.unsetRoot();
  s.parseOperand();
  const defaultNode = s.unsetRoot();
  if (!defaultNode.hasKind("unit"))
    return s.error(writeNonLiteralDefaultMessage(defaultNode.expression));
  const defaultValue = defaultNode.unit instanceof Date ? () => new Date(defaultNode.unit) : defaultNode.unit;
  return [baseNode, "=", defaultValue];
};
var writeNonLiteralDefaultMessage = (defaultDef) => `Default value '${defaultDef}' must a literal value`;

// parser/string.ts
var parseString = (def, ctx) => {
  const aliasResolution = ctx.$.maybeResolveRoot(def);
  if (aliasResolution) return aliasResolution;
  if (def.endsWith("[]")) {
    const possibleElementResolution = ctx.$.maybeResolveRoot(def.slice(0, -2));
    if (possibleElementResolution) return possibleElementResolution.array();
  }
  const s = new DynamicState(new ArkTypeScanner(def), ctx);
  const node3 = fullStringParse(s);
  if (s.finalizer === ">") throwParseError5(writeUnexpectedCharacterMessage(">"));
  return node3;
};
var fullStringParse = (s) => {
  s.parseOperand();
  let result = parseUntilFinalizer(s).root;
  if (!result) {
    return throwInternalError(
      `Root was unexpectedly unset after parsing string '${s.scanner.scanned}'`
    );
  }
  if (s.finalizer === "=") result = parseDefault(s);
  else if (s.finalizer === "?") result = [result, "?"];
  s.scanner.shiftUntilNonWhitespace();
  if (s.scanner.lookahead) {
    throwParseError5(writeUnexpectedCharacterMessage(s.scanner.lookahead));
  }
  return result;
};
var parseUntilFinalizer = (s) => {
  while (s.finalizer === void 0) next(s);
  return s;
};
var next = (s) => s.hasRoot() ? s.parseOperator() : s.parseOperand();

// parser/reduce/dynamic.ts
var DynamicState = class _DynamicState {
  // set root type to `any` so that all constraints can be applied
  root;
  branches = {
    prefixes: [],
    leftBound: null,
    intersection: null,
    union: null,
    pipe: null
  };
  finalizer;
  groups = [];
  scanner;
  ctx;
  constructor(scanner, ctx) {
    this.scanner = scanner;
    this.ctx = ctx;
  }
  error(message) {
    return throwParseError6(message);
  }
  hasRoot() {
    return this.root !== void 0;
  }
  setRoot(root) {
    this.root = root;
  }
  unsetRoot() {
    const value2 = this.root;
    this.root = void 0;
    return value2;
  }
  constrainRoot(...args) {
    this.root = this.root.constrain(args[0], args[1]);
  }
  finalize(finalizer) {
    if (this.groups.length) return this.error(writeUnclosedGroupMessage(")"));
    this.finalizeBranches();
    this.finalizer = finalizer;
  }
  reduceLeftBound(limit, comparator) {
    const invertedComparator = invertedComparators[comparator];
    if (!isKeyOf5(invertedComparator, minComparators))
      return this.error(writeUnpairableComparatorMessage(comparator));
    if (this.branches.leftBound) {
      return this.error(
        writeMultipleLeftBoundsMessage(
          this.branches.leftBound.limit,
          this.branches.leftBound.comparator,
          limit,
          invertedComparator
        )
      );
    }
    this.branches.leftBound = {
      comparator: invertedComparator,
      limit
    };
  }
  finalizeBranches() {
    this.assertRangeUnset();
    if (this.branches.pipe) {
      this.pushRootToBranch("|>");
      this.root = this.branches.pipe;
      return;
    }
    if (this.branches.union) {
      this.pushRootToBranch("|");
      this.root = this.branches.union;
      return;
    }
    if (this.branches.intersection) {
      this.pushRootToBranch("&");
      this.root = this.branches.intersection;
      return;
    }
    this.applyPrefixes();
  }
  finalizeGroup() {
    this.finalizeBranches();
    const topBranchState = this.groups.pop();
    if (!topBranchState)
      return this.error(writeUnmatchedGroupCloseMessage(this.scanner.unscanned));
    this.branches = topBranchState;
  }
  addPrefix(prefix) {
    this.branches.prefixes.push(prefix);
  }
  applyPrefixes() {
    while (this.branches.prefixes.length) {
      const lastPrefix = this.branches.prefixes.pop();
      this.root = lastPrefix === "keyof" ? this.root.keyof() : throwInternalError2(`Unexpected prefix '${lastPrefix}'`);
    }
  }
  pushRootToBranch(token) {
    this.assertRangeUnset();
    this.applyPrefixes();
    const root = this.root;
    this.root = void 0;
    this.branches.intersection = this.branches.intersection?.rawAnd(root) ?? root;
    if (token === "&") return;
    this.branches.union = this.branches.union?.rawOr(this.branches.intersection) ?? this.branches.intersection;
    this.branches.intersection = null;
    if (token === "|") return;
    this.branches.pipe = this.branches.pipe?.rawPipeOnce(this.branches.union) ?? this.branches.union;
    this.branches.union = null;
  }
  parseUntilFinalizer() {
    return parseUntilFinalizer(new _DynamicState(this.scanner, this.ctx));
  }
  parseOperator() {
    return parseOperator(this);
  }
  parseOperand() {
    return parseOperand(this);
  }
  assertRangeUnset() {
    if (this.branches.leftBound) {
      return this.error(
        writeOpenRangeMessage(
          this.branches.leftBound.limit,
          this.branches.leftBound.comparator
        )
      );
    }
  }
  reduceGroupOpen() {
    this.groups.push(this.branches);
    this.branches = {
      prefixes: [],
      leftBound: null,
      union: null,
      intersection: null,
      pipe: null
    };
  }
  previousOperator() {
    return this.branches.leftBound?.comparator ?? this.branches.prefixes.at(-1) ?? (this.branches.intersection ? "&" : this.branches.union ? "|" : this.branches.pipe ? "|>" : void 0);
  }
  shiftedByOne() {
    this.scanner.shift();
    return this;
  }
};

// generic.ts
var Generic = GenericRoot;
var emptyGenericParameterMessage = "An empty string is not a valid generic parameter name";
var parseGenericParamName = (scanner, result, ctx) => {
  scanner.shiftUntilNonWhitespace();
  const name = scanner.shiftUntilNextTerminator();
  if (name === "") {
    if (scanner.lookahead === "" && result.length) return result;
    return throwParseError7(emptyGenericParameterMessage);
  }
  scanner.shiftUntilNonWhitespace();
  return _parseOptionalConstraint(scanner, name, result, ctx);
};
var extendsToken = "extends ";
var _parseOptionalConstraint = (scanner, name, result, ctx) => {
  scanner.shiftUntilNonWhitespace();
  if (scanner.unscanned.startsWith(extendsToken))
    scanner.jumpForward(extendsToken.length);
  else {
    if (scanner.lookahead === ",") scanner.shift();
    result.push(name);
    return parseGenericParamName(scanner, result, ctx);
  }
  const s = parseUntilFinalizer(new DynamicState(scanner, ctx));
  result.push([name, s.root]);
  return parseGenericParamName(scanner, result, ctx);
};

// scope.ts
import {
  $ark as $ark3,
  BaseScope,
  hasArkKind as hasArkKind3,
  parseGeneric
} from "@ark/schema";
import {
  enumValues,
  flatMorph,
  isArray as isArray4,
  isThunk as isThunk2,
  throwParseError as throwParseError13
} from "@ark/util";

// match.ts
import {
  intrinsic
} from "@ark/schema";
import {
  Callable,
  domainOf,
  throwParseError as throwParseError8
} from "@ark/util";
var InternalMatchParser = class extends Callable {
  $;
  constructor($) {
    super((...args) => new InternalChainedMatchParser($)(...args), {
      bind: $
    });
    this.$ = $;
  }
  in(def) {
    return new InternalChainedMatchParser(
      this.$,
      def === void 0 ? void 0 : this.$.parse(def)
    );
  }
  at(key, cases) {
    return new InternalChainedMatchParser(this.$).at(key, cases);
  }
  case(when, then) {
    return new InternalChainedMatchParser(this.$).case(when, then);
  }
};
var InternalChainedMatchParser = class extends Callable {
  $;
  in;
  key;
  branches = [];
  constructor($, In) {
    super(
      (cases) => this.caseEntries(
        Object.entries(cases).map(
          ([k, v]) => k === "default" ? [k, v] : [this.$.parse(k), v]
        )
      )
    );
    this.$ = $;
    this.in = In;
  }
  at(key, cases) {
    if (this.key) throwParseError8(doubleAtMessage);
    if (this.branches.length) throwParseError8(chainedAtMessage);
    this.key = key;
    return cases ? this.match(cases) : this;
  }
  case(def, resolver) {
    return this.caseEntry(this.$.parse(def), resolver);
  }
  caseEntry(node3, resolver) {
    const wrappableNode = this.key ? this.$.parse({ [this.key]: node3 }) : node3;
    const branch = wrappableNode.pipe(resolver);
    this.branches.push(branch);
    return this;
  }
  match(cases) {
    return this(cases);
  }
  strings(cases) {
    return this.caseEntries(
      Object.entries(cases).map(
        ([k, v]) => k === "default" ? [k, v] : [this.$.node("unit", { unit: k }), v]
      )
    );
  }
  caseEntries(entries) {
    for (let i = 0; i < entries.length; i++) {
      const [k, v] = entries[i];
      if (k === "default") {
        if (i !== entries.length - 1) {
          throwParseError8(
            `default may only be specified as the last key of a switch definition`
          );
        }
        return this.default(v);
      }
      if (typeof v !== "function") {
        return throwParseError8(
          `Value for case "${k}" must be a function (was ${domainOf(v)})`
        );
      }
      this.caseEntry(k, v);
    }
    return this;
  }
  default(defaultCase) {
    if (typeof defaultCase === "function")
      this.case(intrinsic.unknown, defaultCase);
    const schema2 = {
      branches: this.branches,
      ordered: true
    };
    if (defaultCase === "never" || defaultCase === "assert")
      schema2.meta = { onFail: throwOnDefault };
    const cases = this.$.node("union", schema2);
    if (!this.in) return this.$.finalize(cases);
    let inputValidatedCases = this.in.pipe(cases);
    if (defaultCase === "never" || defaultCase === "assert") {
      inputValidatedCases = inputValidatedCases.configureReferences(
        {
          onFail: throwOnDefault
        },
        "self"
      );
    }
    return this.$.finalize(inputValidatedCases);
  }
};
var throwOnDefault = (errors) => errors.throw();
var chainedAtMessage = `A key matcher must be specified before the first case i.e. match.at('foo') or match.in<object>().at('bar')`;
var doubleAtMessage = `At most one key matcher may be specified per expression`;

// parser/definition.ts
import { hasArkKind as hasArkKind2 } from "@ark/schema";
import {
  domainOf as domainOf2,
  hasDomain,
  isThunk,
  objectKindOf,
  printable as printable3,
  throwParseError as throwParseError12
} from "@ark/util";

// parser/objectLiteral.ts
import {
  intrinsic as intrinsic2,
  normalizeIndex
} from "@ark/schema";
import {
  append,
  escapeChar,
  isArray as isArray2,
  isEmptyObject,
  printable as printable2,
  stringAndSymbolicEntriesOf,
  throwParseError as throwParseError9
} from "@ark/util";

// parser/property.ts
import {
  isArray
} from "@ark/util";
var parseProperty = (def, ctx) => {
  if (isArray(def)) {
    if (def[1] === "=")
      return [ctx.$.parseOwnDefinitionFormat(def[0], ctx), "=", def[2]];
    if (def[1] === "?")
      return [ctx.$.parseOwnDefinitionFormat(def[0], ctx), "?"];
  }
  return parseInnerDefinition(def, ctx);
};
var invalidOptionalKeyKindMessage = `Only required keys may make their values optional, e.g. { [mySymbol]: ['number', '?'] }`;
var invalidDefaultableKeyKindMessage = `Only required keys may specify default values, e.g. { value: 'number = 0' }`;

// parser/objectLiteral.ts
var parseObjectLiteral = (def, ctx) => {
  let spread;
  const structure = {};
  const defEntries = stringAndSymbolicEntriesOf(def);
  for (const [k, v] of defEntries) {
    const parsedKey = preparseKey(k);
    if (parsedKey.kind === "spread") {
      if (!isEmptyObject(structure))
        return throwParseError9(nonLeadingSpreadError);
      const operand = ctx.$.parseOwnDefinitionFormat(v, ctx);
      if (operand.equals(intrinsic2.object)) continue;
      if (!operand.hasKind("intersection") || // still error on attempts to spread proto nodes like ...Date
      !operand.basis?.equals(intrinsic2.object)) {
        return throwParseError9(
          writeInvalidSpreadTypeMessage(operand.expression)
        );
      }
      spread = operand.structure;
      continue;
    }
    if (parsedKey.kind === "undeclared") {
      if (v !== "reject" && v !== "delete" && v !== "ignore")
        throwParseError9(writeInvalidUndeclaredBehaviorMessage(v));
      structure.undeclared = v;
      continue;
    }
    const parsedValue = parseProperty(v, ctx);
    const parsedEntryKey = parsedKey;
    if (parsedKey.kind === "required") {
      if (!isArray2(parsedValue)) {
        appendNamedProp(
          structure,
          "required",
          {
            key: parsedKey.normalized,
            value: parsedValue
          },
          ctx
        );
      } else {
        appendNamedProp(
          structure,
          "optional",
          parsedValue[1] === "=" ? {
            key: parsedKey.normalized,
            value: parsedValue[0],
            default: parsedValue[2]
          } : {
            key: parsedKey.normalized,
            value: parsedValue[0]
          },
          ctx
        );
      }
      continue;
    }
    if (isArray2(parsedValue)) {
      if (parsedValue[1] === "?") throwParseError9(invalidOptionalKeyKindMessage);
      if (parsedValue[1] === "=")
        throwParseError9(invalidDefaultableKeyKindMessage);
    }
    if (parsedKey.kind === "optional") {
      appendNamedProp(
        structure,
        "optional",
        {
          key: parsedKey.normalized,
          value: parsedValue
        },
        ctx
      );
      continue;
    }
    const signature = ctx.$.parseOwnDefinitionFormat(
      parsedEntryKey.normalized,
      ctx
    );
    const normalized = normalizeIndex(signature, parsedValue, ctx.$);
    if (normalized.index)
      structure.index = append(structure.index, normalized.index);
    if (normalized.required)
      structure.required = append(structure.required, normalized.required);
  }
  const structureNode = ctx.$.node("structure", structure);
  return ctx.$.parseSchema({
    domain: "object",
    structure: spread?.merge(structureNode) ?? structureNode
  });
};
var appendNamedProp = (structure, kind, inner, ctx) => {
  structure[kind] = append(
    // doesn't seem like this cast should be necessary
    structure[kind],
    ctx.$.node(kind, inner)
  );
};
var writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${printable2(actual)})`;
var nonLeadingSpreadError = "Spread operator may only be used as the first key in an object";
var preparseKey = (key) => typeof key === "symbol" ? { kind: "required", normalized: key } : key.at(-1) === "?" ? key.at(-2) === escapeChar ? { kind: "required", normalized: `${key.slice(0, -2)}?` } : {
  kind: "optional",
  normalized: key.slice(0, -1)
} : key[0] === "[" && key.at(-1) === "]" ? { kind: "index", normalized: key.slice(1, -1) } : key[0] === escapeChar && key[1] === "[" && key.at(-1) === "]" ? { kind: "required", normalized: key.slice(1) } : key === "..." ? { kind: "spread" } : key === "+" ? { kind: "undeclared" } : {
  kind: "required",
  normalized: key === "\\..." ? "..." : key === "\\+" ? "+" : key
};
var writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;

// parser/tupleExpressions.ts
import {
  Disjoint,
  intersectNodesRoot,
  pipeNodesRoot
} from "@ark/schema";
import {
  objectKindOrDomainOf,
  throwParseError as throwParseError10
} from "@ark/util";
var maybeParseTupleExpression = (def, ctx) => isIndexZeroExpression(def) ? indexZeroParsers[def[0]](def, ctx) : isIndexOneExpression(def) ? indexOneParsers[def[1]](def, ctx) : null;
var parseKeyOfTuple = (def, ctx) => ctx.$.parseOwnDefinitionFormat(def[1], ctx).keyof();
var parseBranchTuple = (def, ctx) => {
  if (def[2] === void 0)
    return throwParseError10(writeMissingRightOperandMessage(def[1], ""));
  const l = ctx.$.parseOwnDefinitionFormat(def[0], ctx);
  const r = ctx.$.parseOwnDefinitionFormat(def[2], ctx);
  if (def[1] === "|") return ctx.$.node("union", { branches: [l, r] });
  const result = def[1] === "&" ? intersectNodesRoot(l, r, ctx.$) : pipeNodesRoot(l, r, ctx.$);
  if (result instanceof Disjoint) return result.throw();
  return result;
};
var parseArrayTuple = (def, ctx) => ctx.$.parseOwnDefinitionFormat(def[0], ctx).array();
var parseMorphTuple = (def, ctx) => {
  if (typeof def[2] !== "function") {
    return throwParseError10(
      writeMalformedFunctionalExpressionMessage("=>", def[2])
    );
  }
  return ctx.$.parseOwnDefinitionFormat(def[0], ctx).pipe(def[2]);
};
var writeMalformedFunctionalExpressionMessage = (operator, value2) => `${operator === ":" ? "Narrow" : "Morph"} expression requires a function following '${operator}' (was ${typeof value2})`;
var parseNarrowTuple = (def, ctx) => {
  if (typeof def[2] !== "function") {
    return throwParseError10(
      writeMalformedFunctionalExpressionMessage(":", def[2])
    );
  }
  return ctx.$.parseOwnDefinitionFormat(def[0], ctx).constrain(
    "predicate",
    def[2]
  );
};
var parseAttributeTuple = (def, ctx) => ctx.$.parseOwnDefinitionFormat(def[0], ctx).configureReferences(
  def[2],
  "shallow"
);
var defineIndexOneParsers = (parsers) => parsers;
var postfixParsers = defineIndexOneParsers({
  "[]": parseArrayTuple,
  "?": () => throwParseError10(shallowOptionalMessage)
});
var infixParsers = defineIndexOneParsers({
  "|": parseBranchTuple,
  "&": parseBranchTuple,
  ":": parseNarrowTuple,
  "=>": parseMorphTuple,
  "|>": parseBranchTuple,
  "@": parseAttributeTuple,
  // since object and tuple literals parse there via `parseProperty`,
  // they must be shallow if parsed directly as a tuple expression
  "=": () => throwParseError10(shallowDefaultableMessage)
});
var indexOneParsers = { ...postfixParsers, ...infixParsers };
var isIndexOneExpression = (def) => indexOneParsers[def[1]] !== void 0;
var defineIndexZeroParsers = (parsers) => parsers;
var indexZeroParsers = defineIndexZeroParsers({
  keyof: parseKeyOfTuple,
  instanceof: (def, ctx) => {
    if (typeof def[1] !== "function") {
      return throwParseError10(
        writeInvalidConstructorMessage(objectKindOrDomainOf(def[1]))
      );
    }
    const branches = def.slice(1).map(
      (ctor) => typeof ctor === "function" ? ctx.$.node("proto", { proto: ctor }) : throwParseError10(
        writeInvalidConstructorMessage(objectKindOrDomainOf(ctor))
      )
    );
    return branches.length === 1 ? branches[0] : ctx.$.node("union", { branches });
  },
  "===": (def, ctx) => ctx.$.units(def.slice(1))
});
var isIndexZeroExpression = (def) => indexZeroParsers[def[0]] !== void 0;
var writeInvalidConstructorMessage = (actual) => `Expected a constructor following 'instanceof' operator (was ${actual})`;

// parser/tupleLiteral.ts
import {
  $ark as $ark2,
  makeRootAndArrayPropertiesMutable,
  postfixAfterOptionalOrDefaultableMessage
} from "@ark/schema";
import {
  append as append2,
  isArray as isArray3,
  isEmptyObject as isEmptyObject2,
  throwParseError as throwParseError11
} from "@ark/util";
var parseTupleLiteral = (def, ctx) => {
  let sequences = [{}];
  let i = 0;
  while (i < def.length) {
    let spread = false;
    if (def[i] === "..." && i < def.length - 1) {
      spread = true;
      i++;
    }
    const parsedProperty = parseProperty(def[i], ctx);
    const [valueNode, operator, possibleDefaultValue] = !isArray3(parsedProperty) ? [parsedProperty] : parsedProperty;
    i++;
    if (spread) {
      if (!valueNode.extends($ark2.intrinsic.Array))
        return throwParseError11(writeNonArraySpreadMessage(valueNode.expression));
      sequences = sequences.flatMap(
        (base) => (
          // since appendElement mutates base, we have to shallow-ish clone it for each branch
          valueNode.distribute(
            (branch) => appendSpreadBranch(makeRootAndArrayPropertiesMutable(base), branch)
          )
        )
      );
    } else {
      sequences = sequences.map((base) => {
        if (operator === "?") return appendOptionalElement(base, valueNode);
        if (operator === "=")
          return appendDefaultableElement(base, valueNode, possibleDefaultValue);
        return appendRequiredElement(base, valueNode);
      });
    }
  }
  return ctx.$.parseSchema(
    sequences.map(
      (sequence) => isEmptyObject2(sequence) ? {
        proto: Array,
        exactLength: 0
      } : {
        proto: Array,
        sequence
      }
    )
  );
};
var appendRequiredElement = (base, element) => {
  if (base.defaultables || base.optionals) {
    return throwParseError11(
      base.variadic ? (
        // e.g. [boolean = true, ...string[], number]
        postfixAfterOptionalOrDefaultableMessage
      ) : requiredPostOptionalMessage
    );
  }
  if (base.variadic) {
    base.postfix = append2(base.postfix, element);
  } else {
    base.prefix = append2(base.prefix, element);
  }
  return base;
};
var appendOptionalElement = (base, element) => {
  if (base.variadic)
    return throwParseError11(optionalOrDefaultableAfterVariadicMessage);
  base.optionals = append2(base.optionals, element);
  return base;
};
var appendDefaultableElement = (base, element, value2) => {
  if (base.variadic)
    return throwParseError11(optionalOrDefaultableAfterVariadicMessage);
  if (base.optionals)
    return throwParseError11(defaultablePostOptionalMessage);
  base.defaultables = append2(base.defaultables, [[element, value2]]);
  return base;
};
var appendVariadicElement = (base, element) => {
  if (base.postfix) throwParseError11(multipleVariadicMesage);
  if (base.variadic) {
    if (!base.variadic.equals(element)) {
      throwParseError11(multipleVariadicMesage);
    }
  } else {
    base.variadic = element.internal;
  }
  return base;
};
var appendSpreadBranch = (base, branch) => {
  const spread = branch.select({ method: "find", kind: "sequence" });
  if (!spread) {
    return appendVariadicElement(base, $ark2.intrinsic.unknown);
  }
  spread.prefix?.forEach((node3) => appendRequiredElement(base, node3));
  spread.optionals?.forEach((node3) => appendOptionalElement(base, node3));
  if (spread.variadic) appendVariadicElement(base, spread.variadic);
  spread.postfix?.forEach((node3) => appendRequiredElement(base, node3));
  return base;
};
var writeNonArraySpreadMessage = (operand) => `Spread element must be an array (was ${operand})`;
var multipleVariadicMesage = "A tuple may have at most one variadic element";
var requiredPostOptionalMessage = "A required element may not follow an optional element";
var optionalOrDefaultableAfterVariadicMessage = "An optional element may not follow a variadic element";
var defaultablePostOptionalMessage = "A defaultable element may not follow an optional element without a default";

// parser/definition.ts
var parseCache = {};
var parseInnerDefinition = (def, ctx) => {
  if (typeof def === "string") {
    if (ctx.args && Object.keys(ctx.args).some((k) => def.includes(k))) {
      return parseString(def, ctx);
    }
    const scopeCache = parseCache[ctx.$.name] ??= {};
    return scopeCache[def] ??= parseString(def, ctx);
  }
  return hasDomain(def, "object") ? parseObject(def, ctx) : throwParseError12(writeBadDefinitionTypeMessage(domainOf2(def)));
};
var parseObject = (def, ctx) => {
  const objectKind = objectKindOf(def);
  switch (objectKind) {
    case void 0:
      if (hasArkKind2(def, "root")) return def;
      return parseObjectLiteral(def, ctx);
    case "Array":
      return parseTuple(def, ctx);
    case "RegExp":
      return ctx.$.node(
        "intersection",
        {
          domain: "string",
          pattern: def
        },
        { prereduced: true }
      );
    case "Function": {
      const resolvedDef = isThunk(def) ? def() : def;
      if (hasArkKind2(resolvedDef, "root")) return resolvedDef;
      return throwParseError12(writeBadDefinitionTypeMessage("Function"));
    }
    default:
      return throwParseError12(
        writeBadDefinitionTypeMessage(objectKind ?? printable3(def))
      );
  }
};
var parseTuple = (def, ctx) => maybeParseTupleExpression(def, ctx) ?? parseTupleLiteral(def, ctx);
var writeBadDefinitionTypeMessage = (actual) => `Type definitions must be strings or objects (was ${actual})`;

// type.ts
import {
  ArkErrors,
  BaseRoot,
  GenericRoot as GenericRoot2
} from "@ark/schema";
import {
  Callable as Callable2,
  Hkt
} from "@ark/util";
var InternalTypeParser = class extends Callable2 {
  constructor($) {
    const attach = Object.assign(
      {
        errors: ArkErrors,
        hkt: Hkt,
        $,
        raw: $.parse,
        module: $.constructor.module,
        scope: $.constructor.scope,
        define: $.define,
        match: $.match,
        generic: $.generic,
        schema: $.schema,
        // this won't be defined during bootstrapping, but externally always will be
        keywords: $.ambient,
        unit: $.unit,
        enumerated: $.enumerated,
        instanceOf: $.instanceOf,
        valueOf: $.valueOf,
        or: $.or,
        and: $.and,
        merge: $.merge,
        pipe: $.pipe
      },
      // also won't be defined during bootstrapping
      $.ambientAttachments
    );
    super(
      (...args) => {
        if (args.length === 1) {
          return $.parse(args[0]);
        }
        if (args.length === 2 && typeof args[0] === "string" && args[0][0] === "<" && args[0].at(-1) === ">") {
          const paramString = args[0].slice(1, -1);
          const params = $.parseGenericParams(paramString, {});
          return new GenericRoot2(
            params,
            args[1],
            $,
            $,
            null
          );
        }
        return $.parse(args);
      },
      {
        bind: $,
        attach
      }
    );
  }
};
var Type = BaseRoot;

// scope.ts
var $arkTypeRegistry = $ark3;
var InternalScope = class _InternalScope extends BaseScope {
  get ambientAttachments() {
    if (!$arkTypeRegistry.typeAttachments) return;
    return this.cacheGetter(
      "ambientAttachments",
      flatMorph($arkTypeRegistry.typeAttachments, (k, v) => [
        k,
        this.bindReference(v)
      ])
    );
  }
  preparseOwnAliasEntry(alias, def) {
    const firstParamIndex = alias.indexOf("<");
    if (firstParamIndex === -1) {
      if (hasArkKind3(def, "module") || hasArkKind3(def, "generic"))
        return [alias, def];
      const qualifiedName = this.name === "ark" ? alias : alias === "root" ? this.name : `${this.name}.${alias}`;
      const config = this.resolvedConfig.keywords?.[qualifiedName];
      if (config) def = [def, "@", config];
      return [alias, def];
    }
    if (alias.at(-1) !== ">") {
      throwParseError13(
        `'>' must be the last character of a generic declaration in a scope`
      );
    }
    const name = alias.slice(0, firstParamIndex);
    const paramString = alias.slice(firstParamIndex + 1, -1);
    return [
      name,
      // use a thunk definition for the generic so that we can parse
      // constraints within the current scope
      () => {
        const params = this.parseGenericParams(paramString, { alias: name });
        const generic2 = parseGeneric(params, def, this);
        return generic2;
      }
    ];
  }
  parseGenericParams(def, opts) {
    return parseGenericParamName(
      new ArkTypeScanner(def),
      [],
      this.createParseContext({
        ...opts,
        def,
        prefix: "generic"
      })
    );
  }
  normalizeRootScopeValue(resolution) {
    if (isThunk2(resolution) && !hasArkKind3(resolution, "generic"))
      return resolution();
    return resolution;
  }
  preparseOwnDefinitionFormat(def, opts) {
    return {
      ...opts,
      def,
      prefix: opts.alias ?? "type"
    };
  }
  parseOwnDefinitionFormat(def, ctx) {
    const isScopeAlias = ctx.alias && ctx.alias in this.aliases;
    if (!isScopeAlias && !ctx.args) ctx.args = { this: ctx.id };
    const result = parseInnerDefinition(def, ctx);
    if (isArray4(result)) {
      if (result[1] === "=") return throwParseError13(shallowDefaultableMessage);
      if (result[1] === "?") return throwParseError13(shallowOptionalMessage);
    }
    return result;
  }
  unit = (value2) => this.units([value2]);
  valueOf = (tsEnum) => this.units(enumValues(tsEnum));
  enumerated = (...values) => this.units(values);
  instanceOf = (ctor) => this.node("proto", { proto: ctor }, { prereduced: true });
  or = (...defs) => this.schema(defs.map((def) => this.parse(def)));
  and = (...defs) => defs.reduce(
    (node3, def) => node3.and(this.parse(def)),
    this.intrinsic.unknown
  );
  merge = (...defs) => defs.reduce(
    (node3, def) => node3.merge(this.parse(def)),
    this.intrinsic.object
  );
  pipe = (...morphs) => this.intrinsic.unknown.pipe(...morphs);
  match = new InternalMatchParser(this);
  declare = () => ({
    type: this.type
  });
  define(def) {
    return def;
  }
  type = new InternalTypeParser(this);
  static scope = (def, config = {}) => new _InternalScope(def, config);
  static module = (def, config = {}) => this.scope(def, config).export();
};
var scope = Object.assign(InternalScope.scope, {
  define: (def) => def
});
var Scope = InternalScope;

// keywords/builtins.ts
import { genericNode, intrinsic as intrinsic3 } from "@ark/schema";
import { Hkt as Hkt2 } from "@ark/util";
var MergeHkt = class extends Hkt2 {
  description = 'merge an object\'s properties onto another like `Merge(User, { isAdmin: "true" })`';
};
var Merge = genericNode(
  ["base", intrinsic3.object],
  ["props", intrinsic3.object]
)((args) => args.base.merge(args.props), MergeHkt);
var arkBuiltins = Scope.module({
  Key: intrinsic3.key,
  Merge
});

// keywords/constructors.ts
import {
  ecmascriptConstructors,
  flatMorph as flatMorph2,
  platformConstructors
} from "@ark/util";

// keywords/Array.ts
import { genericNode as genericNode2, intrinsic as intrinsic4, rootSchema } from "@ark/schema";
import { Hkt as Hkt3, liftArray } from "@ark/util";
var liftFromHkt = class extends Hkt3 {
};
var liftFrom = genericNode2("element")((args) => {
  const nonArrayElement = args.element.exclude(intrinsic4.Array);
  const lifted = nonArrayElement.array();
  return nonArrayElement.rawOr(lifted).pipe(liftArray).distribute(
    (branch) => branch.assertHasKind("morph").declareOut(lifted),
    rootSchema
  );
}, liftFromHkt);
var arkArray = Scope.module(
  {
    root: intrinsic4.Array,
    readonly: "root",
    index: intrinsic4.nonNegativeIntegerString,
    liftFrom
  },
  {
    name: "Array"
  }
);

// keywords/FormData.ts
import { rootSchema as rootSchema2 } from "@ark/schema";
import { registry } from "@ark/util";
var value = rootSchema2(["string", registry.FileConstructor]);
var parsedFormDataValue = value.rawOr(value.array());
var parsed = rootSchema2({
  meta: "an object representing parsed form data",
  domain: "object",
  index: {
    signature: "string",
    value: parsedFormDataValue
  }
});
var arkFormData = Scope.module(
  {
    root: ["instanceof", FormData],
    value,
    parsed,
    parse: rootSchema2({
      in: FormData,
      morphs: (data) => {
        const result = {};
        for (const [k, v] of data) {
          if (k in result) {
            const existing = result[k];
            if (typeof existing === "string" || existing instanceof registry.FileConstructor)
              result[k] = [existing, v];
            else existing.push(v);
          } else result[k] = v;
        }
        return result;
      },
      declaredOut: parsed
    })
  },
  {
    name: "FormData"
  }
);

// keywords/TypedArray.ts
var TypedArray = Scope.module(
  {
    Int8: ["instanceof", Int8Array],
    Uint8: ["instanceof", Uint8Array],
    Uint8Clamped: ["instanceof", Uint8ClampedArray],
    Int16: ["instanceof", Int16Array],
    Uint16: ["instanceof", Uint16Array],
    Int32: ["instanceof", Int32Array],
    Uint32: ["instanceof", Uint32Array],
    Float32: ["instanceof", Float32Array],
    Float64: ["instanceof", Float64Array],
    BigInt64: ["instanceof", BigInt64Array],
    BigUint64: ["instanceof", BigUint64Array]
  },
  {
    name: "TypedArray"
  }
);

// keywords/constructors.ts
var omittedPrototypes = {
  Boolean: 1,
  Number: 1,
  String: 1
};
var arkPrototypes = Scope.module({
  ...flatMorph2(
    { ...ecmascriptConstructors, ...platformConstructors },
    (k, v) => k in omittedPrototypes ? [] : [k, ["instanceof", v]]
  ),
  Array: arkArray,
  TypedArray,
  FormData: arkFormData
});

// keywords/number.ts
import { intrinsic as intrinsic5, rootSchema as rootSchema3 } from "@ark/schema";
var epoch = rootSchema3({
  domain: {
    domain: "number",
    meta: "a number representing a Unix timestamp"
  },
  divisor: {
    rule: 1,
    meta: `an integer representing a Unix timestamp`
  },
  min: {
    rule: -864e13,
    meta: `a Unix timestamp after -8640000000000000`
  },
  max: {
    rule: 864e13,
    meta: "a Unix timestamp before 8640000000000000"
  },
  meta: "an integer representing a safe Unix timestamp"
});
var integer = rootSchema3({
  domain: "number",
  divisor: 1
});
var number = Scope.module(
  {
    root: intrinsic5.number,
    integer,
    epoch,
    safe: rootSchema3({
      domain: {
        domain: "number",
        numberAllowsNaN: false
      },
      min: Number.MIN_SAFE_INTEGER,
      max: Number.MAX_SAFE_INTEGER
    }),
    NaN: ["===", Number.NaN],
    Infinity: ["===", Number.POSITIVE_INFINITY],
    NegativeInfinity: ["===", Number.NEGATIVE_INFINITY]
  },
  {
    name: "number"
  }
);

// keywords/string.ts
import {
  ArkErrors as ArkErrors2,
  intrinsic as intrinsic6,
  node,
  rootSchema as rootSchema4
} from "@ark/schema";
import {
  flatMorph as flatMorph3,
  numericStringMatcher,
  wellFormedIntegerMatcher
} from "@ark/util";
var regexStringNode = (regex, description) => node("intersection", {
  domain: "string",
  pattern: {
    rule: regex.source,
    flags: regex.flags,
    meta: description
  }
});
var stringIntegerRoot = regexStringNode(
  wellFormedIntegerMatcher,
  "a well-formed integer string"
);
var stringInteger = Scope.module(
  {
    root: stringIntegerRoot,
    parse: rootSchema4({
      in: stringIntegerRoot,
      morphs: (s, ctx) => {
        const parsed2 = Number.parseInt(s);
        return Number.isSafeInteger(parsed2) ? parsed2 : ctx.error(
          "an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER"
        );
      },
      declaredOut: intrinsic6.integer
    })
  },
  {
    name: "string.integer"
  }
);
var hex = regexStringNode(/^[0-9a-fA-F]+$/, "hex characters only");
var base64 = Scope.module(
  {
    root: regexStringNode(
      /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,
      "base64-encoded"
    ),
    url: regexStringNode(
      /^(?:[A-Za-z0-9_-]{4})*(?:[A-Za-z0-9_-]{2}(?:==|%3D%3D)?|[A-Za-z0-9_-]{3}(?:=|%3D)?)?$/,
      "base64url-encoded"
    )
  },
  {
    name: "string.base64"
  }
);
var preformattedCapitalize = regexStringNode(/^[A-Z].*$/, "capitalized");
var capitalize = Scope.module(
  {
    root: rootSchema4({
      in: "string",
      morphs: (s) => s.charAt(0).toUpperCase() + s.slice(1),
      declaredOut: preformattedCapitalize
    }),
    preformatted: preformattedCapitalize
  },
  {
    name: "string.capitalize"
  }
);
var isLuhnValid = (creditCardInput) => {
  const sanitized = creditCardInput.replace(/[- ]+/g, "");
  let sum = 0;
  let digit;
  let tmpNum;
  let shouldDouble = false;
  for (let i = sanitized.length - 1; i >= 0; i--) {
    digit = sanitized.substring(i, i + 1);
    tmpNum = Number.parseInt(digit, 10);
    if (shouldDouble) {
      tmpNum *= 2;
      if (tmpNum >= 10) sum += tmpNum % 10 + 1;
      else sum += tmpNum;
    } else sum += tmpNum;
    shouldDouble = !shouldDouble;
  }
  return !!(sum % 10 === 0 ? sanitized : false);
};
var creditCardMatcher = /^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/;
var creditCard = rootSchema4({
  domain: "string",
  pattern: {
    meta: "a credit card number",
    rule: creditCardMatcher.source
  },
  predicate: {
    meta: "a credit card number",
    predicate: isLuhnValid
  }
});
var iso8601Matcher = /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
var isParsableDate = (s) => !Number.isNaN(new Date(s).valueOf());
var parsableDate = rootSchema4({
  domain: "string",
  predicate: {
    meta: "a parsable date",
    predicate: isParsableDate
  }
}).assertHasKind("intersection");
var epochRoot = stringInteger.root.internal.narrow((s, ctx) => {
  const n = Number.parseInt(s);
  const out = number.epoch(n);
  if (out instanceof ArkErrors2) {
    ctx.errors.merge(out);
    return false;
  }
  return true;
}).configure(
  {
    description: "an integer string representing a safe Unix timestamp"
  },
  "self"
).assertHasKind("intersection");
var epoch2 = Scope.module(
  {
    root: epochRoot,
    parse: rootSchema4({
      in: epochRoot,
      morphs: (s) => new Date(s),
      declaredOut: intrinsic6.Date
    })
  },
  {
    name: "string.date.epoch"
  }
);
var isoRoot = regexStringNode(
  iso8601Matcher,
  "an ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) date"
).internal.assertHasKind("intersection");
var iso = Scope.module(
  {
    root: isoRoot,
    parse: rootSchema4({
      in: isoRoot,
      morphs: (s) => new Date(s),
      declaredOut: intrinsic6.Date
    })
  },
  {
    name: "string.date.iso"
  }
);
var stringDate = Scope.module(
  {
    root: parsableDate,
    parse: rootSchema4({
      declaredIn: parsableDate,
      in: "string",
      morphs: (s, ctx) => {
        const date = new Date(s);
        if (Number.isNaN(date.valueOf())) return ctx.error("a parsable date");
        return date;
      },
      declaredOut: intrinsic6.Date
    }),
    iso,
    epoch: epoch2
  },
  {
    name: "string.date"
  }
);
var email = regexStringNode(
  // https://www.regular-expressions.info/email.html
  /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/,
  "an email address"
);
var ipv4Segment = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
var ipv4Address = `(${ipv4Segment}[.]){3}${ipv4Segment}`;
var ipv4Matcher = new RegExp(`^${ipv4Address}$`);
var ipv6Segment = "(?:[0-9a-fA-F]{1,4})";
var ipv6Matcher = new RegExp(
  `^((?:${ipv6Segment}:){7}(?:${ipv6Segment}|:)|(?:${ipv6Segment}:){6}(?:${ipv4Address}|:${ipv6Segment}|:)|(?:${ipv6Segment}:){5}(?::${ipv4Address}|(:${ipv6Segment}){1,2}|:)|(?:${ipv6Segment}:){4}(?:(:${ipv6Segment}){0,1}:${ipv4Address}|(:${ipv6Segment}){1,3}|:)|(?:${ipv6Segment}:){3}(?:(:${ipv6Segment}){0,2}:${ipv4Address}|(:${ipv6Segment}){1,4}|:)|(?:${ipv6Segment}:){2}(?:(:${ipv6Segment}){0,3}:${ipv4Address}|(:${ipv6Segment}){1,5}|:)|(?:${ipv6Segment}:){1}(?:(:${ipv6Segment}){0,4}:${ipv4Address}|(:${ipv6Segment}){1,6}|:)|(?::((?::${ipv6Segment}){0,5}:${ipv4Address}|(?::${ipv6Segment}){1,7}|:)))(%[0-9a-zA-Z.]{1,})?$`
);
var ip = Scope.module(
  {
    root: ["v4 | v6", "@", "an IP address"],
    v4: regexStringNode(ipv4Matcher, "an IPv4 address"),
    v6: regexStringNode(ipv6Matcher, "an IPv6 address")
  },
  {
    name: "string.ip"
  }
);
var jsonStringDescription = "a JSON string";
var writeJsonSyntaxErrorProblem = (error) => {
  if (!(error instanceof SyntaxError)) throw error;
  return `must be ${jsonStringDescription} (${error})`;
};
var jsonRoot = rootSchema4({
  meta: jsonStringDescription,
  domain: "string",
  predicate: {
    meta: jsonStringDescription,
    predicate: (s, ctx) => {
      try {
        JSON.parse(s);
        return true;
      } catch (e) {
        return ctx.reject({
          code: "predicate",
          expected: jsonStringDescription,
          problem: writeJsonSyntaxErrorProblem(e)
        });
      }
    }
  }
});
var parseJson = (s, ctx) => {
  if (s.length === 0) {
    return ctx.error({
      code: "predicate",
      expected: jsonStringDescription,
      actual: "empty"
    });
  }
  try {
    return JSON.parse(s);
  } catch (e) {
    return ctx.error({
      code: "predicate",
      expected: jsonStringDescription,
      problem: writeJsonSyntaxErrorProblem(e)
    });
  }
};
var json = Scope.module(
  {
    root: jsonRoot,
    parse: rootSchema4({
      meta: "safe JSON string parser",
      in: "string",
      morphs: parseJson,
      declaredOut: intrinsic6.jsonObject
    })
  },
  {
    name: "string.json"
  }
);
var preformattedLower = regexStringNode(/^[a-z]*$/, "only lowercase letters");
var lower = Scope.module(
  {
    root: rootSchema4({
      in: "string",
      morphs: (s) => s.toLowerCase(),
      declaredOut: preformattedLower
    }),
    preformatted: preformattedLower
  },
  {
    name: "string.lower"
  }
);
var normalizedForms = ["NFC", "NFD", "NFKC", "NFKD"];
var preformattedNodes = flatMorph3(
  normalizedForms,
  (i, form) => [
    form,
    rootSchema4({
      domain: "string",
      predicate: (s) => s.normalize(form) === s,
      meta: `${form}-normalized unicode`
    })
  ]
);
var normalizeNodes = flatMorph3(
  normalizedForms,
  (i, form) => [
    form,
    rootSchema4({
      in: "string",
      morphs: (s) => s.normalize(form),
      declaredOut: preformattedNodes[form]
    })
  ]
);
var NFC = Scope.module(
  {
    root: normalizeNodes.NFC,
    preformatted: preformattedNodes.NFC
  },
  {
    name: "string.normalize.NFC"
  }
);
var NFD = Scope.module(
  {
    root: normalizeNodes.NFD,
    preformatted: preformattedNodes.NFD
  },
  {
    name: "string.normalize.NFD"
  }
);
var NFKC = Scope.module(
  {
    root: normalizeNodes.NFKC,
    preformatted: preformattedNodes.NFKC
  },
  {
    name: "string.normalize.NFKC"
  }
);
var NFKD = Scope.module(
  {
    root: normalizeNodes.NFKD,
    preformatted: preformattedNodes.NFKD
  },
  {
    name: "string.normalize.NFKD"
  }
);
var normalize = Scope.module(
  {
    root: "NFC",
    NFC,
    NFD,
    NFKC,
    NFKD
  },
  {
    name: "string.normalize"
  }
);
var numericRoot = regexStringNode(
  numericStringMatcher,
  "a well-formed numeric string"
);
var numeric = Scope.module(
  {
    root: numericRoot,
    parse: rootSchema4({
      in: numericRoot,
      morphs: (s) => Number.parseFloat(s),
      declaredOut: intrinsic6.number
    })
  },
  {
    name: "string.numeric"
  }
);
var semverMatcher = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
var semver = regexStringNode(
  semverMatcher,
  "a semantic version (see https://semver.org/)"
);
var preformattedTrim = regexStringNode(
  // no leading or trailing whitespace
  /^\S.*\S$|^\S?$/,
  "trimmed"
);
var trim = Scope.module(
  {
    root: rootSchema4({
      in: "string",
      morphs: (s) => s.trim(),
      declaredOut: preformattedTrim
    }),
    preformatted: preformattedTrim
  },
  {
    name: "string.trim"
  }
);
var preformattedUpper = regexStringNode(/^[A-Z]*$/, "only uppercase letters");
var upper = Scope.module(
  {
    root: rootSchema4({
      in: "string",
      morphs: (s) => s.toUpperCase(),
      declaredOut: preformattedUpper
    }),
    preformatted: preformattedUpper
  },
  {
    name: "string.upper"
  }
);
var isParsableUrl = (s) => {
  if (URL.canParse) return URL.canParse(s);
  try {
    new URL(s);
    return true;
  } catch {
    return false;
  }
};
var urlRoot = rootSchema4({
  domain: "string",
  predicate: {
    meta: "a URL string",
    predicate: isParsableUrl
  }
});
var url = Scope.module(
  {
    root: urlRoot,
    parse: rootSchema4({
      declaredIn: urlRoot,
      in: "string",
      morphs: (s, ctx) => {
        try {
          return new URL(s);
        } catch {
          return ctx.error("a URL string");
        }
      },
      declaredOut: rootSchema4(URL)
    })
  },
  {
    name: "string.url"
  }
);
var uuid = Scope.module(
  {
    // the meta tuple expression ensures the error message does not delegate
    // to the individual branches, which are too detailed
    root: ["versioned | nil | max", "@", "a UUID"],
    "#nil": "'00000000-0000-0000-0000-000000000000'",
    "#max": "'ffffffff-ffff-ffff-ffff-ffffffffffff'",
    "#versioned": /[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i,
    v1: regexStringNode(
      /^[0-9a-f]{8}-[0-9a-f]{4}-1[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
      "a UUIDv1"
    ),
    v2: regexStringNode(
      /^[0-9a-f]{8}-[0-9a-f]{4}-2[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
      "a UUIDv2"
    ),
    v3: regexStringNode(
      /^[0-9a-f]{8}-[0-9a-f]{4}-3[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
      "a UUIDv3"
    ),
    v4: regexStringNode(
      /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
      "a UUIDv4"
    ),
    v5: regexStringNode(
      /^[0-9a-f]{8}-[0-9a-f]{4}-5[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
      "a UUIDv5"
    ),
    v6: regexStringNode(
      /^[0-9a-f]{8}-[0-9a-f]{4}-6[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
      "a UUIDv6"
    ),
    v7: regexStringNode(
      /^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
      "a UUIDv7"
    ),
    v8: regexStringNode(
      /^[0-9a-f]{8}-[0-9a-f]{4}-8[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i,
      "a UUIDv8"
    )
  },
  {
    name: "string.uuid"
  }
);
var string = Scope.module(
  {
    root: intrinsic6.string,
    alpha: regexStringNode(/^[A-Za-z]*$/, "only letters"),
    alphanumeric: regexStringNode(
      /^[A-Za-z\d]*$/,
      "only letters and digits 0-9"
    ),
    hex,
    base64,
    capitalize,
    creditCard,
    date: stringDate,
    digits: regexStringNode(/^\d*$/, "only digits 0-9"),
    email,
    integer: stringInteger,
    ip,
    json,
    lower,
    normalize,
    numeric,
    semver,
    trim,
    upper,
    url,
    uuid
  },
  {
    name: "string"
  }
);

// keywords/ts.ts
import { genericNode as genericNode3, intrinsic as intrinsic7, node as node2 } from "@ark/schema";
import {
  Hkt as Hkt4
} from "@ark/util";
var arkTsKeywords = Scope.module({
  bigint: intrinsic7.bigint,
  boolean: intrinsic7.boolean,
  false: intrinsic7.false,
  never: intrinsic7.never,
  null: intrinsic7.null,
  number: intrinsic7.number,
  object: intrinsic7.object,
  string: intrinsic7.string,
  symbol: intrinsic7.symbol,
  true: intrinsic7.true,
  unknown: intrinsic7.unknown,
  undefined: intrinsic7.undefined
});
var unknown = Scope.module(
  {
    root: intrinsic7.unknown,
    any: intrinsic7.unknown
  },
  {
    name: "unknown"
  }
);
var json2 = Scope.module(
  {
    root: intrinsic7.jsonObject,
    stringify: node2("morph", {
      in: intrinsic7.jsonObject,
      morphs: (data) => JSON.stringify(data),
      declaredOut: intrinsic7.string
    })
  },
  {
    name: "object.json"
  }
);
var object = Scope.module(
  {
    root: intrinsic7.object,
    json: json2
  },
  {
    name: "object"
  }
);
var RecordHkt = class extends Hkt4 {
  description = 'instantiate an object from an index signature and corresponding value type like `Record("string", "number")`';
};
var Record = genericNode3(["K", intrinsic7.key], "V")(
  (args) => ({
    domain: "object",
    index: {
      signature: args.K,
      value: args.V
    }
  }),
  RecordHkt
);
var PickHkt = class extends Hkt4 {
  description = 'pick a set of properties from an object like `Pick(User, "name | age")`';
};
var Pick = genericNode3(["T", intrinsic7.object], ["K", intrinsic7.key])(
  (args) => args.T.pick(args.K),
  PickHkt
);
var OmitHkt = class extends Hkt4 {
  description = 'omit a set of properties from an object like `Omit(User, "age")`';
};
var Omit = genericNode3(["T", intrinsic7.object], ["K", intrinsic7.key])(
  (args) => args.T.omit(args.K),
  OmitHkt
);
var PartialHkt = class extends Hkt4 {
  description = "make all named properties of an object optional like `Partial(User)`";
};
var Partial = genericNode3(["T", intrinsic7.object])(
  (args) => args.T.partial(),
  PartialHkt
);
var RequiredHkt = class extends Hkt4 {
  description = "make all named properties of an object required like `Required(User)`";
};
var Required = genericNode3(["T", intrinsic7.object])(
  (args) => args.T.required(),
  RequiredHkt
);
var ExcludeHkt = class extends Hkt4 {
  description = 'exclude branches of a union like `Exclude("boolean", "true")`';
};
var Exclude = genericNode3("T", "U")(
  (args) => args.T.exclude(args.U),
  ExcludeHkt
);
var ExtractHkt = class extends Hkt4 {
  description = 'extract branches of a union like `Extract("0 | false | 1", "number")`';
};
var Extract = genericNode3("T", "U")(
  (args) => args.T.extract(args.U),
  ExtractHkt
);
var arkTsGenerics = Scope.module({
  Exclude,
  Extract,
  Omit,
  Partial,
  Pick,
  Record,
  Required
});

// keywords/keywords.ts
var ark = scope(
  {
    ...arkTsKeywords,
    ...arkTsGenerics,
    ...arkPrototypes,
    ...arkBuiltins,
    string,
    number,
    object,
    unknown
  },
  { prereducedAliases: true, name: "ark" }
);
var keywords = ark.export();
Object.assign($arkTypeRegistry.ambient, keywords);
$arkTypeRegistry.typeAttachments = {
  string: keywords.string.root,
  number: keywords.number.root,
  bigint: keywords.bigint,
  boolean: keywords.boolean,
  symbol: keywords.symbol,
  undefined: keywords.undefined,
  null: keywords.null,
  object: keywords.object.root,
  unknown: keywords.unknown.root,
  false: keywords.false,
  true: keywords.true,
  never: keywords.never,
  arrayIndex: keywords.Array.index,
  Key: keywords.Key,
  Record: keywords.Record,
  Array: keywords.Array.root,
  Date: keywords.Date
};
var type = Object.assign(
  ark.type,
  // assign attachments newly parsed in keywords
  // future scopes add these directly from the
  // registry when their TypeParsers are instantiated
  $arkTypeRegistry.typeAttachments
);
var match = ark.match;
var generic = ark.generic;
var schema = ark.schema;
var define = ark.define;
var declare = ark.declare;

// module.ts
import {
  RootModule
} from "@ark/schema";
var Module = RootModule;
export {
  ArkError,
  ArkErrors3 as ArkErrors,
  Generic,
  Hkt5 as Hkt,
  Module,
  Type,
  ark,
  configure,
  declare,
  define,
  generic,
  inferred,
  keywords,
  match,
  scope,
  type
};
