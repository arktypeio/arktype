/** THIS FILE IS AUTOGENERATED FROM ark/repo/dtsGen.ts **/
// prettier-ignore
export const typeDts = "declare module \"arktype\" {\n    import { regex } from '@ark/regex';\nexport { regex } from '@ark/regex';\nimport * as _ark_schema from '@ark/schema';\nimport { BaseRoot, BaseParseContext, TypeMeta, arkKind, GenericAst, GenericParamAst, writeUnsatisfiedParameterConstraintMessage, GenericRoot, genericParamNames, resolvableReferenceIn, writeUnresolvableMessage, writeNonSubmoduleDotMessage, emptyBrandNameMessage, writeUnboundableMessage, writeUnassignableDefaultValueMessage, writeIndivisibleMessage, writeNonStructuralOperandMessage, PrivateDeclaration, writeMissingSubmoduleAccessMessage, writeInvalidPropertyKeyMessage, UndeclaredKeyBehavior, Sequence, postfixAfterOptionalOrDefaultableMessage, BaseMappedPropInner, OptionalMappedPropInner, Prop, InclusiveNumericRangeSchema, ExclusiveNumericRangeSchema, ExactLength, InclusiveDateRangeSchema, ExclusiveDateRangeSchema, Divisor, Pattern, Morph, ToJsonSchema, JsonSchema, NodeSelector, Predicate, BaseNode, Disjoint, StandardSchemaV1, ArkErrors, unwrapDefault, RootSchema, BaseParseOptions, ArkSchemaScopeConfig, exportedNameOf, toInternalScope, NodeKind, RootKind, NodeSchema, nodeOfKind, reducibleKindOf, PreparsedNodeResolution, writeDuplicateAliasError, BaseScope, AliasDefEntry, GenericParamDef, BaseParseContextInput, flatResolutionsOf, LazyGenericBody, RootModule, ArkError } from '@ark/schema';\nexport { ArkError, ArkErrors, ArkSchemaConfig, ArkSchemaScopeConfig, JsonSchema, Traversal, TraversalError } from '@ark/schema';\nimport * as util from '@ark/util';\nimport { Scanner, requireKeys, ErrorMessage, Completion, writeUnmatchedGroupCloseMessage, writeUnclosedGroupMessage, defined, anyOrNever, Stringifiable, Hkt, array, typeToString, arkKeyOf, NumberLiteral, join, lastOf, BigintLiteral, WhitespaceChar, trim as trim$1, writeMalformedNumericLiteralMessage, show, merge, Key, Backslash, ErrorType, satisfy, conform, arkIndexableOf, arkGet, toArkKey, listable, intersectUnion, inferred, optionalKeyOf, JsonStructure, Callable, unset, numericStringKeyOf, isDisjoint, unionToTuple, propValueOf, Constructor, get, Fn, applyElementLabels, flattenListable, Brand, noSuggest, ifEmptyObjectLiteral, Primitive, objectKindOrDomainOf, equals, requiredKeyOf, Json, omit, pick, Digit, liftArray, EcmascriptObjects, PlatformObjects, isSafelyMappable, intersectArrays, unionKeyOf } from '@ark/util';\nexport { Hkt, ParseError, inferred } from '@ark/util';\nimport { ArkSchemaConfig } from '@ark/schema/config';\n\ntype StringifiablePrefixOperator = \"keyof\";\ndeclare const minComparators: {\n    readonly \">\": true;\n    readonly \">=\": true;\n};\ntype MinComparator = keyof typeof minComparators;\ndeclare const maxComparators: {\n    readonly \"<\": true;\n    readonly \"<=\": true;\n};\ntype MaxComparator = keyof typeof maxComparators;\ndeclare const comparators: {\n    \">\": boolean;\n    \">=\": boolean;\n    \"<\": boolean;\n    \"<=\": boolean;\n    \"==\": boolean;\n};\ntype Comparator = keyof typeof comparators;\ntype InvertedComparators = {\n    \"<\": \">\";\n    \">\": \"<\";\n    \"<=\": \">=\";\n    \">=\": \"<=\";\n    \"==\": \"==\";\n};\ntype BranchOperator = \"&\" | \"|\" | \"|>\";\ntype OpenLeftBound = {\n    limit: LimitLiteral;\n    comparator: MinComparator;\n};\ndeclare const writeOpenRangeMessage: <min extends LimitLiteral, comparator extends MinComparator>(min: min, comparator: comparator) => writeOpenRangeMessage<min, comparator>;\ntype writeOpenRangeMessage<min extends LimitLiteral, comparator extends MinComparator> = `Left bounds are only valid when paired with right bounds (try ...${comparator}${min})`;\ntype writeUnpairableComparatorMessage<comparator extends Comparator> = `Left-bounded expressions must specify their limits using < or <= (was ${comparator})`;\ndeclare const writeUnpairableComparatorMessage: <comparator extends Comparator>(comparator: comparator) => writeUnpairableComparatorMessage<comparator>;\ndeclare const writeMultipleLeftBoundsMessage: <openLimit extends LimitLiteral, openComparator extends MinComparator, limit extends LimitLiteral, comparator extends MinComparator>(openLimit: openLimit, openComparator: openComparator, limit: limit, comparator: comparator) => writeMultipleLeftBoundsMessage<openLimit, openComparator, limit, comparator>;\ntype writeMultipleLeftBoundsMessage<openLimit extends LimitLiteral, openComparator extends MinComparator, limit extends LimitLiteral, comparator extends MinComparator> = `An expression may have at most one left bound (parsed ${openLimit}${InvertedComparators[openComparator]}, ${limit}${InvertedComparators[comparator]})`;\n\ndeclare const terminatingChars: {\n    readonly \" \": 1;\n    readonly \"\\n\": 1;\n    readonly \"\\t\": 1;\n    readonly \"<\": 1;\n    readonly \">\": 1;\n    readonly \"=\": 1;\n    readonly \"|\": 1;\n    readonly \"&\": 1;\n    readonly \")\": 1;\n    readonly \"[\": 1;\n    readonly \"%\": 1;\n    readonly \",\": 1;\n    readonly \":\": 1;\n    readonly \"?\": 1;\n    readonly \"#\": 1;\n};\ntype TerminatingChar = keyof typeof terminatingChars;\ndeclare const finalizingLookaheads: {\n    readonly \">\": 1;\n    readonly \",\": 1;\n    readonly \"\": 1;\n    readonly \"=\": 1;\n    readonly \"?\": 1;\n};\ntype FinalizingLookahead = keyof typeof finalizingLookaheads;\ndeclare const lookaheadIsFinalizing: (lookahead: string, unscanned: string) => lookahead is \">\" | \",\" | \"=\" | \"?\";\ntype lookaheadIsFinalizing<lookahead extends string, unscanned extends string> = lookahead extends \">\" ? unscanned extends `=${infer nextUnscanned}` ? nextUnscanned extends `=${string}` ? true : false : Scanner.skipWhitespace<unscanned> extends (\"\" | `${TerminatingChar}${string}`) ? true : false : lookahead extends \"=\" ? unscanned extends `=${string}` ? false : true : lookahead extends \",\" | \"?\" ? true : false;\ntype InfixToken = Comparator | \"|\" | \"&\" | \"%\" | \":\" | \"=>\" | \"|>\" | \"#\" | \"@\" | \"=\";\ntype PostfixToken = \"[]\" | \"?\";\n\ntype BranchState$1 = {\n    prefixes: StringifiablePrefixOperator[];\n    leftBound: OpenLeftBound | null;\n    intersection: BaseRoot | null;\n    union: BaseRoot | null;\n    pipe: BaseRoot | null;\n};\ntype RootedRuntimeState = requireKeys<RuntimeState, \"root\">;\ndeclare class RuntimeState {\n    root: BaseRoot | undefined;\n    branches: BranchState$1;\n    finalizer: FinalizingLookahead | undefined;\n    groups: BranchState$1[];\n    scanner: Scanner;\n    ctx: BaseParseContext;\n    constructor(scanner: Scanner, ctx: BaseParseContext);\n    error(message: string): never;\n    hasRoot(): this is RootedRuntimeState;\n    setRoot(root: BaseRoot): void;\n    unsetRoot(): this[\"root\"];\n    constrainRoot(...args: Parameters<BaseRoot<any>[\"constrain\"]>): void;\n    finalize(finalizer: FinalizingLookahead): void;\n    reduceLeftBound(limit: LimitLiteral, comparator: Comparator): void;\n    finalizeBranches(): void;\n    finalizeGroup(): void;\n    addPrefix(prefix: StringifiablePrefixOperator): void;\n    applyPrefixes(): void;\n    pushRootToBranch(token: BranchOperator): void;\n    parseUntilFinalizer(): RootedRuntimeState;\n    parseOperator(this: RootedRuntimeState): void;\n    parseOperand(): void;\n    private assertRangeUnset;\n    reduceGroupOpen(): void;\n    previousOperator(): MinComparator | StringifiablePrefixOperator | InfixToken | undefined;\n    shiftedByOne(): this;\n}\n\ntype StaticState = {\n    root: unknown;\n    branches: BranchState;\n    groups: BranchState[];\n    finalizer: FinalizingLookahead | ErrorMessage | undefined;\n    scanned: string;\n    unscanned: string;\n};\ntype BranchState = {\n    prefixes: StringifiablePrefixOperator[];\n    leftBound: OpenLeftBound | undefined;\n    intersection: unknown;\n    pipe: unknown;\n    union: unknown;\n};\ndeclare namespace s {\n    type initialize<def extends string> = from<{\n        root: undefined;\n        branches: initialBranches;\n        groups: [];\n        finalizer: undefined;\n        scanned: \"\";\n        unscanned: def;\n    }>;\n    type error<message extends string> = from<{\n        root: ErrorMessage<message>;\n        branches: initialBranches;\n        groups: [];\n        finalizer: ErrorMessage<message>;\n        scanned: \"\";\n        unscanned: \"\";\n    }>;\n    type completion<text extends string> = from<{\n        root: Completion<text>;\n        branches: initialBranches;\n        groups: [];\n        finalizer: Completion<text>;\n        scanned: \"\";\n        unscanned: \"\";\n    }>;\n    type initialBranches = branchesFrom<{\n        prefixes: [];\n        leftBound: undefined;\n        intersection: undefined;\n        pipe: undefined;\n        union: undefined;\n    }>;\n    type updateScanned<previousScanned extends string, previousUnscanned extends string, updatedUnscanned extends string> = previousUnscanned extends `${infer justScanned}${updatedUnscanned}` ? `${previousScanned}${justScanned}` : previousScanned;\n    type setRoot<s extends StaticState, root, unscanned extends string = s[\"unscanned\"]> = from<{\n        root: root;\n        branches: s[\"branches\"];\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type addPrefix<s extends StaticState, prefix extends StringifiablePrefixOperator, unscanned extends string = s[\"unscanned\"]> = from<{\n        root: s[\"root\"];\n        branches: {\n            prefixes: [...s[\"branches\"][\"prefixes\"], prefix];\n            leftBound: s[\"branches\"][\"leftBound\"];\n            intersection: s[\"branches\"][\"intersection\"];\n            pipe: s[\"branches\"][\"pipe\"];\n            union: s[\"branches\"][\"union\"];\n        };\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type reduceBranch<s extends StaticState, token extends BranchOperator, unscanned extends string> = s[\"branches\"][\"leftBound\"] extends {} ? openRangeError<s[\"branches\"][\"leftBound\"]> : from<{\n        root: undefined;\n        branches: {\n            prefixes: [];\n            leftBound: undefined;\n            intersection: token extends \"&\" ? mergeToIntersection<s> : undefined;\n            union: token extends \"|\" ? mergeToUnion<s> : token extends \"|>\" ? undefined : s[\"branches\"][\"union\"];\n            pipe: token extends \"|>\" ? mergeToPipe<s> : s[\"branches\"][\"pipe\"];\n        };\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type reduceLeftBound<s extends StaticState, limit extends LimitLiteral, comparator extends Comparator, unscanned extends string> = comparator extends \"<\" | \"<=\" ? s[\"branches\"][\"leftBound\"] extends {} ? s.error<writeMultipleLeftBoundsMessage<s[\"branches\"][\"leftBound\"][\"limit\"], s[\"branches\"][\"leftBound\"][\"comparator\"], limit, InvertedComparators[comparator]>> : from<{\n        root: undefined;\n        branches: {\n            prefixes: s[\"branches\"][\"prefixes\"];\n            leftBound: {\n                limit: limit;\n                comparator: InvertedComparators[comparator];\n            };\n            intersection: s[\"branches\"][\"intersection\"];\n            pipe: s[\"branches\"][\"pipe\"];\n            union: s[\"branches\"][\"union\"];\n        };\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }> : s.error<writeUnpairableComparatorMessage<comparator>>;\n    type reduceRange<s extends StaticState, minLimit extends LimitLiteral, minComparator extends MinComparator, maxComparator extends MaxComparator, maxLimit extends LimitLiteral, unscanned extends string> = s.from<{\n        root: [minLimit, minComparator, [s[\"root\"], maxComparator, maxLimit]];\n        branches: {\n            prefixes: s[\"branches\"][\"prefixes\"];\n            leftBound: undefined;\n            intersection: s[\"branches\"][\"intersection\"];\n            pipe: s[\"branches\"][\"pipe\"];\n            union: s[\"branches\"][\"union\"];\n        };\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type reduceSingleBound<s extends StaticState, comparator extends Comparator, limit extends number | string, unscanned extends string> = s.from<{\n        root: [s[\"root\"], comparator, limit];\n        branches: {\n            prefixes: s[\"branches\"][\"prefixes\"];\n            leftBound: undefined;\n            intersection: s[\"branches\"][\"intersection\"];\n            pipe: s[\"branches\"][\"pipe\"];\n            union: s[\"branches\"][\"union\"];\n        };\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type mergeToIntersection<s extends StaticState> = s[\"branches\"][\"intersection\"] extends undefined ? mergePrefixes<s> : [s[\"branches\"][\"intersection\"], \"&\", mergePrefixes<s>];\n    type mergeToUnion<s extends StaticState> = s[\"branches\"][\"union\"] extends undefined ? mergeToIntersection<s> : [s[\"branches\"][\"union\"], \"|\", mergeToIntersection<s>];\n    type mergeToPipe<s extends StaticState> = s[\"branches\"][\"pipe\"] extends undefined ? mergeToUnion<s> : [s[\"branches\"][\"pipe\"], \"|>\", mergeToUnion<s>];\n    type mergePrefixes<s extends StaticState, remaining extends unknown[] = s[\"branches\"][\"prefixes\"]> = remaining extends [infer head, ...infer tail] ? [\n        head,\n        mergePrefixes<s, tail>\n    ] : s[\"root\"];\n    type popGroup<stack extends BranchState[], top extends BranchState> = [\n        ...stack,\n        top\n    ];\n    type finalizeGroup<s extends StaticState, unscanned extends string> = s[\"branches\"][\"leftBound\"] extends {} ? openRangeError<s[\"branches\"][\"leftBound\"]> : s[\"groups\"] extends popGroup<infer stack, infer top> ? from<{\n        groups: stack;\n        branches: top;\n        root: mergeToPipe<s>;\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }> : s.error<writeUnmatchedGroupCloseMessage<\")\", unscanned>>;\n    type reduceGroupOpen<s extends StaticState, unscanned extends string> = from<{\n        groups: [...s[\"groups\"], s[\"branches\"]];\n        branches: initialBranches;\n        root: undefined;\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type finalize<s extends StaticState, finalizer extends FinalizingLookahead> = s[\"groups\"] extends [] ? s[\"branches\"][\"leftBound\"] extends {} ? openRangeError<s[\"branches\"][\"leftBound\"]> : from<{\n        root: mergeToPipe<s>;\n        groups: s[\"groups\"];\n        branches: initialBranches;\n        finalizer: finalizer;\n        scanned: s[\"scanned\"];\n        unscanned: s[\"unscanned\"];\n    }> : s.error<writeUnclosedGroupMessage<\")\">>;\n    type openRangeError<range extends defined<BranchState[\"leftBound\"]>> = s.error<writeOpenRangeMessage<range[\"limit\"], range[\"comparator\"]>>;\n    type previousOperator<s extends StaticState> = s[\"branches\"][\"leftBound\"] extends {} ? s[\"branches\"][\"leftBound\"][\"comparator\"] : s[\"branches\"][\"prefixes\"] extends ([\n        ...unknown[],\n        infer tail extends string\n    ]) ? tail : s[\"branches\"][\"intersection\"] extends {} ? \"&\" : s[\"branches\"][\"union\"] extends {} ? \"|\" : undefined;\n    type scanTo<s extends StaticState, unscanned extends string> = from<{\n        root: s[\"root\"];\n        branches: s[\"branches\"];\n        groups: s[\"groups\"];\n        finalizer: s[\"finalizer\"];\n        scanned: updateScanned<s[\"scanned\"], s[\"unscanned\"], unscanned>;\n        unscanned: unscanned;\n    }>;\n    type from<s extends StaticState> = s;\n    type branchesFrom<b extends BranchState> = b;\n}\n\ntype KeywordConfig = {\n    [k in keyof Ark.flat as parseConfigurableFlatAlias<k, Ark.flat[k]>]?: TypeMeta.Collapsible;\n};\ntype parseConfigurableFlatAlias<k extends string, v> = [\n    v\n] extends [anyOrNever] ? k : v extends {\n    [arkKind]: \"generic\" | \"module\";\n} ? never : k extends `${infer prefix}.root` ? prefix : k;\ninterface ArkConfig extends ArkSchemaConfig {\n    keywords?: KeywordConfig;\n}\ndeclare const configure: <config extends ArkConfig>(config: config) => config;\ndeclare global {\n    export interface ArkEnv {\n        $(): Ark;\n    }\n}\n/**\n * This mirrors the global ArkEnv namespace as a local export. We use it instead\n * of the global internally due to a bug in twoslash that prevents `ark/docs`\n * from building if we refer to the global directly.\n *\n * If, in the future, docs can build while arktype refers to `ArkEnv.$` directly,\n * this can be removed.\n */\ndeclare namespace ArkAmbient {\n    type $ = ReturnType<ArkEnv[\"$\"]>;\n    type meta = ArkEnv.meta;\n    type prototypes = ArkEnv.prototypes;\n}\n\ntype astToString<ast> = ast extends InferredAst | DefAst ? ast[2] : ast extends PostfixExpression<infer operator, infer operand> ? operator extends \"[]\" ? `${astToString<operand>}[]` : never : ast extends InfixExpression<infer operator, infer l, infer r> ? operator extends \"&\" | \"|\" | \"%\" | Comparator ? `${astToString<l>} ${operator} ${astToString<r>}` : never : ast extends Stringifiable ? `${ast extends bigint ? `${ast}n` : ast}` : \"...\";\ntype writeConstrainedMorphMessage<constrainedAst> = `To constrain the output of ${astToString<constrainedAst>}, pipe like myMorph.to('number > 0').\nTo constrain the input, intersect like myMorph.and('number > 0').`;\n\ntype GenericInstantiationAst<generic extends GenericAst = GenericAst, argAsts extends unknown[] = unknown[]> = [generic, \"<>\", argAsts];\ntype inferGenericInstantiation<g extends GenericAst, argAsts extends unknown[], $, args> = g[\"bodyDef\"] extends Hkt ? Hkt.apply<g[\"bodyDef\"], {\n    [i in keyof argAsts]: inferExpression<argAsts[i], $, args>;\n}> : inferDefinition<g[\"bodyDef\"], resolveScope<g[\"$\"], $>, {\n    [i in keyof g[\"names\"] & `${number}` as g[\"names\"][i]]: inferExpression<argAsts[i & keyof argAsts], resolveScope<g[\"arg$\"], $>, args>;\n}>;\ntype validateGenericInstantiation<g extends GenericAst, argAsts extends unknown[], $, args> = validateGenericArgs<g[\"paramsAst\"], argAsts, $, args, []>;\ntype validateGenericArgs<params extends array<GenericParamAst>, argAsts extends array, $, args, indices extends 1[]> = argAsts extends readonly [infer arg, ...infer argsTail] ? validateAst<arg, $, args> extends infer e extends ErrorMessage ? e : inferAstRoot<arg, $, args> extends params[indices[\"length\"]][1] ? validateGenericArgs<params, argsTail, $, args, [...indices, 1]> : ErrorMessage<writeUnsatisfiedParameterConstraintMessage<params[indices[\"length\"]][0], typeToString<params[indices[\"length\"]][1]>, astToString<arg>>> : undefined;\ntype resolveScope<g$, $> = g$ extends UnparsedScope ? $ : g$;\n\ntype inferAstRoot<ast, $, args> = ast extends array ? inferExpression<ast, $, args> : never;\ntype inferAstIn<ast, $, args> = distill.In<inferAstRoot<ast, $, args>>;\ntype DefAst<def = unknown, alias extends string = string> = [\n    def,\n    \"def\",\n    alias\n];\ntype InferredAst<t = unknown, def extends string = string> = [\n    t,\n    \"inferred\",\n    def\n];\ntype inferExpression<ast, $, args> = ast extends array ? ast extends InferredAst<infer resolution> ? resolution : ast extends DefAst<infer def> ? inferDefinition<def, $, args> : ast extends GenericInstantiationAst<infer g, infer argAsts> ? inferGenericInstantiation<g, argAsts, $, args> : ast[1] extends \"[]\" ? inferExpression<ast[0], $, args>[] : ast[1] extends \"|\" ? inferExpression<ast[0], $, args> | inferExpression<ast[2], $, args> : ast[1] extends \"&\" ? inferIntersection<inferExpression<ast[0], $, args>, inferExpression<ast[2], $, args>> : ast[1] extends \"|>\" ? inferPipe<inferExpression<ast[0], $, args>, inferExpression<ast[2], $, args>> : ast[1] extends \"=\" ? type.infer<ast[2]> extends infer defaultValue ? withDefault<inferExpression<ast[0], $, args>, defaultValue> : never : ast[1] extends \"#\" ? type.brand<inferExpression<ast[0], $, args>, ast[2]> : ast[1] extends Comparator ? ast[0] extends LimitLiteral ? inferExpression<ast[2], $, args> : inferExpression<ast[0], $, args> : ast[1] extends \"%\" ? inferExpression<ast[0], $, args> : ast[1] extends \"?\" ? inferExpression<ast[0], $, args> : ast[0] extends \"keyof\" ? arkKeyOf<inferExpression<ast[1], $, args>> : never : never;\ntype PostfixExpression<operator extends PostfixToken = PostfixToken, operand = unknown> = readonly [operand, operator];\ntype InfixExpression<operator extends InfixToken = InfixToken, l = unknown, r = unknown> = [l, operator, r];\n\ntype StringLiteral<contents extends string = string> = DoubleQuotedStringLiteral<contents> | SingleQuotedStringLiteral<contents>;\ntype DoubleQuotedStringLiteral<contents extends string = string> = `\"${contents}\"`;\ntype SingleQuotedStringLiteral<contents extends string = string> = `'${contents}'`;\ndeclare const parseEnclosed: (s: RuntimeState, enclosing: EnclosingStartToken) => void;\ntype parseEnclosed<s extends StaticState, enclosingStart extends EnclosingStartToken, unscanned extends string> = Scanner.shiftUntilEscapable<unscanned, EnclosingTokens[enclosingStart], \"\"> extends Scanner.shiftResult<infer scanned, infer nextUnscanned> ? nextUnscanned extends \"\" ? s.error<writeUnterminatedEnclosedMessage<scanned, enclosingStart>> : s.setRoot<s, InferredAst<enclosingStart extends EnclosingQuote ? scanned : enclosingStart extends \"/\" ? regex.infer<scanned> : Date, `${enclosingStart}${scanned}${EnclosingTokens[enclosingStart]}`>, nextUnscanned extends Scanner.shift<string, infer unscanned> ? unscanned : \"\"> : never;\ndeclare const enclosingQuote: {\n    readonly \"'\": 1;\n    readonly '\"': 1;\n};\ntype EnclosingQuote = keyof typeof enclosingQuote;\ndeclare const enclosingTokens: {\n    readonly \"d'\": \"'\";\n    readonly 'd\"': \"\\\"\";\n    readonly \"'\": \"'\";\n    readonly '\"': \"\\\"\";\n    readonly \"/\": \"/\";\n};\ntype EnclosingTokens = typeof enclosingTokens;\ntype EnclosingStartToken = keyof EnclosingTokens;\ndeclare const enclosingCharDescriptions: {\n    readonly '\"': \"double-quote\";\n    readonly \"'\": \"single-quote\";\n    readonly \"/\": \"forward slash\";\n};\ntype enclosingCharDescriptions = typeof enclosingCharDescriptions;\ndeclare const writeUnterminatedEnclosedMessage: <fragment extends string, enclosingStart extends EnclosingStartToken>(fragment: fragment, enclosingStart: enclosingStart) => writeUnterminatedEnclosedMessage<fragment, enclosingStart>;\ntype writeUnterminatedEnclosedMessage<fragment extends string, enclosingStart extends EnclosingStartToken> = `${enclosingStart}${fragment} requires a closing ${enclosingCharDescriptions[EnclosingTokens[enclosingStart]]}`;\n\ndeclare const parseUnenclosed: (s: RuntimeState) => void;\ntype parseUnenclosed<s extends StaticState, $, args> = Scanner.shiftUntil<s[\"unscanned\"], TerminatingChar> extends (Scanner.shiftResult<infer token, infer unscanned>) ? tryResolve<s, unscanned, token, $, args> extends s.from<infer s> ? s : never : never;\ntype parseResolution<s extends StaticState, unscanned extends string, alias extends string, resolution, $, args> = resolutionToAst<alias, resolution> extends infer ast ? ast extends GenericAst ? parseGenericInstantiation<alias, ast, s.scanTo<s, unscanned>, $, args> : s.setRoot<s, ast, unscanned> : never;\ndeclare const parseGenericInstantiation: (name: string, g: GenericRoot, s: RuntimeState) => BaseRoot;\ntype parseGenericInstantiation<name extends string, g extends GenericAst, s extends StaticState, $, args> = Scanner.skipWhitespace<s[\"unscanned\"]> extends `<${infer unscanned}` ? parseGenericArgs<name, g, unscanned, $, args> extends infer result ? result extends ParsedArgs<infer argAsts, infer nextUnscanned> ? s.setRoot<s, GenericInstantiationAst<g, argAsts>, nextUnscanned> : result : never : s.error<writeInvalidGenericArgCountMessage<name, genericParamNames<g[\"paramsAst\"]>, [\n]>>;\ntype tryResolve<s extends StaticState, unscanned extends string, token extends string, $, args> = token extends keyof args ? parseResolution<s, unscanned, token, args[token], $, args> : token extends keyof $ ? parseResolution<s, unscanned, token, $[token], $, args> : token extends keyof ArkAmbient.$ ? parseResolution<s, unscanned, token, ArkAmbient.$[token], $, args> : `#${token}` extends keyof $ ? parseResolution<s, unscanned, token, $[`#${token}`], $, args> : token extends NumberLiteral<infer n> ? s.setRoot<s, InferredAst<n, token>, unscanned> : token extends (`${infer submodule extends keyof $ & string}.${infer reference}`) ? tryResolveSubmodule<token, $[submodule], reference, s, unscanned, $, args, [\n    submodule\n]> : token extends (`${infer submodule extends keyof ArkAmbient.$ & string}.${infer reference}`) ? tryResolveSubmodule<token, ArkAmbient.$[submodule], reference, s, unscanned, $, args, [\n    submodule\n]> : token extends BigintLiteral<infer b> ? s.setRoot<s, InferredAst<b, token>, unscanned> : token extends \"keyof\" ? s.addPrefix<s, \"keyof\", unscanned> : unresolvableState<s, token, $, args, []>;\ntype tryResolveSubmodule<token extends string, resolution, reference extends string, s extends StaticState, unscanned extends string, $, args, submodulePath extends string[]> = resolution extends {\n    [arkKind]: \"module\";\n} ? reference extends keyof resolution ? parseResolution<s, unscanned, token, resolution[reference], $, args> : reference extends (`${infer nestedSubmodule extends keyof resolution & string}.${infer nestedReference}`) ? tryResolveSubmodule<token, resolution[nestedSubmodule], nestedReference, s, unscanned, $, args, [\n    ...submodulePath,\n    nestedSubmodule\n]> : unresolvableState<s, reference, resolution, {}, submodulePath> : s.error<writeNonSubmoduleDotMessage<lastOf<submodulePath>>>;\n/** Provide valid completions for the current token, or fallback to an\n * unresolvable error if there are none */\ntype unresolvableState<s extends StaticState, token extends string, resolutions, args, submodulePath extends string[]> = [\n    token,\n    s[\"unscanned\"]\n] extends [\"\", Scanner.shift<\"#\", infer unscanned>] ? Scanner.shiftUntil<unscanned, TerminatingChar> extends (Scanner.shiftResult<infer name, string>) ? s.error<writePrefixedPrivateReferenceMessage<name>> : never : validReferenceFromToken<token, resolutions, args, submodulePath> extends (never) ? s.error<writeUnresolvableMessage<qualifiedReference<token, submodulePath>>> : s.completion<`${s[\"scanned\"]}${qualifiedReference<validReferenceFromToken<token, resolutions, args, submodulePath>, submodulePath>}`>;\ntype qualifiedReference<reference extends string, submodulePath extends string[]> = join<[...submodulePath, reference], \".\">;\ntype validReferenceFromToken<token extends string, $, args, submodulePath extends string[]> = Extract<submodulePath[\"length\"] extends 0 ? BaseCompletions<$, args> : resolvableReferenceIn<$>, `${token}${string}`>;\ntype writeMissingRightOperandMessage<token extends string, unscanned extends string = \"\"> = `Token '${token}' requires a right operand${unscanned extends \"\" ? \"\" : ` before '${unscanned}'`}`;\ndeclare const writeMissingRightOperandMessage: <token extends string, unscanned extends string>(token: token, unscanned?: unscanned) => writeMissingRightOperandMessage<token, unscanned>;\n\ndeclare const parseOperand: (s: RuntimeState) => void;\ntype parseOperand<s extends StaticState, $, args> = s[\"unscanned\"] extends Scanner.shift<infer lookahead, infer unscanned> ? lookahead extends \"(\" ? s.reduceGroupOpen<s, unscanned> : lookahead extends EnclosingStartToken ? parseEnclosed<s, lookahead, unscanned> : lookahead extends WhitespaceChar ? parseOperand<s.scanTo<s, unscanned>, $, args> : lookahead extends \"d\" ? unscanned extends (Scanner.shift<infer enclosing extends EnclosingQuote, infer nextUnscanned>) ? parseEnclosed<s, `d${enclosing}`, nextUnscanned> : parseUnenclosed<s, $, args> : parseUnenclosed<s, $, args> : s.completion<`${s[\"scanned\"]}${BaseCompletions<$, args>}`>;\n\ntype UnitLiteralKeyword = \"null\" | \"undefined\" | \"true\" | \"false\";\ntype UnitLiteral = StringLiteral | BigintLiteral | NumberLiteral | DateLiteral | UnitLiteralKeyword;\ntype ParsedDefaultableProperty = readonly [BaseRoot, \"=\", unknown];\ndeclare const parseDefault: (s: RootedRuntimeState) => ParsedDefaultableProperty;\ntype parseDefault<root, unscanned extends string> = trim$1<unscanned> extends infer defaultValue extends UnitLiteral ? [\n    root,\n    \"=\",\n    defaultValue\n] : ErrorMessage<writeNonLiteralDefaultMessage<trim$1<unscanned>>>;\ndeclare const writeNonLiteralDefaultMessage: <defaultDef extends string>(defaultDef: defaultDef) => writeNonLiteralDefaultMessage<defaultDef>;\ntype writeNonLiteralDefaultMessage<defaultDef extends string> = `Default value '${defaultDef}' must a literal value`;\n\ndeclare const parseBound: (s: RootedRuntimeState, start: ComparatorStartChar) => void;\ntype parseBound<s extends StaticState, start extends ComparatorStartChar, unscanned extends string, $, args> = shiftComparator<start, unscanned> extends infer shiftResultOrError ? shiftResultOrError extends (Scanner.shiftResult<infer comparator extends Comparator, infer nextUnscanned>) ? s[\"root\"] extends (InferredAst<Date | number, `${infer limit extends number | DateLiteral}`>) ? s.reduceLeftBound<s, limit, comparator, nextUnscanned> : parseRightBound<s.scanTo<s, nextUnscanned>, comparator, $, args> : shiftResultOrError : never;\ntype OneCharComparator = \">\" | \"<\";\ntype ComparatorStartChar = Comparator extends `${infer char}${string}` ? char : never;\ndeclare const shiftComparator: (s: RuntimeState, start: ComparatorStartChar) => Comparator;\ntype shiftComparator<start extends ComparatorStartChar, unscanned extends string> = unscanned extends `=${infer nextUnscanned}` ? [`${start}=`, nextUnscanned] : [start & OneCharComparator, unscanned];\ndeclare const parseRightBound: (s: RootedRuntimeState, comparator: Comparator) => void;\ntype parseRightBound<s extends StaticState, comparator extends Comparator, $, args> = parseOperand<s, $, args> extends infer nextState extends StaticState ? nextState[\"root\"] extends (InferredAst<unknown, `${infer limit extends number | DateLiteral}`>) ? s[\"branches\"][\"leftBound\"] extends {} ? comparator extends MaxComparator ? s.reduceRange<s, s[\"branches\"][\"leftBound\"][\"limit\"], s[\"branches\"][\"leftBound\"][\"comparator\"], comparator, limit, nextState[\"unscanned\"]> : s.error<writeUnpairableComparatorMessage<comparator>> : s.reduceSingleBound<s, comparator, limit, nextState[\"unscanned\"]> : s.error<writeInvalidLimitMessage<comparator, astToString<nextState[\"root\"]>, \"right\">> : never;\ndeclare const writeInvalidLimitMessage: <comparator extends Comparator, limit extends string | number, boundKind extends BoundExpressionKind>(comparator: comparator, limit: limit, boundKind: boundKind) => writeInvalidLimitMessage<comparator, limit, boundKind>;\ntype writeInvalidLimitMessage<comparator extends Comparator, limit extends string | number, boundKind extends BoundExpressionKind> = `Comparator ${boundKind extends \"left\" ? InvertedComparators[comparator] : comparator} must be ${boundKind extends \"left\" ? \"preceded\" : \"followed\"} by a corresponding literal (was ${limit})`;\ntype BoundExpressionKind = \"left\" | \"right\";\n\ndeclare const parseBrand: (s: RootedRuntimeState) => void;\ntype parseBrand<s extends StaticState, unscanned extends string> = Scanner.shiftUntil<Scanner.skipWhitespace<unscanned>, TerminatingChar> extends Scanner.shiftResult<`${infer brandName}`, infer nextUnscanned> ? brandName extends \"\" ? s.error<emptyBrandNameMessage> : s.setRoot<s, [s[\"root\"], \"#\", brandName], nextUnscanned> : never;\n\ndeclare const parseDivisor: (s: RootedRuntimeState) => void;\ntype parseDivisor<s extends StaticState, unscanned extends string> = Scanner.shiftUntil<Scanner.skipWhitespace<unscanned>, TerminatingChar> extends Scanner.shiftResult<infer scanned, infer nextUnscanned> ? scanned extends `${infer divisor extends number}` ? divisor extends 0 ? s.error<writeInvalidDivisorMessage<0>> : s.setRoot<s, [s[\"root\"], \"%\", divisor], nextUnscanned> : s.error<writeInvalidDivisorMessage<scanned>> : never;\ndeclare const writeInvalidDivisorMessage: <divisor extends string | number>(divisor: divisor) => writeInvalidDivisorMessage<divisor>;\ntype writeInvalidDivisorMessage<divisor extends string | number> = `% operator must be followed by a non-zero integer literal (was ${divisor})`;\n\ndeclare const parseOperator: (s: RootedRuntimeState) => void;\ntype parseOperator<s extends StaticState, $, args> = s[\"unscanned\"] extends Scanner.shift<infer lookahead, infer unscanned> ? lookahead extends \"[\" ? unscanned extends Scanner.shift<\"]\", infer nextUnscanned> ? s.setRoot<s, [s[\"root\"], \"[]\"], nextUnscanned> : s.error<incompleteArrayTokenMessage> : lookahead extends \"|\" ? unscanned extends Scanner.shift<\">\", infer nextUnscanned> ? s.reduceBranch<s, \"|>\", nextUnscanned> : s.reduceBranch<s, lookahead, unscanned> : lookahead extends \"&\" ? s.reduceBranch<s, lookahead, unscanned> : lookahead extends \")\" ? s.finalizeGroup<s, unscanned> : lookaheadIsFinalizing<lookahead, unscanned> extends true ? s.finalize<s.scanTo<s, unscanned>, lookahead & FinalizingLookahead> : lookahead extends ComparatorStartChar ? parseBound<s, lookahead, unscanned, $, args> : lookahead extends \"%\" ? parseDivisor<s, unscanned> : lookahead extends \"#\" ? parseBrand<s, unscanned> : lookahead extends WhitespaceChar ? parseOperator<s.scanTo<s, unscanned>, $, args> : s.error<writeUnexpectedCharacterMessage<lookahead>> : s.finalize<s, \"\">;\ndeclare const writeUnexpectedCharacterMessage: <char extends string, shouldBe extends string>(char: char, shouldBe?: shouldBe) => writeUnexpectedCharacterMessage<char, shouldBe>;\ntype writeUnexpectedCharacterMessage<char extends string, shouldBe extends string = \"\"> = `'${char}' is not allowed here${shouldBe extends \"\" ? \"\" : ` (should be ${shouldBe})`}`;\ndeclare const incompleteArrayTokenMessage = \"Missing expected ']'\";\ntype incompleteArrayTokenMessage = typeof incompleteArrayTokenMessage;\n\ndeclare const parseString: (def: string, ctx: BaseParseContext) => InnerParseResult;\n/**\n * Try to parse the definition from right to left using the most common syntax.\n * This can be much more efficient for simple definitions.\n */\ntype parseString<def extends string, $, args> = def extends keyof $ ? resolutionToAst<def, $[def]> : def extends `${infer child}[]` ? child extends keyof $ ? [\n    resolutionToAst<child, $[child]>,\n    \"[]\"\n] : fullStringParse<s.initialize<def>, $, args> : fullStringParse<s.initialize<def>, $, args>;\ntype inferString<def extends string, $, args> = inferAstRoot<parseString<def, $, args>, $, args>;\ntype BaseCompletions<$, args, otherSuggestions extends string = never> = resolvableReferenceIn<$> | resolvableReferenceIn<ArkAmbient.$> | (keyof args & string) | StringifiablePrefixOperator | otherSuggestions;\ndeclare const fullStringParse: (s: RuntimeState) => InnerParseResult;\ntype fullStringParse<s extends StaticState, $, args> = extractFinalizedResult<parseUntilFinalizer<s, $, args>>;\ndeclare const parseUntilFinalizer: (s: RuntimeState) => RootedRuntimeState;\ntype parseUntilFinalizer<s extends StaticState, $, args> = s[\"finalizer\"] extends undefined ? parseUntilFinalizer<next<s, $, args>, $, args> : s;\ndeclare const next: (s: RuntimeState) => void;\ntype next<s extends StaticState, $, args> = s[\"root\"] extends undefined ? parseOperand<s, $, args> : parseOperator<s, $, args>;\ntype extractFinalizedResult<s extends StaticState> = s[\"finalizer\"] extends \"\" ? s[\"root\"] : s[\"finalizer\"] extends ErrorMessage ? s[\"finalizer\"] : s[\"finalizer\"] extends \"?\" ? [s[\"root\"], \"?\"] : s[\"finalizer\"] extends \"=\" ? parseDefault<s[\"root\"], s[\"unscanned\"]> : ErrorMessage<writeUnexpectedCharacterMessage<s[\"finalizer\"] & string>>;\n\ndeclare const parseGenericArgs: (name: string, g: GenericRoot, s: RuntimeState) => BaseRoot[];\ntype parseGenericArgs<name extends string, g extends GenericAst, unscanned extends string, $, args> = _parseGenericArgs<name, g, unscanned, $, args, [], []>;\ntype ParsedArgs<result extends unknown[] = unknown[], unscanned extends string = string> = {\n    result: result;\n    unscanned: unscanned;\n};\ndeclare const _parseGenericArgs: (name: string, g: GenericRoot, s: RuntimeState, argNodes: BaseRoot[]) => BaseRoot[];\ntype _parseGenericArgs<name extends string, g extends GenericAst, unscanned extends string, $, args, argDefs extends string[], argAsts extends unknown[]> = parseUntilFinalizer<s.initialize<unscanned>, $, args> extends (infer finalArgState extends StaticState) ? {\n    defs: [\n        ...argDefs,\n        finalArgState[\"scanned\"] extends `${infer def}${\",\" | \">\"}` ? def : finalArgState[\"scanned\"]\n    ];\n    asts: [...argAsts, finalArgState[\"root\"]];\n    unscanned: finalArgState[\"unscanned\"];\n} extends ({\n    defs: infer nextDefs extends string[];\n    asts: infer nextAsts extends unknown[];\n    unscanned: infer nextUnscanned extends string;\n}) ? finalArgState[\"finalizer\"] extends \">\" ? nextAsts[\"length\"] extends g[\"paramsAst\"][\"length\"] ? ParsedArgs<nextAsts, nextUnscanned> : s.error<writeInvalidGenericArgCountMessage<name, genericParamNames<g[\"paramsAst\"]>, nextDefs>> : finalArgState[\"finalizer\"] extends \",\" ? _parseGenericArgs<name, g, nextUnscanned, $, args, nextDefs, nextAsts> : finalArgState[\"finalizer\"] extends ErrorMessage ? finalArgState : s.error<writeUnclosedGroupMessage<\">\">> : never : never;\ndeclare const writeInvalidGenericArgCountMessage: <name extends string, params extends array<string>, argDefs extends array<string>>(name: name, params: params, argDefs: argDefs) => writeInvalidGenericArgCountMessage<name, params, argDefs>;\ntype writeInvalidGenericArgCountMessage<name extends string, params extends array<string>, argDefs extends array<string>> = `${name}<${join<params, \", \">}> requires exactly ${params[\"length\"]} args (got ${argDefs[\"length\"]}${argDefs[\"length\"] extends (0) ? \"\" : `: ${join<argDefs, \",\">}`})`;\n\ntype validateRange<l, comparator extends Comparator, r, $, args> = [\n    l\n] extends [LimitLiteral] ? validateBound<r, comparator, l, \"left\", $, args> : [l] extends [[infer leftAst, Comparator, unknown]] ? ErrorMessage<writeDoubleRightBoundMessage<astToString<leftAst>>> : validateBound<l, comparator, r & LimitLiteral, \"right\", $, args>;\ntype validateBound<boundedAst, comparator extends Comparator, limit extends LimitLiteral, boundKind extends BoundExpressionKind, $, args> = inferAstRoot<boundedAst, $, args> extends infer bounded ? isNumericallyBoundable<bounded> extends true ? limit extends number ? validateAst<boundedAst, $, args> : ErrorMessage<writeInvalidLimitMessage<comparator, limit, boundKind>> : [bounded] extends [Date] ? validateAst<boundedAst, $, args> : [bounded] extends [InferredMorph] ? ErrorMessage<writeConstrainedMorphMessage<boundedAst>> : ErrorMessage<writeUnboundableMessage<typeToString<bounded>>> : never;\ntype isNumericallyBoundable<bounded> = [\n    bounded\n] extends [number] ? true : [bounded] extends [string] ? true : [bounded] extends [array] ? true : false;\ndeclare const writeDoubleRightBoundMessage: <root extends string>(root: root) => writeDoubleRightBoundMessage<root>;\ntype writeDoubleRightBoundMessage<root extends string> = `Expression ${root} must have at most one right bound`;\n\ntype validateDefault<baseAst, unitLiteral extends UnitLiteral, $, args> = validateAst<baseAst, $, args> extends infer e extends ErrorMessage ? e : type.infer<unitLiteral> extends inferAstIn<baseAst, $, args> ? undefined : ErrorMessage<writeUnassignableDefaultValueMessage<astToString<baseAst>, unitLiteral>>;\n\ntype validateDivisor<l, $, args> = inferAstRoot<l, $, args> extends infer data ? [\n    data\n] extends [number] ? validateAst<l, $, args> : [data] extends [InferredMorph] ? ErrorMessage<writeConstrainedMorphMessage<l>> : ErrorMessage<writeIndivisibleMessage<data>> : never;\n\ntype validateKeyof<operandAst, $, args> = inferAstRoot<operandAst, $, args> extends infer data ? [\n    data\n] extends [object] ? validateAst<operandAst, $, args> : ErrorMessage<writeNonStructuralOperandMessage<\"keyof\", typeToString<data>>> : never;\n\ntype validateAst<ast, $, args> = ast extends ErrorMessage ? ast : ast extends InferredAst ? validateInferredAst<ast[0], ast[2]> : ast extends DefAst ? ast[2] extends PrivateDeclaration<infer name> ? ErrorMessage<writePrefixedPrivateReferenceMessage<name>> : undefined : ast extends PostfixExpression<\"[]\" | \"?\", infer operand> ? validateAst<operand, $, args> : ast extends InfixExpression<infer operator, infer l, infer r> ? operator extends BranchOperator ? validateInfix<ast, $, args> : operator extends Comparator ? validateRange<l, operator, r, $, args> : operator extends \"%\" ? validateDivisor<l, $, args> : operator extends \"=\" ? validateDefault<l, r & UnitLiteral, $, args> : operator extends \"#\" ? validateAst<l, $, args> : ErrorMessage<writeUnexpectedExpressionMessage<astToString<ast>>> : ast extends [\"keyof\", infer operand] ? validateKeyof<operand, $, args> : ast extends GenericInstantiationAst<infer g, infer argAsts> ? validateGenericInstantiation<g, argAsts, $, args> : ErrorMessage<writeUnexpectedExpressionMessage<astToString<ast>>> & {\n    ast: ast;\n};\ntype writeUnexpectedExpressionMessage<expression extends string> = `Failed to parse the expression resulting from ${expression}`;\ndeclare const writePrefixedPrivateReferenceMessage: <name extends string>(name: name) => writePrefixedPrivateReferenceMessage<name>;\ntype writePrefixedPrivateReferenceMessage<name extends string> = `Private type references should not include '#'. Use '${name}' instead.`;\ntype validateInferredAst<inferred, def extends string> = def extends NumberLiteral ? number extends inferred ? ErrorMessage<writeMalformedNumericLiteralMessage<def, \"number\">> : undefined : def extends BigintLiteral ? bigint extends inferred ? ErrorMessage<writeMalformedNumericLiteralMessage<def, \"bigint\">> : undefined : [inferred] extends [anyOrNever] ? undefined : def extends PrivateDeclaration<infer name> ? ErrorMessage<writePrefixedPrivateReferenceMessage<name>> : inferred extends Generic ? ErrorMessage<writeInvalidGenericArgCountMessage<def, inferred[\"names\"], []>> : inferred extends {\n    [arkKind]: \"module\";\n} ? \"root\" extends keyof inferred ? undefined : ErrorMessage<writeMissingSubmoduleAccessMessage<def>> : def extends ErrorMessage ? def : undefined;\ntype validateString<def extends string, $, args> = parseString<def, $, args> extends infer ast ? validateAst<ast, $, args> extends infer result extends ErrorMessage ? result extends Completion<infer text> ? text : result : def : never;\ntype validateInfix<ast extends InfixExpression, $, args> = validateAst<ast[0], $, args> extends infer e extends ErrorMessage ? e : validateAst<ast[2], $, args> extends infer e extends ErrorMessage ? e : undefined;\ndeclare const shallowOptionalMessage = \"Optional definitions like 'string?' are only valid as properties in an object or tuple\";\ntype shallowOptionalMessage = typeof shallowOptionalMessage;\ndeclare const shallowDefaultableMessage = \"Defaultable definitions like 'number = 0' are only valid as properties in an object or tuple\";\ntype shallowDefaultableMessage = typeof shallowDefaultableMessage;\n\ntype inferObjectLiteral<def extends object, $, args> = show<\"...\" extends keyof def ? merge<inferDefinition<def[\"...\"], $, args>, _inferObjectLiteral<def, $, args>> : _inferObjectLiteral<def, $, args>>;\n/**\n * Infers the contents of an object literal, ignoring a spread definition\n */\ntype _inferObjectLiteral<def extends object, $, args> = {\n    -readonly [k in keyof def as nonOptionalKeyFromEntry<k, def[k], $, args>]: inferDefinition<def[k], $, args>;\n} & {\n    -readonly [k in keyof def as optionalKeyFromEntry<k, def[k]>]?: def[k] extends OptionalPropertyDefinition<infer baseDef> ? inferDefinition<baseDef, $, args> : inferDefinition<def[k], $, args>;\n};\ntype validateObjectLiteral<def, $, args> = {\n    [k in keyof def]: preparseKey<k> extends (infer parsedKey extends PreparsedKey) ? parsedKey extends PreparsedEntryKey<\"index\"> ? validateString<parsedKey[\"normalized\"], $, args> extends (ErrorMessage<infer message>) ? ErrorType<message> : inferDefinition<parsedKey[\"normalized\"], $, args> extends Key ? validateProperty<def[k], parsedKey[\"kind\"], $, args> : ErrorMessage<writeInvalidPropertyKeyMessage<parsedKey[\"normalized\"]>> : validateProperty<def[k], parsedKey[\"kind\"], $, args> : never;\n};\ntype nonOptionalKeyFromEntry<k extends PropertyKey, v, $, args> = preparseKey<k> extends infer parsedKey ? parsedKey extends PreparsedEntryKey<\"required\"> ? [\n    v\n] extends [OptionalPropertyDefinition] ? [\n    v\n] extends [anyOrNever] ? parsedKey[\"normalized\"] : never : parsedKey[\"normalized\"] : parsedKey extends PreparsedEntryKey<\"index\"> ? inferDefinition<parsedKey[\"normalized\"], $, args> & Key : never : never;\ntype optionalKeyFromEntry<k extends PropertyKey, v> = preparseKey<k> extends infer parsedKey ? parsedKey extends PreparsedEntryKey<\"optional\"> ? parsedKey[\"normalized\"] : v extends OptionalPropertyDefinition ? k : never : never;\ntype normalizedKeyKind<kind extends EntryKeyKind> = kind extends \"index\" ? string : Key;\ntype PreparsedEntryKey<kind extends EntryKeyKind = EntryKeyKind, normalized extends normalizedKeyKind<kind> = normalizedKeyKind<kind>> = {\n    kind: kind;\n    normalized: normalized;\n};\ntype PreparsedSpecialKey<kind extends SpecialKeyKind = SpecialKeyKind> = {\n    kind: kind;\n};\ntype PreparsedKey = PreparsedEntryKey | PreparsedSpecialKey;\ndeclare namespace PreparsedKey {\n    type from<t extends PreparsedKey> = t;\n}\ntype ParsedKeyKind = EntryKeyKind | SpecialKeyKind;\ntype EntryKeyKind = \"required\" | \"optional\" | \"index\";\ntype SpecialKeyKind = \"spread\" | \"undeclared\";\ntype MetaKey = \"...\" | \"+\";\ntype IndexKey<def extends string = string> = `[${def}]`;\ndeclare const preparseKey: (key: Key) => PreparsedKey;\ntype preparseKey<k> = k extends symbol ? PreparsedKey.from<{\n    kind: \"required\";\n    normalized: k;\n}> : k extends `${infer inner}?` ? inner extends `${infer baseName}${Backslash}` ? PreparsedKey.from<{\n    kind: \"required\";\n    normalized: `${baseName}?`;\n}> : PreparsedKey.from<{\n    kind: \"optional\";\n    normalized: inner;\n}> : k extends \"+\" ? {\n    kind: \"undeclared\";\n} : k extends \"...\" ? {\n    kind: \"spread\";\n} : k extends `${Backslash}${infer escapedMeta extends MetaKey}` ? PreparsedKey.from<{\n    kind: \"required\";\n    normalized: escapedMeta;\n}> : k extends IndexKey<infer def> ? PreparsedKey.from<{\n    kind: \"index\";\n    normalized: def;\n}> : PreparsedKey.from<{\n    kind: \"required\";\n    normalized: k extends (`${Backslash}${infer escapedIndexKey extends IndexKey}`) ? escapedIndexKey : k extends Key ? k : `${k & number}`;\n}>;\ndeclare const writeInvalidSpreadTypeMessage: <def extends string>(def: def) => writeInvalidSpreadTypeMessage<def>;\ntype writeInvalidSpreadTypeMessage<def extends string> = `Spread operand must resolve to an object literal type (was ${def})`;\n\ntype ParsedOptionalProperty = readonly [BaseRoot, \"?\"];\ntype validateProperty<def, keyKind extends ParsedKeyKind, $, args> = [\n    def\n] extends [anyOrNever] ? \n/** this extra [anyOrNever] check is required to ensure that nested `type` invocations\n * like the following are not prematurely validated by the outer call:\n *\n * ```ts\n * type({\n * \t\"test?\": type(\"string\").pipe(x => x === \"true\")\n * })\n * ```\n */\ndef : keyKind extends \"spread\" ? def extends validateInnerDefinition<def, $, args> ? inferDefinition<def, $, args> extends object ? def : ErrorType<writeInvalidSpreadTypeMessage<typeToString<inferDefinition<def, $, args>>>> : validateInnerDefinition<def, $, args> : keyKind extends \"undeclared\" ? UndeclaredKeyBehavior : keyKind extends \"required\" ? validateInnerDefinition<def, $, args> : def extends OptionalPropertyDefinition ? ErrorMessage<invalidOptionalKeyKindMessage> : isDefaultable<def, $, args> extends true ? ErrorMessage<invalidDefaultableKeyKindMessage> : validateInnerDefinition<def, $, args>;\ntype isDefaultable<def, $, args> = def extends DefaultablePropertyTuple ? true : def extends PossibleDefaultableStringDefinition ? parseString<def, $, args> extends DefaultablePropertyTuple ? true : false : false;\ntype OptionalPropertyDefinition<baseDef = unknown> = OptionalPropertyTuple<baseDef> | OptionalPropertyString<baseDef & string>;\ntype OptionalPropertyString<baseDef extends string = string> = `${baseDef}?`;\ntype OptionalPropertyTuple<baseDef = unknown> = readonly [baseDef, \"?\"];\ntype PossibleDefaultableStringDefinition = `${string}=${string}`;\ntype DefaultablePropertyTuple<baseDef = unknown, thunkableProperty = unknown> = readonly [baseDef, \"=\", thunkableProperty];\ndeclare const invalidOptionalKeyKindMessage = \"Only required keys may make their values optional, e.g. { [mySymbol]: ['number', '?'] }\";\ntype invalidOptionalKeyKindMessage = typeof invalidOptionalKeyKindMessage;\ndeclare const invalidDefaultableKeyKindMessage = \"Only required keys may specify default values, e.g. { value: 'number = 0' }\";\ntype invalidDefaultableKeyKindMessage = typeof invalidDefaultableKeyKindMessage;\n\ntype validateTupleLiteral<def extends array, $, args> = parseSequence<def, $, args> extends infer s extends SequenceParseState ? Readonly<s[\"validated\"]> : never;\ntype inferTupleLiteral<def extends array, $, args> = parseSequence<def, $, args> extends infer s extends SequenceParseState ? s[\"inferred\"] : never;\ntype SequencePhase = satisfy<keyof Sequence.Inner, SequencePhase.prefix | SequencePhase.optionals | SequencePhase.defaultables | SequencePhase.postfix>;\ndeclare namespace SequencePhase {\n    type prefix = \"prefix\";\n    type optionals = \"optionals\";\n    type defaultables = \"defaultables\";\n    type postfix = \"postfix\";\n}\ntype SequenceParseState = {\n    unscanned: array;\n    inferred: array;\n    validated: array;\n    phase: SequencePhase;\n};\ntype parseSequence<def extends array, $, args> = parseNextElement<{\n    unscanned: def;\n    inferred: [];\n    validated: [];\n    phase: SequencePhase.prefix;\n}, $, args>;\ntype PreparsedElementKind = \"required\" | SequencePhase.optionals | SequencePhase.defaultables;\ntype PreparsedElement = {\n    head: unknown;\n    tail: array;\n    inferred: unknown;\n    validated: unknown;\n    kind: PreparsedElementKind;\n    spread: boolean;\n};\ndeclare namespace PreparsedElement {\n    type from<result extends PreparsedElement> = result;\n    type required = \"required\";\n    type optionals = \"optionals\";\n    type defaultables = \"defaultables\";\n}\ntype preparseNextState<s extends SequenceParseState, $, args> = s[\"unscanned\"] extends readonly [\"...\", infer head, ...infer tail] ? preparseNextElement<head, tail, true, $, args> : s[\"unscanned\"] extends readonly [infer head, ...infer tail] ? preparseNextElement<head, tail, false, $, args> : null;\ntype preparseNextElement<head, tail extends array, spread extends boolean, $, args> = PreparsedElement.from<{\n    head: head;\n    tail: tail;\n    inferred: inferDefinition<head, $, args>;\n    validated: validateInnerDefinition<head, $, args>;\n    kind: head extends OptionalPropertyDefinition ? PreparsedElement.optionals : head extends DefaultablePropertyTuple ? PreparsedElement.defaultables : isDefaultable<head, $, args> extends true ? PreparsedElement.defaultables : PreparsedElement.required;\n    spread: spread;\n}>;\ntype parseNextElement<s extends SequenceParseState, $, args> = preparseNextState<s, $, args> extends infer next extends PreparsedElement ? parseNextElement<{\n    unscanned: next[\"tail\"];\n    inferred: nextInferred<s, next>;\n    validated: nextValidated<s, next>;\n    phase: next[\"kind\"] extends (SequencePhase.optionals | SequencePhase.defaultables) ? next[\"kind\"] : number extends nextInferred<s, next>[\"length\"] ? s[\"phase\"] : SequencePhase.prefix;\n}, $, args> : s;\ntype nextInferred<s extends SequenceParseState, next extends PreparsedElement> = next[\"spread\"] extends true ? [\n    ...s[\"inferred\"],\n    ...conform<next[\"inferred\"], array>\n] : next[\"kind\"] extends SequencePhase.optionals ? [\n    ...s[\"inferred\"],\n    next[\"inferred\"]?\n] : [...s[\"inferred\"], next[\"inferred\"]];\ntype nextValidated<s extends SequenceParseState, next extends PreparsedElement> = [\n    ...s[\"validated\"],\n    ...nextValidatedSpreadOperatorIfPresent<s, next>,\n    nextValidatedElement<s, next>\n];\ntype nextValidatedSpreadOperatorIfPresent<s extends SequenceParseState, next extends PreparsedElement> = next[\"spread\"] extends true ? [\n    next[\"inferred\"] extends infer spreadOperand extends array ? [\n        number,\n        number\n    ] extends ([\n        s[\"inferred\"][\"length\"],\n        spreadOperand[\"length\"]\n    ]) ? ErrorMessage<multipleVariadicMessage> : \"...\" : ErrorMessage<writeNonArraySpreadMessage<next[\"head\"]>>\n] : [];\ntype nextValidatedElement<s extends SequenceParseState, next extends PreparsedElement> = next[\"kind\"] extends SequencePhase.optionals ? next[\"spread\"] extends true ? ErrorMessage<spreadOptionalMessage> : s[\"phase\"] extends SequencePhase.postfix ? ErrorMessage<optionalOrDefaultableAfterVariadicMessage> : next[\"validated\"] : next[\"kind\"] extends SequencePhase.defaultables ? next[\"spread\"] extends true ? ErrorMessage<spreadDefaultableMessage> : s[\"phase\"] extends SequencePhase.optionals ? ErrorMessage<defaultablePostOptionalMessage> : s[\"phase\"] extends SequencePhase.postfix ? ErrorMessage<optionalOrDefaultableAfterVariadicMessage> : next[\"validated\"] : [s[\"phase\"], next[\"spread\"]] extends ([\n    SequencePhase.optionals | SequencePhase.defaultables,\n    false\n]) ? ErrorMessage<postfixAfterOptionalOrDefaultableMessage> : next[\"validated\"];\ndeclare const writeNonArraySpreadMessage: <operand extends string>(operand: operand) => writeNonArraySpreadMessage<operand>;\ntype writeNonArraySpreadMessage<operand> = `Spread element must be an array${operand extends string ? ` (was ${operand})` : \"\"}`;\ndeclare const multipleVariadicMesage = \"A tuple may have at most one variadic element\";\ntype multipleVariadicMessage = typeof multipleVariadicMesage;\ndeclare const optionalOrDefaultableAfterVariadicMessage = \"An optional element may not follow a variadic element\";\ntype optionalOrDefaultableAfterVariadicMessage = typeof optionalOrDefaultableAfterVariadicMessage;\ndeclare const spreadOptionalMessage = \"A spread element cannot be optional\";\ntype spreadOptionalMessage = typeof spreadOptionalMessage;\ndeclare const spreadDefaultableMessage = \"A spread element cannot have a default\";\ntype spreadDefaultableMessage = typeof spreadDefaultableMessage;\ndeclare const defaultablePostOptionalMessage = \"A defaultable element may not follow an optional element without a default\";\ntype defaultablePostOptionalMessage = typeof defaultablePostOptionalMessage;\n\n/** @ts-ignore cast variance */\ninterface Type$6<out t extends object = object, $ = {}> extends Type$1<t, $> {\n    readonly(): t extends array ? Type$5<{\n        readonly [i in keyof t]: t[i];\n    }, $> : Type$6<{\n        readonly [k in keyof t]: t[k];\n    }, $>;\n    keyof(): instantiateType<arkKeyOf<t>, $>;\n    /**\n     * Get the `Type` of a property of this `Type<object>`.\n     * @example type({ foo: \"string\" }).get(\"foo\") // Type<string>\n     */\n    get<const k1 extends arkIndexableOf<t>, r = instantiateType<arkGet<t, k1>, $>>(k1: k1 | type.cast<k1>): r extends infer _ ? _ : never;\n    get<const k1 extends arkIndexableOf<t>, const k2 extends arkIndexableOf<arkGet<t, k1>>, r = instantiateType<arkGet<arkGet<t, k1>, k2>, $>>(k1: k1 | type.cast<k1>, k2: k2 | type.cast<k2>): r extends infer _ ? _ : never;\n    get<const k1 extends arkIndexableOf<t>, const k2 extends arkIndexableOf<arkGet<t, k1>>, const k3 extends arkIndexableOf<arkGet<arkGet<t, k1>, k2>>, r = instantiateType<arkGet<arkGet<arkGet<t, k1>, k2>, k3>, $>>(k1: k1 | type.cast<k1>, k2: k2 | type.cast<k2>, k3: k3 | type.cast<k3>): r extends infer _ ? _ : never;\n    /**\n     * Create a copy of this `Type` with only the specified properties.\n     * @example type({ foo: \"string\", bar: \"number\" }).pick(\"foo\") // Type<{ foo: string }>\n     */\n    pick<const key extends arkKeyOf<t> = never>(...keys: (key | type.cast<key>)[]): Type$6<{\n        [k in keyof t as Extract<toArkKey<t, k>, key>]: t[k];\n    }, $>;\n    /**\n     * Create a copy of this `Type` with all properties except the specified ones.\n     * @example type({ foo: \"string\", bar: \"number\" }).omit(\"foo\") // Type<{ bar: number }>\n     */\n    omit<const key extends arkKeyOf<t> = never>(...keys: (key | type.cast<key>)[]): Type$6<{\n        [k in keyof t as Exclude<toArkKey<t, k>, key>]: t[k];\n    }, $>;\n    /**\n     * Merge another `Type` definition, overriding properties of this `Type` with the duplicate keys.\n     * @example type({ a: \"1\", b: \"2\" }).merge({ b: \"3\", c: \"4\" }) // Type<{ a: 1, b: 3, c: 4 }>\n     */\n    merge<const def, inferredDef = type.infer<def, $>, r = Type$6<merge<t, inferredDef>, $>>(def: type.validate<def, $> & (inferredDef extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredDef]>)): r extends infer _ ? _ : never;\n    /**\n     * Create a copy of this `Type` with all properties required.\n     * @example const T = type({ \"foo?\"\": \"string\" }).required() // Type<{ foo: string }>\n     */\n    required(): Type$6<{\n        [k in keyof t]-?: t[k];\n    }, $>;\n    /**\n     * Create a copy of this `Type` with all properties optional.\n     * @example: const T = type({ foo: \"string\" }).optional() // Type<{ foo?: string }>\n     */\n    partial(): Type$6<{\n        [k in keyof t]?: t[k];\n    }, $>;\n    map<transformed extends listable<MappedTypeProp>, r = Type$6<constructMapped<t, transformed>, $>>(flatMapEntry: (entry: typePropOf<t, $>) => transformed): r extends infer _ ? _ : never;\n    /**\n     * List of property info of this `Type<object>`.\n     * @example type({ foo: \"string = \"\" }).props // [{ kind: \"required\", key: \"foo\", value: Type<string>, default: \"\" }]\n     */\n    props: array<typePropOf<t, $>>;\n}\ntype typePropOf<o, $> = keyof o extends infer k ? k extends keyof o ? typeProp<o, k, $> : never : never;\ntype typeProp<o, k extends keyof o, $, t = o[k] & ({} | null)> = t extends Default<infer t, infer defaultValue> ? DefaultedTypeProp<k & Key, t, defaultValue, $> : BaseTypeProp<k extends optionalKeyOf<o> ? \"optional\" : \"required\", k & Key, t, $>;\ninterface BaseTypeProp<kind extends Prop.Kind = Prop.Kind, k extends Key = Key, \n/** @ts-ignore cast variance */\nout v = unknown, $ = {}> {\n    kind: kind;\n    key: k;\n    value: instantiateType<v, $>;\n    meta: ArkEnv.meta;\n    toJSON: () => JsonStructure;\n}\ninterface DefaultedTypeProp<k extends Key = Key, v = unknown, defaultValue = v, $ = {}> extends BaseTypeProp<\"optional\", k, v, $> {\n    default: defaultValue;\n}\ntype MappedTypeProp<k extends Key = Key, v = unknown> = BaseMappedTypeProp<k, v> | OptionalMappedTypeProp<k, v>;\ntype BaseMappedTypeProp<k extends Key, v> = merge<BaseMappedPropInner, {\n    key: k;\n    value: type.cast<v>;\n}>;\ntype OptionalMappedTypeProp<k extends Key, v> = merge<OptionalMappedPropInner, {\n    key: k;\n    value: type.cast<v>;\n    default?: v;\n}>;\ntype constructMapped<t, transformed extends listable<MappedTypeProp>> = show<intersectUnion<fromTypeProps<t, transformed extends array ? transformed : [transformed]>>>;\ntype fromTypeProps<t, props extends array<MappedTypeProp>> = show<{\n    [prop in props[number] as Extract<applyHomomorphicOptionality<t, prop>, {\n        kind: \"required\";\n    }>[\"key\"]]: prop[\"value\"][inferred];\n} & {\n    [prop in props[number] as Extract<applyHomomorphicOptionality<t, prop>, {\n        kind: \"optional\";\n        default?: never;\n    }>[\"key\"]]?: prop[\"value\"][inferred];\n} & {\n    [prop in props[number] as Extract<applyHomomorphicOptionality<t, prop>, {\n        kind: \"optional\";\n        default: unknown;\n    }>[\"key\"]]: withDefault<prop[\"value\"][inferred], prop[\"default\" & keyof prop]>;\n}>;\ntype NonObjectMergeErrorMessage = \"Merged type must be an object\";\ntype applyHomomorphicOptionality<t, prop extends MappedTypeProp> = prop[\"kind\"] extends string ? prop : prop & {\n    kind: prop[\"key\"] extends optionalKeyOf<t> ? \"optional\" : \"required\";\n};\n\ninterface Type$5<\n/** @ts-ignore cast variance */\nout t extends readonly unknown[] = readonly unknown[], $ = {}> extends Type$6<t, $> {\n    atLeastLength(schema: InclusiveNumericRangeSchema): this;\n    atMostLength(schema: InclusiveNumericRangeSchema): this;\n    moreThanLength(schema: ExclusiveNumericRangeSchema): this;\n    lessThanLength(schema: ExclusiveNumericRangeSchema): this;\n    exactlyLength(schema: ExactLength.Schema): this;\n}\n\n/** @ts-ignore cast variance */\ninterface Type$4<out t extends globalThis.Date = globalThis.Date, $ = {}> extends Type$6<t, $> {\n    atOrAfter(schema: InclusiveDateRangeSchema): this;\n    atOrBefore(schema: InclusiveDateRangeSchema): this;\n    laterThan(schema: ExclusiveDateRangeSchema): this;\n    earlierThan(schema: ExclusiveDateRangeSchema): this;\n}\n\n/** @ts-ignore cast variance */\ninterface Type$3<out t extends number = number, $ = {}> extends Type$1<t, $> {\n    divisibleBy(schema: Divisor.Schema): this;\n    atLeast(schema: InclusiveNumericRangeSchema): this;\n    atMost(schema: InclusiveNumericRangeSchema): this;\n    moreThan(schema: ExclusiveNumericRangeSchema): this;\n    lessThan(schema: ExclusiveNumericRangeSchema): this;\n}\n\n/** @ts-ignore cast variance */\ninterface Type$2<out t extends string = string, $ = {}> extends Type$1<t, $> {\n    matching<const schema extends Pattern.Schema>(schema: schema): schema extends string ? Type$2<regex.infer<schema>, $> : schema extends {\n        rule: infer pattern extends string;\n    } ? Type$2<regex.infer<pattern>, $> : this;\n    atLeastLength(schema: InclusiveNumericRangeSchema): this;\n    atMostLength(schema: InclusiveNumericRangeSchema): this;\n    moreThanLength(schema: ExclusiveNumericRangeSchema): this;\n    lessThanLength(schema: ExclusiveNumericRangeSchema): this;\n    exactlyLength(schema: ExactLength.Schema): this;\n}\n\ntype instantiateType<t, $> = [\n    t\n] extends [anyOrNever] ? Type$1<t, $> : [t] extends [object] ? [\n    t\n] extends [array] ? Type$5<t, $> : [t] extends [Date] ? Type$4<t, $> : Type$6<t, $> : [t] extends [string] ? Type$2<t, $> : [t] extends [number] ? Type$3<t, $> : Type$1<t, $>;\n\ntype NaryUnionParser<$> = {\n    (): Type<never, $>;\n    <const a, r = Type<type.infer<a, $>, $>>(a: type.validate<a, $>): r extends infer _ ? _ : never;\n    <const a, const b, r = Type<type.infer<a, $> | type.infer<b, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $> | type.infer<h, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $> | type.infer<h, $> | type.infer<i, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $> | type.infer<h, $> | type.infer<i, $> | type.infer<j, $>>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $> | type.infer<h, $> | type.infer<i, $> | type.infer<j, $> | type.infer<k, $>>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $> | type.infer<h, $> | type.infer<i, $> | type.infer<j, $> | type.infer<k, $> | type.infer<l, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $> | type.infer<h, $> | type.infer<i, $> | type.infer<j, $> | type.infer<k, $> | type.infer<l, $> | type.infer<m, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>, m: type.validate<m, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $> | type.infer<h, $> | type.infer<i, $> | type.infer<j, $> | type.infer<k, $> | type.infer<l, $> | type.infer<m, $> | type.infer<n, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>, m: type.validate<m, $>, n: type.validate<n, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, const o, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $> | type.infer<h, $> | type.infer<i, $> | type.infer<j, $> | type.infer<k, $> | type.infer<l, $> | type.infer<m, $> | type.infer<n, $> | type.infer<o, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>, m: type.validate<m, $>, n: type.validate<n, $>, o: type.validate<o, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, const o, const p, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $> | type.infer<h, $> | type.infer<i, $> | type.infer<j, $> | type.infer<k, $> | type.infer<l, $> | type.infer<m, $> | type.infer<n, $> | type.infer<o, $> | type.infer<p, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>, m: type.validate<m, $>, n: type.validate<n, $>, o: type.validate<o, $>, p: type.validate<p, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, const o, const p, const q, r = Type<type.infer<a, $> | type.infer<b, $> | type.infer<c, $> | type.infer<d, $> | type.infer<e, $> | type.infer<f, $> | type.infer<g, $> | type.infer<h, $> | type.infer<i, $> | type.infer<j, $> | type.infer<k, $> | type.infer<l, $> | type.infer<m, $> | type.infer<n, $> | type.infer<o, $> | type.infer<p, $> | type.infer<q, $>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>, m: type.validate<m, $>, n: type.validate<n, $>, o: type.validate<o, $>, p: type.validate<p, $>, q: type.validate<q, $>): r extends infer _ ? _ : never;\n    <const defs extends readonly unknown[], r = Type<type.infer<defs[number], $>, $>>(...defs: {\n        [i in keyof defs]: type.validate<defs[i], $>;\n    }): r extends infer _ ? _ : never;\n};\ntype NaryIntersectionParser<$> = {\n    (): Type<unknown, $>;\n    <const a, r = Type<type.infer<a, $>, $>>(a: type.validate<a, $>): r extends infer _ ? _ : never;\n    <const a, const b, r = Type<inferIntersection<type.infer<a, $>, type.infer<b, $>>, $>>(a: type.validate<a, $>, b: type.validate<b, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>,\n        type.infer<h, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>,\n        type.infer<h, $>,\n        type.infer<i, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>,\n        type.infer<h, $>,\n        type.infer<i, $>,\n        type.infer<j, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>,\n        type.infer<h, $>,\n        type.infer<i, $>,\n        type.infer<j, $>,\n        type.infer<k, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>,\n        type.infer<h, $>,\n        type.infer<i, $>,\n        type.infer<j, $>,\n        type.infer<k, $>,\n        type.infer<l, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>,\n        type.infer<h, $>,\n        type.infer<i, $>,\n        type.infer<j, $>,\n        type.infer<k, $>,\n        type.infer<l, $>,\n        type.infer<m, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>, m: type.validate<m, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>,\n        type.infer<h, $>,\n        type.infer<i, $>,\n        type.infer<j, $>,\n        type.infer<k, $>,\n        type.infer<l, $>,\n        type.infer<m, $>,\n        type.infer<n, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>, m: type.validate<m, $>, n: type.validate<n, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, const o, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>,\n        type.infer<h, $>,\n        type.infer<i, $>,\n        type.infer<j, $>,\n        type.infer<k, $>,\n        type.infer<l, $>,\n        type.infer<m, $>,\n        type.infer<n, $>,\n        type.infer<o, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>, m: type.validate<m, $>, n: type.validate<n, $>, o: type.validate<o, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, const o, const p, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>,\n        type.infer<h, $>,\n        type.infer<i, $>,\n        type.infer<j, $>,\n        type.infer<k, $>,\n        type.infer<l, $>,\n        type.infer<m, $>,\n        type.infer<n, $>,\n        type.infer<o, $>,\n        type.infer<p, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>, m: type.validate<m, $>, n: type.validate<n, $>, o: type.validate<o, $>, p: type.validate<p, $>): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, const o, const p, const q, r = Type<inferNaryIntersection<[\n        type.infer<a, $>,\n        type.infer<b, $>,\n        type.infer<c, $>,\n        type.infer<d, $>,\n        type.infer<e, $>,\n        type.infer<f, $>,\n        type.infer<g, $>,\n        type.infer<h, $>,\n        type.infer<i, $>,\n        type.infer<j, $>,\n        type.infer<k, $>,\n        type.infer<l, $>,\n        type.infer<m, $>,\n        type.infer<n, $>,\n        type.infer<o, $>,\n        type.infer<p, $>,\n        type.infer<q, $>\n    ]>, $>>(a: type.validate<a, $>, b: type.validate<b, $>, c: type.validate<c, $>, d: type.validate<d, $>, e: type.validate<e, $>, f: type.validate<f, $>, g: type.validate<g, $>, h: type.validate<h, $>, i: type.validate<i, $>, j: type.validate<j, $>, k: type.validate<k, $>, l: type.validate<l, $>, m: type.validate<m, $>, n: type.validate<n, $>, o: type.validate<o, $>, p: type.validate<p, $>, q: type.validate<q, $>): r extends infer _ ? _ : never;\n    <const defs extends readonly unknown[], r = Type<inferNaryIntersection<{\n        [i in keyof defs]: type.infer<defs[i], $>;\n    }>, $>>(...defs: {\n        [i in keyof defs]: type.validate<defs[i], $>;\n    }): r extends infer _ ? _ : never;\n};\ntype NaryMergeParser<$> = {\n    (): Type<object, $>;\n    <const a, inferredA = type.infer<a, $>, r = Type<inferredA, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>)): r extends infer _ ? _ : never;\n    <const a, const b, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, r = Type<merge<inferredA, inferredB>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, r = Type<inferNaryMerge<[inferredA, inferredB, inferredC]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, r = Type<inferNaryMerge<[inferredA, inferredB, inferredC, inferredD]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, r = Type<inferNaryMerge<[inferredA, inferredB, inferredC, inferredD, inferredE]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, inferredH = type.infer<h, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG,\n        inferredH\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>), h: type.validate<h, $> & (inferredH extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredH]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, inferredH = type.infer<h, $>, inferredI = type.infer<i, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG,\n        inferredH,\n        inferredI\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>), h: type.validate<h, $> & (inferredH extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredH]>), i: type.validate<i, $> & (inferredI extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredI]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, inferredH = type.infer<h, $>, inferredI = type.infer<i, $>, inferredJ = type.infer<j, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG,\n        inferredH,\n        inferredI,\n        inferredJ\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>), h: type.validate<h, $> & (inferredH extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredH]>), i: type.validate<i, $> & (inferredI extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredI]>), j: type.validate<j, $> & (inferredJ extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredJ]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, inferredH = type.infer<h, $>, inferredI = type.infer<i, $>, inferredJ = type.infer<j, $>, inferredK = type.infer<k, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG,\n        inferredH,\n        inferredI,\n        inferredJ,\n        inferredK\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>), h: type.validate<h, $> & (inferredH extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredH]>), i: type.validate<i, $> & (inferredI extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredI]>), j: type.validate<j, $> & (inferredJ extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredJ]>), k: type.validate<k, $> & (inferredK extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredK]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, inferredH = type.infer<h, $>, inferredI = type.infer<i, $>, inferredJ = type.infer<j, $>, inferredK = type.infer<k, $>, inferredL = type.infer<l, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG,\n        inferredH,\n        inferredI,\n        inferredJ,\n        inferredK,\n        inferredL\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>), h: type.validate<h, $> & (inferredH extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredH]>), i: type.validate<i, $> & (inferredI extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredI]>), j: type.validate<j, $> & (inferredJ extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredJ]>), k: type.validate<k, $> & (inferredK extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredK]>), l: type.validate<l, $> & (inferredL extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredL]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, inferredH = type.infer<h, $>, inferredI = type.infer<i, $>, inferredJ = type.infer<j, $>, inferredK = type.infer<k, $>, inferredL = type.infer<l, $>, inferredM = type.infer<m, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG,\n        inferredH,\n        inferredI,\n        inferredJ,\n        inferredK,\n        inferredL,\n        inferredM\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>), h: type.validate<h, $> & (inferredH extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredH]>), i: type.validate<i, $> & (inferredI extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredI]>), j: type.validate<j, $> & (inferredJ extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredJ]>), k: type.validate<k, $> & (inferredK extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredK]>), l: type.validate<l, $> & (inferredL extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredL]>), m: type.validate<m, $> & (inferredM extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredM]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, inferredH = type.infer<h, $>, inferredI = type.infer<i, $>, inferredJ = type.infer<j, $>, inferredK = type.infer<k, $>, inferredL = type.infer<l, $>, inferredM = type.infer<m, $>, inferredN = type.infer<n, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG,\n        inferredH,\n        inferredI,\n        inferredJ,\n        inferredK,\n        inferredL,\n        inferredM,\n        inferredN\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>), h: type.validate<h, $> & (inferredH extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredH]>), i: type.validate<i, $> & (inferredI extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredI]>), j: type.validate<j, $> & (inferredJ extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredJ]>), k: type.validate<k, $> & (inferredK extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredK]>), l: type.validate<l, $> & (inferredL extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredL]>), m: type.validate<m, $> & (inferredM extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredM]>), n: type.validate<n, $> & (inferredN extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredN]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, const o, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, inferredH = type.infer<h, $>, inferredI = type.infer<i, $>, inferredJ = type.infer<j, $>, inferredK = type.infer<k, $>, inferredL = type.infer<l, $>, inferredM = type.infer<m, $>, inferredN = type.infer<n, $>, inferredO = type.infer<o, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG,\n        inferredH,\n        inferredI,\n        inferredJ,\n        inferredK,\n        inferredL,\n        inferredM,\n        inferredN,\n        inferredO\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>), h: type.validate<h, $> & (inferredH extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredH]>), i: type.validate<i, $> & (inferredI extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredI]>), j: type.validate<j, $> & (inferredJ extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredJ]>), k: type.validate<k, $> & (inferredK extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredK]>), l: type.validate<l, $> & (inferredL extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredL]>), m: type.validate<m, $> & (inferredM extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredM]>), n: type.validate<n, $> & (inferredN extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredN]>), o: type.validate<o, $> & (inferredO extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredO]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, const o, const p, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, inferredH = type.infer<h, $>, inferredI = type.infer<i, $>, inferredJ = type.infer<j, $>, inferredK = type.infer<k, $>, inferredL = type.infer<l, $>, inferredM = type.infer<m, $>, inferredN = type.infer<n, $>, inferredO = type.infer<o, $>, inferredP = type.infer<p, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG,\n        inferredH,\n        inferredI,\n        inferredJ,\n        inferredK,\n        inferredL,\n        inferredM,\n        inferredN,\n        inferredO,\n        inferredP\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>), h: type.validate<h, $> & (inferredH extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredH]>), i: type.validate<i, $> & (inferredI extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredI]>), j: type.validate<j, $> & (inferredJ extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredJ]>), k: type.validate<k, $> & (inferredK extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredK]>), l: type.validate<l, $> & (inferredL extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredL]>), m: type.validate<m, $> & (inferredM extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredM]>), n: type.validate<n, $> & (inferredN extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredN]>), o: type.validate<o, $> & (inferredO extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredO]>), p: type.validate<p, $> & (inferredP extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredP]>)): r extends infer _ ? _ : never;\n    <const a, const b, const c, const d, const e, const f, const g, const h, const i, const j, const k, const l, const m, const n, const o, const p, const q, inferredA = type.infer<a, $>, inferredB = type.infer<b, $>, inferredC = type.infer<c, $>, inferredD = type.infer<d, $>, inferredE = type.infer<e, $>, inferredF = type.infer<f, $>, inferredG = type.infer<g, $>, inferredH = type.infer<h, $>, inferredI = type.infer<i, $>, inferredJ = type.infer<j, $>, inferredK = type.infer<k, $>, inferredL = type.infer<l, $>, inferredM = type.infer<m, $>, inferredN = type.infer<n, $>, inferredO = type.infer<o, $>, inferredP = type.infer<p, $>, inferredQ = type.infer<q, $>, r = Type<inferNaryMerge<[\n        inferredA,\n        inferredB,\n        inferredC,\n        inferredD,\n        inferredE,\n        inferredF,\n        inferredG,\n        inferredH,\n        inferredI,\n        inferredJ,\n        inferredK,\n        inferredL,\n        inferredM,\n        inferredN,\n        inferredO,\n        inferredP,\n        inferredQ\n    ]>, $>>(a: type.validate<a, $> & (inferredA extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredA]>), b: type.validate<b, $> & (inferredB extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredB]>), c: type.validate<c, $> & (inferredC extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredC]>), d: type.validate<d, $> & (inferredD extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredD]>), e: type.validate<e, $> & (inferredE extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredE]>), f: type.validate<f, $> & (inferredF extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredF]>), g: type.validate<g, $> & (inferredG extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredG]>), h: type.validate<h, $> & (inferredH extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredH]>), i: type.validate<i, $> & (inferredI extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredI]>), j: type.validate<j, $> & (inferredJ extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredJ]>), k: type.validate<k, $> & (inferredK extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredK]>), l: type.validate<l, $> & (inferredL extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredL]>), m: type.validate<m, $> & (inferredM extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredM]>), n: type.validate<n, $> & (inferredN extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredN]>), o: type.validate<o, $> & (inferredO extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredO]>), p: type.validate<p, $> & (inferredP extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredP]>), q: type.validate<q, $> & (inferredQ extends object ? unknown : ErrorType<[NonObjectMergeErrorMessage, actual: inferredQ]>)): r extends infer _ ? _ : never;\n    <const defs extends readonly unknown[], r = Type<inferNaryMerge<{\n        [i in keyof defs]: type.infer<defs[i], $>;\n    }>, $>>(...defs: {\n        [i in keyof defs]: type.validate<defs[i], $> & (type.infer<defs[i], $> extends object ? unknown : ErrorType<[\n            NonObjectMergeErrorMessage,\n            actual: type.infer<defs[i], $>\n        ]>);\n    }): r extends infer _ ? _ : never;\n};\ntype NaryPipeParser<$, initial = unknown> = {\n    (): Type<initial, $>;\n    <a extends Morph<distill.Out<initial>>, r = instantiateType<inferMorph<initial, a>, $>>(a: a): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b]>, $>>(a: a, b: b): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c]>, $>>(a: a, b: b, c: c): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d]>, $>>(a: a, b: b, c: c, d: d): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d, e]>, $>>(a: a, b: b, c: c, d: d, e: e): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d, e, f]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d, e, f, g]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, h extends Morph<inferMorphOut<g>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d, e, f, g, h]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, h extends Morph<inferMorphOut<g>>, i extends Morph<inferMorphOut<h>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d, e, f, g, h, i]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h, i: i): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, h extends Morph<inferMorphOut<g>>, i extends Morph<inferMorphOut<h>>, j extends Morph<inferMorphOut<i>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d, e, f, g, h, i, j]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h, i: i, j: j): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, h extends Morph<inferMorphOut<g>>, i extends Morph<inferMorphOut<h>>, j extends Morph<inferMorphOut<i>>, k extends Morph<inferMorphOut<j>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d, e, f, g, h, i, j, k]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h, i: i, j: j, k: k): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, h extends Morph<inferMorphOut<g>>, i extends Morph<inferMorphOut<h>>, j extends Morph<inferMorphOut<i>>, k extends Morph<inferMorphOut<j>>, l extends Morph<inferMorphOut<k>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d, e, f, g, h, i, j, k, l]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h, i: i, j: j, k: k, l: l): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, h extends Morph<inferMorphOut<g>>, i extends Morph<inferMorphOut<h>>, j extends Morph<inferMorphOut<i>>, k extends Morph<inferMorphOut<j>>, l extends Morph<inferMorphOut<k>>, m extends Morph<inferMorphOut<l>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d, e, f, g, h, i, j, k, l, m]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h, i: i, j: j, k: k, l: l, m: m): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, h extends Morph<inferMorphOut<g>>, i extends Morph<inferMorphOut<h>>, j extends Morph<inferMorphOut<i>>, k extends Morph<inferMorphOut<j>>, l extends Morph<inferMorphOut<k>>, m extends Morph<inferMorphOut<l>>, n extends Morph<inferMorphOut<m>>, r = instantiateType<inferNaryPipe<[Type<initial>, a, b, c, d, e, f, g, h, i, j, k, l, m, n]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h, i: i, j: j, k: k, l: l, m: m, n: n): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, h extends Morph<inferMorphOut<g>>, i extends Morph<inferMorphOut<h>>, j extends Morph<inferMorphOut<i>>, k extends Morph<inferMorphOut<j>>, l extends Morph<inferMorphOut<k>>, m extends Morph<inferMorphOut<l>>, n extends Morph<inferMorphOut<m>>, o extends Morph<inferMorphOut<n>>, r = instantiateType<inferNaryPipe<[\n        Type<initial>,\n        a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n,\n        o\n    ]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h, i: i, j: j, k: k, l: l, m: m, n: n, o: o): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, h extends Morph<inferMorphOut<g>>, i extends Morph<inferMorphOut<h>>, j extends Morph<inferMorphOut<i>>, k extends Morph<inferMorphOut<j>>, l extends Morph<inferMorphOut<k>>, m extends Morph<inferMorphOut<l>>, n extends Morph<inferMorphOut<m>>, o extends Morph<inferMorphOut<n>>, p extends Morph<inferMorphOut<o>>, r = instantiateType<inferNaryPipe<[\n        Type<initial>,\n        a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n,\n        o,\n        p\n    ]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h, i: i, j: j, k: k, l: l, m: m, n: n, o: o, p: p): r extends infer _ ? _ : never;\n    <a extends Morph<distill.Out<initial>>, b extends Morph<inferMorphOut<a>>, c extends Morph<inferMorphOut<b>>, d extends Morph<inferMorphOut<c>>, e extends Morph<inferMorphOut<d>>, f extends Morph<inferMorphOut<e>>, g extends Morph<inferMorphOut<f>>, h extends Morph<inferMorphOut<g>>, i extends Morph<inferMorphOut<h>>, j extends Morph<inferMorphOut<i>>, k extends Morph<inferMorphOut<j>>, l extends Morph<inferMorphOut<k>>, m extends Morph<inferMorphOut<l>>, n extends Morph<inferMorphOut<m>>, o extends Morph<inferMorphOut<n>>, p extends Morph<inferMorphOut<o>>, q extends Morph<inferMorphOut<p>>, r = instantiateType<inferNaryPipe<[\n        Type<initial>,\n        a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n,\n        o,\n        p,\n        q\n    ]>, $>>(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h, i: i, j: j, k: k, l: l, m: m, n: n, o: o, p: p, q: q): r extends infer _ ? _ : never;\n    <const morphs extends readonly Morph[], r = Type<inferNaryPipe<morphs>, $>>(...defs: morphs): r extends infer _ ? _ : never;\n};\n\n/** @ts-ignore cast variance */\ninterface Inferred<out t = unknown, $ = {}> {\n    internal: BaseRoot;\n    [inferred]: t;\n    /**\n     * precompiled JS used to optimize validation\n     *\n     *  will be `undefined` in [jitless](https://arktype.io/docs/configuration#jitless) mode\n     */\n    precompilation: string | undefined;\n    /**\n     * generic parameter representing this Type\n     *\n     * @typeonly\n     *\n     *  May contain types representing morphs or default values that would\n     * be inaccurate if used directly for runtime values. In those cases,\n     * you should use {@link infer} or {@link inferIn} on this object instead.\n     */\n    t: t;\n    /**\n     * #### {@link Scope} in which chained methods are parsed\n     */\n    $: Scope<$>;\n    /**\n     * #### type of output this returns\n     *\n     * @typeonly\n     *\n     * @example\n     * const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\n     * type ParsedNumber = typeof parseNumber.infer // number\n     */\n    infer: this[\"inferOut\"];\n    /**\n     * type of output this returns\n     *\n     *  alias of {@link infer}\n     * @typeonly\n     *\n     *\n     * @example\n     * const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\n     * type ParsedNumber = typeof parseNumber.infer // number\n     */\n    inferOut: distill.Out<t>;\n    /**\n     * type of output that can be introspected at runtime (e.g. via {@link out})\n     *\n     *  If your Type contains morphs, they will be inferred as `unknown` unless\n     * they are an ArkType keyword or have an explicitly defined output validator.\n     *\n     * @typeonly\n     *\n     * @example\n     * const Unmorphed = type(\"string\")\n     * // with no morphs, we can introspect the input and output as a single Type\n     * type UnmorphedOut = typeof Unmorphed.inferIntrospectableOut // string\n     *\n     * const Morphed = type(\"string\").pipe(s => s.length)\n     * // with a standard user-defined morph, TypeScript can infer a\n     * // return type from your function, but we have no way to\n     * // know the shape at runtime\n     * type MorphOut = typeof Morphed.inferIntrospectableOut  // unknown\n     *\n     * const Validated = type(\"string\").pipe(s => s.length).to(\"number\")\n     * // morphs with validated output, including all morph keywords, are introspectable\n     * type ValidatedMorphOut = typeof Validated.inferIntrospectableOut\n     */\n    inferIntrospectableOut: distill.introspectable.Out<t>;\n    /**\n     * #### type of input this allows\n     *\n     * @typeonly\n     *\n     * @example\n     * const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\n     * type UnparsedNumber = typeof parseNumber.inferIn // string\n     */\n    inferIn: distill.In<t>;\n    /**\n     * #### internal JSON representation\n     */\n    json: JsonStructure;\n    /**\n     * alias of {@link json} for `JSON.stringify` compatibility\n     */\n    toJSON(): JsonStructure;\n    /**\n     * #### generate a JSON Schema\n     *\n     * @throws {ToJsonSchema.Error} if this cannot be converted to JSON Schema\n     */\n    toJsonSchema(options?: ToJsonSchema.Options): JsonSchema;\n    /**\n     * #### metadata like custom descriptions and error messages\n     *\n     *  type {@link https://arktype.io/docs/configuration#custom | can be customized} for your project\n     */\n    meta: ArkAmbient.meta;\n    /**\n     * #### human-readable English description\n     *\n     *  works best for primitive values\n     *\n     * @example\n     * const N = type(\"0 < number <= 100\")\n     * console.log(N.description) // positive and at most 100\n     */\n    description: string;\n    /**\n     * #### syntax string similar to native TypeScript\n     *\n     *  works well for both primitives and structures\n     *\n     * @example\n     * const Loc = type({ coords: [\"number\", \"number\"] })\n     * console.log(Loc.expression) // { coords: [number, number] }\n     */\n    expression: string;\n    /**\n     * #### validate and return transformed data or throw\n     *\n     *  sugar to avoid checking for {@link type.errors} if they are unrecoverable\n     *\n     * @example\n     * const CriticalPayload = type({\n     *     superImportantValue: \"string\"\n     * })\n     * // throws TraversalError: superImportantValue must be a string (was missing)\n     * const data = CriticalPayload.assert({ irrelevantValue: \"whoops\" })\n     * console.log(data.superImportantValue) // valid output can be accessed directly\n     *\n     * @throws {TraversalError}\n     */\n    assert(data: unknown): this[\"infer\"];\n    /**\n     * #### check input without applying morphs\n     *\n     *  good for stuff like filtering that doesn't benefit from detailed errors\n     *\n     * @example\n     * const Numeric = type(\"number | bigint\")\n     * // [0, 2n]\n     * const numerics = [0, \"one\", 2n].filter(Numeric.allows)\n     */\n    allows(data: unknown): data is this[\"inferIn\"];\n    /**\n     * #### add metadata to shallow references\n     *\n     *  does not affect error messages within properties of an object\n     *\n     * @example\n     * const NotOdd = type(\"number % 2\").configure({ description: \"not odd\" })\n     * // all constraints at the root are affected\n     * const odd = NotOdd(3) // must be not odd (was 3)\n     * const nonNumber = NotOdd(\"two\") // must be not odd (was \"two\")\n     *\n     * const NotOddBox = type({\n     *    // we should have referenced notOdd or added meta here\n     *    notOdd: \"number % 2\",\n     * // but instead chained from the root object\n     * }).configure({ description: \"not odd\" })\n     * // error message at path notOdd is not affected\n     * const oddProp = NotOddBox({ notOdd: 3 }) // notOdd must be even (was 3)\n     * // error message at root is affected, leading to a misleading description\n     * const nonObject = NotOddBox(null) // must be not odd (was null)\n     */\n    configure: NodeSelector.SelectableFn<TypeMeta.MappableInput, this>;\n    /**\n     * #### add description to shallow references\n     *\n     *  equivalent to `.configure({ description })` (see {@link configure})\n     *  does not affect error messages within properties of an object\n     *\n     * @example\n     * const AToZ = type(/^a.*z$/).describe(\"a string like 'a...z'\")\n     * const good = AToZ(\"alcatraz\") // \"alcatraz\"\n     * // ArkErrors: must be a string like 'a...z' (was \"albatross\")\n     * const badPattern = AToZ(\"albatross\")\n     */\n    describe: NodeSelector.SelectableFn<string, this>;\n    /**\n     * #### apply undeclared key behavior\n     *\n     * {@inheritDoc UndeclaredKeyBehavior}\n     */\n    onUndeclaredKey(behavior: UndeclaredKeyBehavior): this;\n    /**\n     * #### deeply apply undeclared key behavior\n     *\n     * {@inheritDoc UndeclaredKeyBehavior}\n     **/\n    onDeepUndeclaredKey(behavior: UndeclaredKeyBehavior): this;\n    /**\n     * #### alias for {@link assert} with typed input\n     *\n     * @example\n     * const T = type({ foo: \"string\" });\n     * // TypeScript: foo must be a string (was 5)\n     * const data = T.from({ foo: 5 });\n     */\n    from(literal: this[\"inferIn\"]): this[\"infer\"];\n    /**\n     * #### deeply extract inputs\n     *\n     *  will never include morphs\n     *  good for generating JSON Schema or other non-transforming formats\n     *\n     * @example\n     * const User = type({\n     *    age: \"string.numeric.parse\"\n     * })\n     * // { age: 25 } (age parsed to a number)\n     * const out = User({ age: \"25\" })\n     * // { age: \"25\" } (age is still a string)\n     * const inOut = User.in({ age: \"25\" })\n     */\n    get in(): instantiateType<this[\"inferIn\"], $>;\n    /**\n     * #### deeply extract outputs\n     *\n     *  will never include morphs\n     *  if your type includes morphs, their output will likely be unknown unless they\n     * were defined with an explicit output validator via `.to(outputDef)` or `.pipe(morph, outputType)`\n     *\n     * @example\n     * const join = type(\"string[]\").pipe(a => a.join(\",\"))\n     *\n     * const T = type({\n     *    // all keywords have introspectable output\n     *    keyword: \"string.numeric.parse\",\n     *    // TypeScript knows this returns a string, but we can't introspect that at runtime\n     *    unvalidated: join,\n     *    // if needed, it can be made introspectable with an output validator\n     *    validated: join.to(\"string\")\n     * })\n     *\n     * // Type<{ keyword: number; unvalidated: unknown; validated: string }>\n     * const baseOut = base.out\n     */\n    get out(): instantiateType<this[\"inferIntrospectableOut\"], $>;\n    /**\n     * #### add a compile-time brand to output\n     *\n     * @typenoop\n     *\n     * @example\n     * const Palindrome = type(\"string\")\n     *     .narrow(s => s === [...s].reverse().join(\"\"))\n     *     .brand(\"palindrome\")\n     * // Brand<string, \"palindrome\">\n     * const out = Palindrome.assert(\"racecar\")\n     */\n    brand<const name extends string, r = instantiateType<type.brand<t, name>, $>>(name: name): r extends infer _ ? _ : never;\n    /**\n     * #### an array of this\n     *\n     * @example\n     * // Type<{ rebmun: number }[]>\n     * const T = type({ rebmun: \"number\" }).array();\n     */\n    array(): Type$5<t[], $>;\n    /**\n     * #### {@link https://arktype.io/docs/objects#properties-optional | optional definition}\n     *\n     * @chainedDefinition\n     *\n     * @example\n     * const Prop = type({ foo: \"number\" })\n     * // Type<{ bar?: { foo: number } }>\n     * const Obj = type({ bar: Prop.optional() })\n     */\n    optional(): [this, \"?\"];\n    /**\n     * #### {@link https://arktype.io/docs/objects#properties-defaultable | defaultable definition}\n     *\n     *  object defaults can be returned from a function\n     *  throws if the default value is not allowed\n     * @chainedDefinition\n     *\n     * @example\n     * // Type<{ count: Default<number, 0> }>\n     * const State = type({ count: type.number.default(0) })\n     * const Prop = type({ nested: \"boolean\" })\n     * const ForObj = type({\n     *     key: Prop.default(() => ({ nested: false }))\n     * })\n     */\n    default<const value extends defaultFor<this[\"inferIn\"]>>(value: value): [this, \"=\", value];\n    /**\n     * #### apply a predicate function to input\n     *\n     *  the behavior of {@link narrow}, this method's output counterpart, is usually more desirable\n     *  most useful for morphs with input types that are re-used externally\n     * @predicateCast\n     *\n     * @example\n     * const stringifyUser = type({ name: \"string\" }).pipe(user => JSON.stringify(user))\n     * const stringifySafe = stringifyUser.filter(user => user.name !== \"Bobby Tables\")\n     * // Type<(In: `${string}Z`) => To<Date>>\n     * const WithPredicate = type(\"string.date.parse\").filter((s): s is `${string}Z` =>\n     *     s.endsWith(\"Z\")\n     * )\n     */\n    filter<narrowed extends this[\"inferIn\"] = never, r = instantiateType<[\n        narrowed\n    ] extends [never] ? t : t extends InferredMorph<never, infer o> ? (In: narrowed) => o : narrowed, $>>(predicate: Predicate.Castable<this[\"inferIn\"], narrowed>): r extends infer _ ? _ : never;\n    /**\n     * #### apply a predicate function to output\n     *\n     *  go-to fallback for validation not composable via built-in types and operators\n     *  runs after all other validators and morphs, if present\n     * @predicateCast\n     *\n     * @example\n     * const Palindrome = type(\"string\").narrow(s => s === [...s].reverse().join(\"\"))\n     *\n     * const PalindromicEmail = type(\"string.date.parse\").narrow((date, ctx) =>\n     *\t\tdate.getFullYear() === 2025 || ctx.mustBe(\"the current year\")\n     * )\n     * // Type<`${string}.tsx`>\n     * const WithPredicate = type(\"string\").narrow((s): s is `${string}.tsx` => /\\.tsx?$/.test(s))\n     */\n    narrow<narrowed extends this[\"infer\"] = never, r = instantiateType<[\n        narrowed\n    ] extends [never] ? t : t extends InferredMorph<infer i, infer o> ? o extends To ? (In: i) => To<narrowed> : (In: i) => Out<narrowed> : narrowed, $>>(predicate: Predicate.Castable<this[\"infer\"], narrowed>): r extends infer _ ? _ : never;\n    /**\n     * #### pipe output through arbitrary transformations or other Types\n     *\n     * @example\n     * const User = type({ name: \"string\" })\n     *\n     * // parse a string and validate that the result as a user\n     * const parseUser = type(\"string\").pipe(s => JSON.parse(s), user)\n     */\n    pipe: ChainedPipeParser<$, t>;\n    /**\n     * #### parse a definition as an output validator\n     *\n     *  `to({ name: \"string\" })` is equivalent to `.pipe(type({ name: \"string\" }))`\n     *\n     * @example\n     * // parse a string and validate that the result as a user\n     * const parseUser = type(\"string\").pipe(s => JSON.parse(s)).to({ name: \"string\" })\n     */\n    to<const def, r = instantiateType<inferPipe<t, type.infer<def, $>>, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * #### query internal node references\n     *\n     * @experimental filters and returns the Type's internal representation from `@ark/schema`\n     *\n     * @example\n     * // [\"blue\", \"red\"]\n     * const values = type(\"'red' | 'blue'\").select(\"unit\").map(u => u.unit)\n     */\n    select: BaseNode[\"select\"];\n}\n/** @ts-ignore cast variance */\ninterface Type$1<out t = unknown, $ = {}> extends Callable<(data: unknown) => distill.Out<t> | ArkEnv.onFail>, Inferred<t, $> {\n    /**\n     * #### cast the way this is inferred\n     *\n     * @typenoop\n     *\n     * @example\n     * // Type<`LEEEEEEEE${string}ROY`>\n     * const Leeroy = type(/^LE{8,}ROY$/).as<`LEEEEEEEE${string}ROY`>()\n     */\n    as<castTo = unset>(...args: validateChainedAsArgs<castTo>): instantiateType<castTo, $>;\n    /**\n     * #### intersect the parsed Type, throwing if the result is unsatisfiable\n     *\n     * @example\n     * // Type<{ foo: number; bar: string }>\n     * const T = type({ foo: \"number\" }).and({ bar: \"string\" })\n     * // ParseError: Intersection at foo of number and string results in an unsatisfiable type\n     * const Bad = type({ foo: \"number\" }).and({ foo: \"string\" })\n     */\n    and<const def, r = instantiateType<inferIntersection<t, type.infer<def, $>>, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * #### union with the parsed Type\n     *\n     *  a union that could apply different morphs to the same data is a ParseError ({@link https://arktype.io/docs/expressions#union-morphs | docs})\n     *\n     * @example\n     * // Type<string | { box: string }>\n     * const T = type(\"string\").or({ box: \"string\" })\n     */\n    or<const def, r = instantiateType<t | type.infer<def, $>, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * #### intersect the parsed Type, returning an introspectable {@link Disjoint} if the result is unsatisfiable\n     *\n     * @example\n     * // Type<{ foo: number; bar: string }>\n     * const T = type({ foo: \"number\" }).intersect({ bar: \"string\" })\n     * const Bad = type(\"number > 10\").intersect(\"number < 5\")\n     * // logs \"Intersection of > 10 and < 5 results in an unsatisfiable type\"\n     * if (Bad instanceof Disjoint) console.log(`${bad.summary}`)\n     */\n    intersect<const def, r = instantiateType<inferIntersection<t, type.infer<def, $>>, $>>(def: type.validate<def, $>): r extends infer _ ? _ | Disjoint : never;\n    /**\n     * #### check if the parsed Type's constraints are identical\n     *\n     *  equal types have identical input and output constraints and transforms\n     * @ignoresMeta\n     *\n     * @example\n     * const DivisibleBy6 = type.number.divisibleBy(6).moreThan(0)\n     * // false (left side must also be positive)\n     * DivisibleBy6.equals(\"number % 6\")\n     * // false (right side has an additional <100 constraint)\n     * console.log(DivisibleBy6.equals(\"0 < (number % 6) < 100\"))\n     * const ThirdTry = type(\"(number % 2) > 0\").divisibleBy(3)\n     * // true (types are normalized and reduced)\n     * console.log(DivisibleBy6.equals(ThirdTry))\n     */\n    equals<const def>(def: type.validate<def, $>): boolean;\n    /**\n     * #### narrow this based on an {@link equals} check\n     *\n     * @ignoresMeta\n     *\n     * @example\n     * const N = type.raw(`${Math.random()}`)\n     * // Type<0.5> | undefined\n     * const Ez = N.ifEquals(\"0.5\")\n     */\n    ifEquals<const def, r = type.instantiate<def, $>>(def: type.validate<def, $>): r extends infer _ ? _ | undefined : never;\n    /**\n     * #### check if this is a subtype of the parsed Type\n     *\n     *  a subtype must include all constraints from the base type\n     *  unlike {@link equals}, additional constraints may be present\n     * @ignoresMeta\n     *\n     * @example\n     * type.string.extends(\"unknown\") // true\n     * type.string.extends(/^a.*z$/) // false\n     */\n    extends<const def>(other: type.validate<def, $>): boolean;\n    /**\n     * #### narrow this based on an {@link extends} check\n     *\n     * @ignoresMeta\n     *\n     * @example\n     * const N = type(Math.random() > 0.5 ? \"true\" : \"0\") // Type<0 | true>\n     * const Ez = N.ifExtends(\"boolean\") // Type<true> | undefined\n     */\n    ifExtends<const def, r = type.instantiate<def, $>>(other: type.validate<def, $>): r extends infer _ ? _ | undefined : never;\n    /**\n     * #### check if a value could satisfy this and the parsed Type\n     *\n     *  will return true unless a {@link Disjoint} can be proven\n     *\n     * @example\n     * type.string.overlaps(\"string | number\") // true (e.g. \"foo\")\n     * type(\"string | number\").overlaps(\"1\") // true (1)\n     * type(\"number > 0\").overlaps(\"number < 0\") // false (no values exist)\n     *\n     * const NoAt = type(\"string\").narrow(s => !s.includes(\"@\"))\n     * NoAt.overlaps(\"string.email\") // true (no values exist, but not provable)\n     */\n    overlaps<const def>(r: type.validate<def, $>): boolean;\n    /**\n     * #### extract branches {@link extend}ing the parsed Type\n     *\n     * @example\n     * // Type<true | 0 | 2>\n     * const T = type(\"boolean | 0 | 'one' | 2 | bigint\").extract(\"number | 0n | true\")\n     */\n    extract<const def, r = instantiateType<t extends type.infer<def, $> ? t : never, $>>(r: type.validate<def, $>): r extends infer _ extends r ? _ : never;\n    /**\n     * #### exclude branches {@link extend}ing the parsed Type\n     *\n     * @example\n     *\n     * // Type<false | 'one' | bigint>\n     * const T = type(\"boolean | 0 | 'one' | 2 | bigint\").exclude(\"number | 0n | true\")\n     */\n    exclude<const def, r = instantiateType<t extends type.infer<def, $> ? never : t, $>>(r: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * @experimental\n     * Map and optionally reduce branches of a union. Types that are not unions\n     * are treated as a single branch.\n     *\n     * @param mapBranch - the mapping function, accepting a branch Type\n     *     Returning another `Type` is common, but any value can be returned and\n     *     inferred as part of the output.\n     *\n     * @param [reduceMapped] - an operation to perform on the mapped branches\n     *     Can be used to e.g. merge an array of returned Types representing\n     *     branches back to a single union.\n     */\n    distribute<mapOut, reduceOut = mapOut[]>(mapBranch: (branch: Type$1, i: number, branches: array<Type$1>) => mapOut, reduceMapped?: (mappedBranches: mapOut[]) => reduceOut): reduceOut;\n    /** The Type's [StandardSchema](https://github.com/standard-schema/standard-schema) properties */\n    \"~standard\": StandardSchemaV1.ArkTypeProps<this[\"inferIn\"], this[\"inferOut\"]>;\n    /** @deprecated */\n    apply: Function[\"apply\"];\n    /** @deprecated */\n    bind: Function[\"bind\"];\n    /** @deprecated */\n    call: Function[\"call\"];\n    /** @deprecated */\n    caller: Function;\n    /** @deprecated */\n    length: number;\n    /** @deprecated */\n    name: string;\n    /** @deprecated */\n    prototype: Function[\"prototype\"];\n    /** @deprecated */\n    arguments: Function[\"arguments\"];\n    /** @deprecated */\n    Symbol: never;\n}\ninterface ChainedPipeParser<$, t> extends NaryPipeParser<$, t> {\n    try: NaryPipeParser<$, t>;\n}\ntype validateChainedAsArgs<t> = [\n    t\n] extends [unset] ? [\n    t\n] extends [anyOrNever] ? [\n] : [\n    ErrorMessage<\"as requires an explicit type parameter like myType.as<t>()\">\n] : [];\n\ntype MatchParserContext<input = unknown> = {\n    cases: Morph[];\n    $: unknown;\n    input: input;\n    checked: boolean;\n    key: PropertyKey | null;\n};\ndeclare namespace ctx {\n    type from<ctx extends MatchParserContext> = ctx;\n    type init<$, input = unknown, checked extends boolean = false> = from<{\n        cases: [];\n        $: $;\n        input: input;\n        checked: checked;\n        key: null;\n    }>;\n    type atKey<ctx extends MatchParserContext, key extends string> = from<{\n        cases: ctx[\"cases\"];\n        $: ctx[\"$\"];\n        input: ctx[\"input\"];\n        checked: ctx[\"checked\"];\n        key: key;\n    }>;\n}\ninterface MatchParser<$> extends CaseMatchParser<ctx.init<$>> {\n    in<const def>(def: type.validate<def, $>): ChainableMatchParser<ctx.init<$, type.infer<def, $>, true>>;\n    in<const typedInput = never>(...args: [typedInput] extends [never] ? [\n        ErrorMessage<\"in requires a definition or type argument (in('string') or in<string>())\">\n    ] : []): ChainableMatchParser<ctx.init<$, typedInput>>;\n    in<const def>(def: type.validate<def, $>): ChainableMatchParser<ctx.init<$, type.infer<def, $>, true>>;\n    case: CaseParser<ctx.init<$>>;\n    at: AtParser<ctx.init<$>>;\n}\ntype addCasesToContext<ctx extends MatchParserContext, cases extends unknown[]> = cases extends Morph[] ? ctx.from<{\n    $: ctx[\"$\"];\n    input: ctx[\"input\"];\n    cases: [...ctx[\"cases\"], ...cases];\n    checked: ctx[\"checked\"];\n    key: ctx[\"key\"];\n}> : never;\ntype addDefaultToContext<ctx extends MatchParserContext, defaultCase extends DefaultCase<ctx>> = ctx.from<{\n    $: ctx[\"$\"];\n    input: defaultCase extends \"never\" ? Morph.In<ctx[\"cases\"][number]> : ctx[\"input\"];\n    cases: defaultCase extends \"never\" | \"assert\" ? ctx[\"cases\"] : defaultCase extends Morph ? ctx[\"checked\"] extends true ? [\n        (In: unknown) => ArkErrors,\n        ...ctx[\"cases\"],\n        defaultCase\n    ] : [...ctx[\"cases\"], defaultCase] : [\n        ...ctx[\"cases\"],\n        (In: ctx[\"input\"]) => ArkErrors\n    ];\n    checked: ctx[\"checked\"];\n    key: ctx[\"key\"];\n}>;\ntype CaseKeyKind = \"def\" | \"string\";\ntype casesToMorphTuple<cases, ctx extends MatchParserContext, kind extends CaseKeyKind> = unionToTuple<propValueOf<{\n    [def in Exclude<keyof cases, \"default\">]: cases[def] extends (Morph<never, infer o>) ? kind extends \"def\" ? (In: inferCaseArg<def extends number ? `${number}` : def, ctx, \"in\">) => o : (In: maybeLiftToKey<def, ctx>) => o : never;\n}>>;\ntype addCasesToParser<cases, ctx extends MatchParserContext, kind extends CaseKeyKind> = cases extends {\n    default: infer defaultDef extends DefaultCase<ctx>;\n} ? finalizeMatchParser<addCasesToContext<ctx, casesToMorphTuple<cases, ctx, kind>>, defaultDef> : ChainableMatchParser<addCasesToContext<ctx, casesToMorphTuple<cases, ctx, kind>>>;\ntype inferCaseArg<def, ctx extends MatchParserContext, endpoint extends \"in\" | \"out\"> = _finalizeCaseArg<maybeLiftToKey<type.infer<def, ctx[\"$\"]>, ctx>, ctx, endpoint>;\ntype maybeLiftToKey<t, ctx extends MatchParserContext> = ctx[\"key\"] extends PropertyKey ? {\n    [k in ctx[\"key\"]]: t;\n} : t;\ntype _finalizeCaseArg<t, ctx extends MatchParserContext, endpoint extends \"in\" | \"out\", ctxInput = ctx[\"input\"]> = ctxInput extends unknown ? t extends unknown ? [\n    distill<t, \"in\">,\n    distill<t, endpoint>\n] extends [infer i, infer result] ? i extends ctxInput ? ctxInput extends result ? ctxInput : ctxInput & result : ctxInput & result : never : never : never;\ntype CaseParser<ctx extends MatchParserContext> = <const def, ret>(def: type.validate<def, ctx[\"$\"]>, resolve: (In: inferCaseArg<def, ctx, \"out\">) => ret) => ChainableMatchParser<addCasesToContext<ctx, [(In: inferCaseArg<def, ctx, \"in\">) => ret]>>;\ntype validateKey<key extends Key, ctx extends MatchParserContext> = ctx[\"key\"] extends Key ? ErrorMessage<doubleAtMessage> : ctx[\"cases\"][\"length\"] extends 0 ? keyof ctx[\"input\"] extends never ? key : conform<key, keyof ctx[\"input\"]> : ErrorMessage<chainedAtMessage>;\ninterface StringsParser<ctx extends MatchParserContext> {\n    <const cases>(def: cases extends validateStringCases<cases, ctx> ? cases : validateStringCases<cases, ctx>): addCasesToParser<cases, ctx, \"string\">;\n}\ntype validateStringCases<cases, ctx extends MatchParserContext> = unknown extends ctx[\"input\"] ? {\n    [k in keyof cases]?: k extends \"default\" ? DefaultCase<ctx> : (In: _finalizeCaseArg<maybeLiftToKey<k, ctx>, ctx, \"out\">) => unknown;\n} & {\n    default?: DefaultCase<ctx>;\n} : {\n    [k in keyof cases]?: k extends \"default\" ? DefaultCase<ctx> : k extends stringValue<ctx> ? (In: _finalizeCaseArg<maybeLiftToKey<k, ctx>, ctx, \"out\">) => unknown : ErrorType<`${k & string} must be a possible string value`>;\n} & {\n    [k in stringValue<ctx>]?: unknown;\n} & {\n    default?: DefaultCase<ctx>;\n};\ntype stringValue<ctx extends MatchParserContext> = ctx[\"input\"] extends string ? ctx[\"input\"] : ctx[\"key\"] extends keyof ctx[\"input\"] ? ctx[\"input\"][ctx[\"key\"]] extends infer s extends string ? s : never : never;\ninterface AtParser<ctx extends MatchParserContext> {\n    <const key extends string>(key: validateKey<key, ctx>): ChainableMatchParser<ctx.atKey<ctx, key>>;\n    <const key extends string, const cases, ctxAtKey extends MatchParserContext = ctx.atKey<ctx, key>>(key: validateKey<key, ctx>, cases: cases extends validateCases<cases, ctxAtKey> ? cases : errorCases<cases, ctxAtKey>): addCasesToParser<cases, ctxAtKey, \"def\">;\n}\ninterface ChainableMatchParser<ctx extends MatchParserContext> {\n    case: CaseParser<ctx>;\n    match: CaseMatchParser<ctx>;\n    default: DefaultMethod<ctx>;\n    at: AtParser<ctx>;\n    /** @experimental */\n    strings: StringsParser<ctx>;\n}\ntype DefaultCaseKeyword = \"never\" | \"assert\" | \"reject\";\ntype DefaultCase<ctx extends MatchParserContext = MatchParserContext<any>> = DefaultCaseKeyword | Morph<ctx[\"input\"]>;\ntype DefaultMethod<ctx extends MatchParserContext> = <const def extends DefaultCase<ctx>>(def: def) => finalizeMatchParser<ctx, def>;\ntype validateCases<cases, ctx extends MatchParserContext> = {\n    [def in keyof cases | BaseCompletions<ctx[\"$\"], {}, \"default\">]?: def extends \"default\" ? DefaultCase<ctx> : def extends number ? (In: inferCaseArg<`${def}`, ctx, \"out\">) => unknown : def extends type.validate<def, ctx[\"$\"]> ? (In: inferCaseArg<def, ctx, \"out\">) => unknown : type.validate<def, ctx[\"$\"]>;\n};\ntype errorCases<cases, ctx extends MatchParserContext> = {\n    [def in keyof cases]?: def extends \"default\" ? DefaultCase<ctx> : def extends number ? (In: inferCaseArg<`${def}`, ctx, \"out\">) => unknown : def extends type.validate<def, ctx[\"$\"]> ? (In: inferCaseArg<def, ctx, \"out\">) => unknown : ErrorType<type.validate<def, ctx[\"$\"]>>;\n} & {\n    [k in BaseCompletions<ctx[\"$\"], {}>]?: (In: inferCaseArg<k, ctx, \"out\">) => unknown;\n} & {\n    default?: DefaultCase<ctx>;\n};\ntype CaseMatchParser<ctx extends MatchParserContext> = <const cases>(def: cases extends validateCases<cases, ctx> ? cases : errorCases<cases, ctx>) => addCasesToParser<cases, ctx, \"def\">;\ntype finalizeMatchParser<ctx extends MatchParserContext, defaultCase extends DefaultCase<ctx>> = addDefaultToContext<ctx, defaultCase> extends (infer ctx extends MatchParserContext) ? Match<ctx[\"input\"], ctx[\"cases\"]> : never;\ninterface Match<In = any, cases extends Morph[] = Morph[]> extends Inferred<(In: Morph.In<cases[number]>) => Out<ReturnType<cases[number]>>> {\n    <const data extends In>(data: data): {\n        [i in numericStringKeyOf<cases>]: isDisjoint<data, Morph.In<cases[i]>> extends true ? never : Morph.Out<cases[i]>;\n    }[numericStringKeyOf<cases>];\n}\ndeclare class InternalMatchParser extends Callable<InternalCaseParserFn> {\n    $: InternalScope;\n    constructor($: InternalScope);\n    in(def?: unknown): InternalChainedMatchParser;\n    at(key: Key, cases?: InternalCases): InternalChainedMatchParser | Match;\n    case(when: unknown, then: Morph): InternalChainedMatchParser;\n}\ntype InternalCases = Record<string, Morph | DefaultCase>;\ntype InternalCaseParserFn = (cases: InternalCases) => InternalChainedMatchParser | Match;\ntype CaseEntry = [BaseRoot, Morph] | [\"default\", DefaultCase];\ndeclare class InternalChainedMatchParser extends Callable<InternalCaseParserFn> {\n    $: InternalScope;\n    in: BaseRoot | undefined;\n    protected key: Key | undefined;\n    protected branches: BaseRoot[];\n    constructor($: InternalScope, In?: BaseRoot);\n    at(key: Key, cases?: InternalCases): InternalChainedMatchParser | Match;\n    case(def: unknown, resolver: Morph): InternalChainedMatchParser;\n    protected caseEntry(node: BaseRoot, resolver: Morph): InternalChainedMatchParser;\n    match(cases: InternalCases): InternalChainedMatchParser | Match;\n    strings(cases: InternalCases): InternalChainedMatchParser | Match;\n    protected caseEntries(entries: CaseEntry[]): InternalChainedMatchParser | Match;\n    default(defaultCase: DefaultCase): Match;\n}\ndeclare const chainedAtMessage = \"A key matcher must be specified before the first case i.e. match.at('foo') or match.in<object>().at('bar')\";\ntype chainedAtMessage = typeof chainedAtMessage;\ndeclare const doubleAtMessage = \"At most one key matcher may be specified per expression\";\ntype doubleAtMessage = typeof doubleAtMessage;\n\ntype maybeValidateTupleExpression<def extends array, $, args> = def extends IndexZeroExpression ? validatePrefixExpression<def, $, args> : def extends IndexOneExpression ? validateIndexOneExpression<def, $, args> : def extends (readonly [\"\", ...unknown[]] | readonly [unknown, \"\", ...unknown[]]) ? readonly [\n    def[0] extends \"\" ? BaseCompletions<$, args, IndexZeroOperator | \"...\"> : def[0],\n    def[1] extends \"\" ? BaseCompletions<$, args, IndexOneOperator | \"...\"> : def[1]\n] : null;\ntype inferTupleExpression<def extends TupleExpression, $, args> = def[1] extends \"[]\" ? inferDefinition<def[0], $, args>[] : def[1] extends \"?\" ? inferDefinition<def[0], $, args> : def[1] extends \"&\" ? inferIntersection<inferDefinition<def[0], $, args>, inferDefinition<def[2], $, args>> : def[1] extends \"|\" ? inferDefinition<def[0], $, args> | inferDefinition<def[2], $, args> : def[1] extends \":\" ? inferPredicate<inferDefinition<def[0], $, args>, def[2]> : def[1] extends \"=>\" ? parseMorph<def[0], def[2], $, args> : def[1] extends \"|>\" ? parseTo<def[0], def[2], $, args> : def[1] extends \"=\" ? withDefault<inferDefinition<def[0], $, args>, unwrapDefault<def[2]>> : def[1] extends \"@\" ? inferDefinition<def[0], $, args> : def extends readonly [\"===\", ...infer values] ? values[number] : def extends (readonly [\"instanceof\", ...infer constructors extends Constructor[]]) ? InstanceType<constructors[number]> : def[0] extends \"keyof\" ? inferKeyOfExpression<def[1], $, args> : never;\ntype validatePrefixExpression<def extends IndexZeroExpression, $, args> = def[\"length\"] extends 1 ? readonly [writeMissingRightOperandMessage<def[0]>] : def[0] extends \"keyof\" ? readonly [def[0], validateDefinition<def[1], $, args>] : def[0] extends \"===\" ? readonly [def[0], ...unknown[]] : def[0] extends \"instanceof\" ? readonly [def[0], ...Constructor[]] : never;\ntype validateIndexOneExpression<def extends IndexOneExpression, $, args> = def[1] extends TuplePostfixOperator ? readonly [validateDefinition<def[0], $, args>, def[1]] : readonly [\n    validateDefinition<def[0], $, args>,\n    def[\"length\"] extends 2 ? writeMissingRightOperandMessage<def[1]> : def[1],\n    def[1] extends \"|\" ? validateDefinition<def[2], $, args> : def[1] extends \"&\" ? validateDefinition<def[2], $, args> : def[1] extends \":\" ? Predicate<type.infer.Out<def[0], $, args>> : def[1] extends \"=>\" ? Morph<type.infer.Out<def[0], $, args>> : def[1] extends \"|>\" ? validateDefinition<def[2], $, args> : def[1] extends \"=\" ? defaultFor<type.infer.In<def[0], $, args>> : def[1] extends \"@\" ? TypeMeta.MappableInput : validateDefinition<def[2], $, args>,\n    ...(def[1] extends \"@\" ? [NodeSelector?] : [])\n];\ntype inferKeyOfExpression<operandDef, $, args> = show<keyof inferDefinition<operandDef, $, args>>;\ntype TupleExpression = IndexZeroExpression | IndexOneExpression;\ntype ArgTwoOperator = Exclude<IndexOneOperator, \"?\" | \"=\">;\ntype parseTo<inDef, outDef, $, args> = inferPipe<inferDefinition<inDef, $, args>, inferDefinition<outDef, $, args>>;\ntype parseMorph<inDef, morph, $, args> = morph extends Morph ? inferMorphOut<morph> extends infer out ? (In: distill.In<inferDefinition<inDef, $, args>>) => Out<out> : never : never;\ntype IndexOneExpression<token extends string = IndexOneOperator> = readonly [unknown, token, ...unknown[]];\ntype IndexOneParser<token extends string> = (def: IndexOneExpression<token>, ctx: BaseParseContext) => BaseRoot;\ndeclare const postfixParsers: {\n    \"?\": IndexOneParser<\"?\">;\n    \"[]\": IndexOneParser<\"[]\">;\n};\ntype TuplePostfixOperator = keyof typeof postfixParsers;\ndeclare const infixParsers: {\n    \"|\": IndexOneParser<\"|\">;\n    \"=\": IndexOneParser<\"=\">;\n    \":\": IndexOneParser<\":\">;\n    \"|>\": IndexOneParser<\"|>\">;\n    \"&\": IndexOneParser<\"&\">;\n    \"=>\": IndexOneParser<\"=>\">;\n    \"@\": IndexOneParser<\"@\">;\n};\ntype TupleInfixOperator = keyof typeof infixParsers;\ndeclare const indexOneParsers: {\n    \"|\": IndexOneParser<\"|\">;\n    \"=\": IndexOneParser<\"=\">;\n    \":\": IndexOneParser<\":\">;\n    \"|>\": IndexOneParser<\"|>\">;\n    \"&\": IndexOneParser<\"&\">;\n    \"=>\": IndexOneParser<\"=>\">;\n    \"@\": IndexOneParser<\"@\">;\n    \"?\": IndexOneParser<\"?\">;\n    \"[]\": IndexOneParser<\"[]\">;\n};\ntype IndexOneOperator = keyof typeof indexOneParsers;\ntype IndexZeroParser<token extends string> = (def: IndexZeroExpression<token>, ctx: BaseParseContext) => BaseRoot;\ntype IndexZeroExpression<token extends string = IndexZeroOperator> = readonly [\n    token,\n    ...unknown[]\n];\ndeclare const indexZeroParsers: {\n    keyof: IndexZeroParser<\"keyof\">;\n    instanceof: IndexZeroParser<\"instanceof\">;\n    \"===\": IndexZeroParser<\"===\">;\n};\ntype IndexZeroOperator = keyof typeof indexZeroParsers;\n\n/** The convenience properties attached to `type` */\ntype TypeParserAttachments = Omit<TypeParser, never>;\ninterface TypeParser<$ = {}> extends Ark.boundTypeAttachments<$> {\n    /**\n     * Create a {@link Type} from your definition.\n     *\n     * @example const Person = type({ name: \"string\" })\n     */\n    <const def, r = type.instantiate<def, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * Create a {@link Generic} from a parameter string and body definition.\n     *\n     * @param params A string like \"<t, n extends number>\" specifying the\n     * {@link Generic}'s parameters and any associated constraints via `extends`.\n     *\n     * @param def The definition for the body of the {@link Generic}. Can reference the\n     * parameter names specified in the previous argument in addition to aliases\n     * from its {@link Scope}.\n     *\n     * @example const BoxOf = type(\"<t extends string | number>\", { contents: \"t\" })\n     */\n    <const params extends ParameterString, const def, r = Generic<parseValidGenericParams<params, $>, def, $>>(params: validateParameterString<params, $>, def: type.validate<def, $, baseGenericConstraints<parseValidGenericParams<params, $>>>): r extends infer _ ? _ : never;\n    /**\n     * Create a {@link Type} from a [tuple expression](http://localhost:3000/docs/expressions)\n     * spread as this function's arguments.\n     *\n     * @example type(\"string\", \"|\", { foo: \"number\" })\n     */\n    <const zero, const one, const rest extends array, r = type.instantiate<[zero, one, ...rest], $>>(_0: zero extends IndexZeroOperator ? zero : type.validate<zero, $>, _1: zero extends \"keyof\" ? type.validate<one, $> : zero extends \"instanceof\" ? conform<one, Constructor> : zero extends \"===\" ? conform<one, unknown> : conform<one, ArgTwoOperator>, ..._2: zero extends \"===\" ? rest : zero extends \"instanceof\" ? conform<rest, readonly Constructor[]> : one extends TupleInfixOperator ? one extends \":\" ? [Predicate<distill.In<type.infer<zero, $>>>] : one extends \"=>\" ? [Morph<distill.Out<type.infer<zero, $>>, unknown>] : one extends \"|>\" ? [type.validate<rest[0], $>] : one extends \"@\" ? [TypeMeta.MappableInput, NodeSelector?] : [type.validate<rest[0], $>] : []): r extends infer _ ? _ : never;\n    /**\n     * An alias of the {@link ArkErrors} class, an instance of which is returned when a {@link Type}\n     * is invoked with invalid input.\n     *\n     * @example\n     * const out = myType(data)\n     *\n     * if(out instanceof type.errors) console.log(out.summary)\n     */\n    errors: typeof ArkErrors;\n    hkt: typeof Hkt;\n    keywords: typeof keywords;\n    /**\n     * The {@link Scope} in which definitions passed to this function will be parsed.\n     */\n    $: Scope<$>;\n    /**\n     * An alias of `type` with no type-level validation or inference.\n     *\n     * Useful when wrapping `type` or using it to parse a dynamic definition.\n     */\n    raw(def: unknown): Type$1<any, $>;\n    module: ModuleParser;\n    scope: ScopeParser;\n    define: DefinitionParser<$>;\n    declare: DeclarationParser<$>;\n    generic: GenericParser<$>;\n    match: MatchParser<$>;\n    schema: SchemaParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by a value strictly equal (`===`) to the argument passed to this function.\n     * @example const foo = type.unit('foo') // {@link Type}<'foo'>\n     * @example const sym: unique symbol = Symbol(); type.unit(sym) // {@link Type}<typeof sym>\n     */\n    unit: UnitTypeParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by a value strictly equal (`===`) to one of the arguments passed to this function.\n     * @example const enum = type.enumerated('foo', 'bar', obj) // obj is a by-reference object\n     * @example const TupleForm = type(['===', 'foo', 'bar', obj])\n     * @example const ArgsForm = type('===', 'foo', 'bar', obj)\n     */\n    enumerated: EnumeratedTypeParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by one of the Object.values() of the argument passed to this function.\n     *\n     *  For TypeScript enum compatibility, values at numeric keys with corresponding numeric values will not be included.\n     * @example const myEnum = type.valueOf(myTsEnum)\n     */\n    valueOf: ValueOfTypeParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by a value of a specific class.\n     * @example const array = type.instanceOf(Array)\n     */\n    instanceOf: InstanceOfTypeParser<$>;\n    /**\n     * Create a {@link Type} from a union of definitions\n     * @example const T = type.or(\"string\", \"number\")\n     */\n    or: NaryUnionParser<$>;\n    /**\n     * Create a {@link Type} from an intersection of definitions\n     * @example const T = type.and({ a: \"1\" }, { b: \"2\" })\n     */\n    and: NaryIntersectionParser<$>;\n    /**\n     * Create a {@link Type} by merging object definitions, with later\n     * definitions having precedence for overlapping keys\n     * @example\n     * // Type<{ a: \"3\", b: \"2\", c: \"4\" }>\n     * const T = type.merge({ a: \"1\", b: \"2\" }, { a: \"3\", c: \"4\" })\n     */\n    merge: NaryMergeParser<$>;\n    /**\n     * Create a {@link Type} from a set of morphs (including Types)\n     * @example\n     * // Type<(In: string) => To<object>>\n     * const T = type.pipe(type.string, s => JSON.parse(s), type.object)\n     */\n    pipe: NaryPipeParser<$>;\n    /**\n     * Define a validated function\n     * @example\n     * const len = type.fn(\"string | unknown[]\", \":\", \"number\")(s => s.length)\n     * len(\"foo\") // 3\n     * // TypeScript: boolean is not assignable to string | unknown[]\n     * // Runtime (throws): must be a string or an object (was boolean)\n     * len(true)\n     */\n    fn: FnParser<$>;\n}\ndeclare class InternalTypeParser extends Callable<(...args: unknown[]) => BaseRoot | Generic, TypeParserAttachments> {\n    constructor($: InternalScope);\n}\ntype UnitTypeParser<$> = <const t>(value: t) => Type<t, $>;\ntype InstanceOfTypeParser<$> = <const t extends object>(ctor: Constructor<t>) => Type<t, $>;\ntype EnumeratedTypeParser<$> = <const values extends readonly unknown[]>(...values: values) => Type<values[number], $>;\ntype ValueOfTypeParser<$> = <const o extends object>(o: o) => Type<o[keyof o], $>;\ntype DefinitionParser<$> = <const def>(def: type.validate<def, $>) => def;\ntype SchemaParser<$> = (schema: RootSchema, opts?: BaseParseOptions) => Type<unknown, $>;\ntype TypeConstructor<t = unknown, $ = {}> = new (def: unknown, $: Scope<$>) => Type<t, $>;\ntype Type<t = unknown, $ = {}> = instantiateType<t, $>;\ndeclare const Type: TypeConstructor;\n\ninterface FnParser<$ = {}> {\n    <const args extends readonly unknown[], paramsT extends readonly unknown[] = inferTupleLiteral<args extends readonly [...infer params, \":\", unknown] ? params : args, $, {}>, returnT = args extends readonly [...unknown[], \":\", infer returnDef] ? type.infer<returnDef, $> : unknown>(...args: {\n        [i in keyof args]: conform<args[i], get<validateFnArgs<args, $>, i>>;\n    }): <internalSignature extends (...args: distill.Out<paramsT>) => distill.In<returnT>, externalSignature extends Fn = (...args: applyElementLabels<distill.In<paramsT>, Parameters<internalSignature>>) => args extends readonly [...unknown[], \":\", unknown] ? distill.Out<returnT> : ReturnType<internalSignature>>(implementation: internalSignature) => TypedFn<externalSignature, $, args extends readonly [...unknown[], \":\", unknown] ? Return.introspectable : {}>;\n    /**\n     * The {@link Scope} in which definitions passed to this function will be parsed.\n     */\n    $: Scope<$>;\n    /**\n     * An alias of `fn` with no type-level validation or inference.\n     *\n     * Useful when wrapping `fn` or using it to parse a dynamic definition.\n     */\n    raw: RawFnParser;\n}\ntype RawFnParser = (...args: unknown[]) => (...args: unknown[]) => unknown;\ndeclare class InternalFnParser extends Callable<(...args: unknown[]) => Fn> {\n    constructor($: InternalScope);\n}\ndeclare namespace TypedFn {\n    type meta = {\n        introspectableReturn?: true;\n    };\n}\ninterface TypedFn<signature extends Fn = Fn, $ = {}, meta extends TypedFn.meta = {}> extends Callable<signature> {\n    expression: string;\n    params: signature extends Fn<infer params> ? Type<params, $> : never;\n    returns: Type<meta extends Return.introspectable ? ReturnType<signature> : unknown, $>;\n}\ndeclare namespace Return {\n    interface introspectable {\n        introspectableReturn: true;\n    }\n}\ntype validateFnArgs<args, $> = args extends readonly unknown[] ? args extends readonly [...infer paramDefs, \":\", infer returnDef] ? readonly [\n    ...validateFnParamDefs<paramDefs, $>,\n    \":\",\n    type.validate<returnDef, $>\n] : validateFnParamDefs<args, $> : never;\ntype validateFnParamDefs<paramDefs extends readonly unknown[], $> = paramDefs extends validateTupleLiteral<paramDefs, $, {}> ? paramDefs : paramDefs extends {\n    [i in keyof paramDefs]: paramDefs[i] extends \"...\" ? paramDefs[i] : validateInnerDefinition<paramDefs[i], $, {}>;\n} ? validateTupleLiteral<paramDefs, $, {}> : {\n    [i in keyof paramDefs]: validateInnerDefinition<paramDefs[i], $, {}>;\n};\n\ninterface ArkScopeConfig extends ArkSchemaScopeConfig {\n}\ninterface ScopeParser {\n    <const def>(def: scope.validate<def>, config?: ArkScopeConfig): Scope<scope.infer<def>>;\n    define: <const def>(def: scope.validate<def>) => def;\n}\ntype ModuleParser = <const def>(def: scope.validate<def>, config?: ArkScopeConfig) => scope.infer<def> extends infer $ ? Module<{\n    [k in exportedNameOf<$>]: $[k];\n}> : never;\ntype bindThis<def> = {\n    this: Def<def>;\n};\n/** nominal type for an unparsed definition used during scope bootstrapping */\ntype Def<def = {}> = Brand<def, \"unparsed\">;\n/** sentinel indicating a scope that will be associated with a generic has not yet been parsed */\ntype UnparsedScope = \"$\";\n/** These are legal as values of a scope but not as definitions in other contexts */\ntype PreparsedResolution = PreparsedNodeResolution;\ntype bootstrapAliases<def> = {\n    [k in Exclude<keyof def, GenericDeclaration>]: def[k] extends (PreparsedResolution) ? def[k] extends {\n        t: infer g extends GenericAst;\n    } ? g : def[k] extends Module<infer $> | BoundModule<infer $, any> ? Submodule<$> : def[k] : def[k] extends (() => infer thunkReturn extends PreparsedResolution) ? thunkReturn extends {\n        t: infer g extends GenericAst;\n    } ? g : thunkReturn extends Module<infer $> | BoundModule<infer $, any> ? Submodule<$> : thunkReturn : Def<def[k]>;\n} & {\n    [k in keyof def & GenericDeclaration as extractGenericName<k>]: GenericAst<parseValidGenericParams<extractGenericParameters<k>, bootstrapAliases<def>>, def[k], UnparsedScope>;\n};\ntype inferBootstrapped<$> = {\n    [name in keyof $]: $[name] extends Def<infer def> ? inferDefinition<def, $, {}> : $[name] extends {\n        t: infer g extends GenericAst;\n    } ? bindGenericToScope<g, $> : $[name];\n} & unknown;\ntype bindGenericToScope<g extends GenericAst, $> = GenericAst<g[\"paramsAst\"], g[\"bodyDef\"], g[\"$\"] extends UnparsedScope ? $ : g[\"$\"], $>;\ntype extractGenericName<k> = k extends GenericDeclaration<infer name> ? name : never;\ntype extractGenericParameters<k> = k extends `${string}<${infer params}>` ? ParameterString<params> : never;\ntype resolutionToAst<alias extends string, resolution> = [\n    resolution\n] extends [anyOrNever] ? InferredAst<resolution, alias> : resolution extends Def<infer def> ? DefAst<def, alias> : resolution extends {\n    [arkKind]: \"module\";\n    root: infer root;\n} ? InferredAst<root, alias> : resolution extends GenericAst ? resolution : InferredAst<resolution, alias>;\ninterface InternalScope {\n    constructor: typeof InternalScope;\n}\ndeclare class InternalScope<$ extends {} = {}> extends BaseScope<$> {\n    get ambientAttachments(): Ark.boundTypeAttachments<$> | undefined;\n    protected preparseOwnAliasEntry(alias: string, def: unknown): AliasDefEntry;\n    parseGenericParams(def: string, opts: BaseParseOptions): array<GenericParamDef>;\n    protected normalizeRootScopeValue(resolution: unknown): unknown;\n    protected preparseOwnDefinitionFormat(def: unknown, opts: BaseParseOptions): BaseRoot | BaseParseContextInput;\n    parseOwnDefinitionFormat(def: unknown, ctx: BaseParseContext): BaseRoot;\n    unit: UnitTypeParser<$>;\n    valueOf: ValueOfTypeParser<$>;\n    enumerated: EnumeratedTypeParser<$>;\n    instanceOf: InstanceOfTypeParser<$>;\n    or: NaryUnionParser<$>;\n    and: NaryIntersectionParser<$>;\n    merge: NaryMergeParser<$>;\n    pipe: NaryPipeParser<$>;\n    fn: InternalFnParser;\n    match: InternalMatchParser;\n    declare: () => {\n        type: InternalTypeParser;\n    };\n    define<def>(def: def): def;\n    type: InternalTypeParser;\n    static scope: ScopeParser;\n    static module: ModuleParser;\n}\ndeclare const scope: ScopeParser;\ndeclare namespace scope {\n    type validate<def> = {\n        [k in keyof def]: k extends noSuggest ? unknown : parseScopeKey<k, def>[\"params\"] extends infer params ? params extends array<GenericParamAst> ? params[\"length\"] extends 0 ? def[k] extends type.Any | PreparsedResolution ? def[k] : k extends (PrivateDeclaration<infer name extends keyof def & string>) ? ErrorType<writeDuplicateAliasError<name>> : type.validate<def[k], bootstrapAliases<def>, {}> : type.validate<def[k], bootstrapAliases<def>, baseGenericConstraints<params>> : params : never;\n    };\n    type infer<def> = inferBootstrapped<bootstrapAliases<def>>;\n}\ninterface ScopeConstructor {\n    new <$ = {}>(...args: ConstructorParameters<typeof InternalScope>): Scope<$>;\n    scope: ScopeParser;\n    module: ModuleParser;\n}\ninterface Scope<$ = {}> {\n    t: $;\n    [arkKind]: \"scope\";\n    config: ArkScopeConfig;\n    references: readonly BaseNode[];\n    json: JsonStructure;\n    exportedNames: array<exportedNameOf<$>>;\n    /** The set of names defined at the root-level of the scope mapped to their\n     * corresponding definitions.**/\n    aliases: Record<string, unknown>;\n    internal: toInternalScope<$>;\n    defineSchema<const def extends RootSchema>(schema: def): def;\n    node<kinds extends NodeKind | array<RootKind>>(kinds: kinds, schema: NodeSchema<flattenListable<kinds>>, opts?: BaseParseOptions): nodeOfKind<reducibleKindOf<flattenListable<kinds>>>;\n    unit: UnitTypeParser<$>;\n    enumerated: EnumeratedTypeParser<$>;\n    valueOf: ValueOfTypeParser<$>;\n    instanceOf: InstanceOfTypeParser<$>;\n    type: TypeParser<$>;\n    match: MatchParser<$>;\n    fn: FnParser<$>;\n    declare: DeclarationParser<$>;\n    define: DefinitionParser<$>;\n    generic: GenericParser<$>;\n    schema: SchemaParser<$>;\n    import(): Module<{\n        [k in exportedNameOf<$> as PrivateDeclaration<k>]: $[k];\n    }>;\n    import<names extends exportedNameOf<$>[]>(...names: names): BoundModule<{\n        [k in names[number] as PrivateDeclaration<k>]: $[k];\n    } & unknown, $>;\n    export(): Module<{\n        [k in exportedNameOf<$>]: $[k];\n    }>;\n    export<names extends exportedNameOf<$>[]>(...names: names): BoundModule<{\n        [k in names[number]]: $[k];\n    } & unknown, $>;\n    resolve<name extends exportedNameOf<$>>(name: name): instantiateExport<$[name], $>;\n}\ndeclare const Scope: ScopeConstructor;\ntype parseScopeKey<k, def> = k extends `${infer name}<${infer params}>` ? parseGenericScopeKey<name, params, def> : {\n    name: k;\n    params: [];\n};\ntype parseGenericScopeKey<name extends string, params extends string, def> = {\n    name: name;\n    params: parseGenericParams<params, bootstrapAliases<def>>;\n};\ntype InnerParseResult = BaseRoot | ParsedOptionalProperty | ParsedDefaultableProperty;\n\ntype inferDefinition<def, $, args> = [\n    def\n] extends [anyOrNever] ? def : def extends type.cast<infer t> ? ifEmptyObjectLiteral<def, object, t> : def extends ThunkCast<infer t> ? t : def extends string ? inferString<def, $, args> : def extends array ? inferTuple<def, $, args> : def extends RegExp ? string : def extends object ? inferObjectLiteral<def, $, args> : never;\ntype validateDefinition<def, $, args> = null extends undefined ? ErrorMessage<`'strict' or 'strictNullChecks' must be set to true in your tsconfig's 'compilerOptions'`> : [def] extends [anyOrNever] ? def : def extends OptionalPropertyDefinition ? ErrorMessage<shallowOptionalMessage> : isDefaultable<def, $, args> extends true ? ErrorMessage<shallowDefaultableMessage> : validateInnerDefinition<def, $, args>;\ntype validateInnerDefinition<def, $, args> = [\n    def\n] extends [Terminal] ? def : def extends string ? validateString<def, $, args> : unknown extends def ? BaseCompletions<$, args> | {} : def extends readonly unknown[] ? validateTuple<def, $, args> : def extends BadDefinitionType ? ErrorMessage<writeBadDefinitionTypeMessage<objectKindOrDomainOf<def>>> : validateObjectLiteral<def, $, args>;\ntype validateTuple<def extends array, $, args> = maybeValidateTupleExpression<def, $, args> extends infer result ? result extends null ? validateTupleLiteral<def, $, args> : result : never;\ntype inferTuple<def extends array, $, args> = def extends TupleExpression ? inferTupleExpression<def, $, args> : inferTupleLiteral<def, $, args>;\ntype Terminal = type.cast<unknown> | Fn | RegExp;\ntype ThunkCast<t = unknown> = () => type.cast<t>;\ntype BadDefinitionType = Exclude<Primitive, string>;\ndeclare const writeBadDefinitionTypeMessage: <actual extends string>(actual: actual) => writeBadDefinitionTypeMessage<actual>;\ntype writeBadDefinitionTypeMessage<actual extends string> = `Type definitions must be strings or objects (was ${actual})`;\n\ntype DeclarationParser<$> = <preinferred = unset, ctx extends DeclareContext = {}>() => {\n    type: <const def>(def: [preinferred] extends [unset] ? [\n        preinferred\n    ] extends [anyOrNever] ? validateDeclared<preinferred, def, $, ctx> : ErrorMessage<`declare<ExternalType>() requires a generic argument`> : validateDeclared<preinferred, def, $, ctx>) => Type<finalizePreinferred<preinferred, def, $, ctx>, $>;\n};\ntype finalizePreinferred<preinferred, def, $, ctx extends DeclareContext> = ctx[\"side\"] extends distill.Side ? ctx[\"side\"] extends \"in\" ? (In: preinferred) => type.infer.Out<def, $> : (In: type.infer.In<def, $>) => preinferred : preinferred;\ntype DeclareContext = {\n    side?: \"in\" | \"out\";\n};\ntype validateDeclared<declared, def, $, ctx extends DeclareContext> = def extends type.validate<def, $> ? validateInference<def, declared, $, bindThis<def>, ctx> : type.validate<def, $>;\ntype validateInference<def, declared, $, args, ctx extends DeclareContext> = def extends RegExp | type.cast<unknown> | ThunkCast | TupleExpression ? validateShallowInference<inferDefinition<def, $, args>, declared, ctx> : def extends array ? declared extends array ? {\n    [i in keyof declared]: i extends keyof def ? validateInference<def[i], declared[i], $, args, ctx> : declared[i];\n} : show<declarationMismatch<inferDefinition<def, $, args>, declared>> : def extends object ? show<{\n    [k in requiredKeyOf<declared>]: k extends keyof def ? validateInference<def[k], declared[k], $, args, ctx> : declared[k];\n} & {\n    [k in optionalKeyOf<declared> & string as `${k}?`]: `${k}?` extends (keyof def) ? validateInference<def[`${k}?`], defined<declared[k]>, $, args, ctx> : declared[k];\n}> : validateShallowInference<inferDefinition<def, $, args>, declared, ctx>;\ntype validateShallowInference<t, declared, ctx extends DeclareContext, inferred = ctx[\"side\"] extends distill.Side ? distill<t, ctx[\"side\"]> : t> = equals<inferred, declared> extends true ? unknown : show<declarationMismatch<inferred, declared>>;\ntype declarationMismatch<inferred, declared> = ErrorType<{\n    declared: declared;\n    inferred: inferred;\n}>;\n\ndeclare class MergeHkt extends Hkt<[base: object, props: object]> {\n    body: util.merge<this[0], this[1]>;\n    description: string;\n}\ndeclare const Merge: _ark_schema.GenericRoot<readonly [[\"base\", object], [\"props\", object]], MergeHkt>;\ndeclare const arkBuiltins: arkBuiltins;\ntype arkBuiltins = Module<arkBuiltins.$>;\ndeclare namespace arkBuiltins {\n    type submodule = Submodule<$>;\n    type $ = {\n        Key: Key;\n        Merge: typeof Merge.t;\n    };\n}\n\ndeclare const number: number.module;\ndeclare namespace number {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: number;\n        epoch: number;\n        integer: number;\n        safe: number;\n        NaN: number;\n        Infinity: number;\n        NegativeInfinity: number;\n    };\n}\n\ndeclare const stringInteger: stringInteger.module;\ndeclare namespace stringInteger {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        parse: (In: string) => To<number>;\n    };\n}\ndeclare const base64: Module<{\n    root: unknown;\n    url: unknown;\n}>;\ndeclare namespace base64 {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        url: string;\n    };\n}\ndeclare const capitalize: capitalize.module;\ndeclare namespace capitalize {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: (In: string) => To<string>;\n        preformatted: string;\n    };\n}\ndeclare const stringDate: stringDate.module;\ndeclare namespace stringDate {\n    type module = Module<stringDate.submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        parse: (In: string) => To<Date>;\n        iso: iso.submodule;\n        epoch: epoch.submodule;\n    };\n    namespace iso {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: string;\n            parse: (In: string) => To<Date>;\n        };\n    }\n    namespace epoch {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: string;\n            parse: (In: string) => To<Date>;\n        };\n    }\n}\ndeclare const ip: ip.module;\ndeclare namespace ip {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        v4: string;\n        v6: string;\n    };\n}\ndeclare namespace stringJson {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        parse: (In: string) => To<Json>;\n    };\n}\ndeclare namespace lower {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: (In: string) => To<string>;\n        preformatted: string;\n    };\n}\ndeclare const normalize: Module<{\n    root: unknown;\n    NFC: Submodule<{\n        root: unknown;\n        preformatted: unknown;\n    }>;\n    NFD: Submodule<{\n        root: unknown;\n        preformatted: unknown;\n    }>;\n    NFKC: Submodule<{\n        root: unknown;\n        preformatted: unknown;\n    }>;\n    NFKD: Submodule<{\n        root: unknown;\n        preformatted: unknown;\n    }>;\n}>;\ndeclare namespace normalize {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: (In: string) => To<string>;\n        NFC: NFC.submodule;\n        NFD: NFD.submodule;\n        NFKC: NFKC.submodule;\n        NFKD: NFKD.submodule;\n    };\n    namespace NFC {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: (In: string) => To<string>;\n            preformatted: string;\n        };\n    }\n    namespace NFD {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: (In: string) => To<string>;\n            preformatted: string;\n        };\n    }\n    namespace NFKC {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: (In: string) => To<string>;\n            preformatted: string;\n        };\n    }\n    namespace NFKD {\n        type submodule = Submodule<$>;\n        type $ = {\n            root: (In: string) => To<string>;\n            preformatted: string;\n        };\n    }\n}\ndeclare const stringNumeric: stringNumeric.module;\ndeclare namespace stringNumeric {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        parse: (In: string) => To<number>;\n    };\n}\ndeclare namespace trim {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: (In: string) => To<string>;\n        preformatted: string;\n    };\n}\ndeclare const upper: upper.module;\ndeclare namespace upper {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: (In: string) => To<string>;\n        preformatted: string;\n    };\n}\ndeclare const url: url.module;\ndeclare namespace url {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        parse: (In: string) => To<URL>;\n    };\n}\ndeclare const uuid: Module<{\n    root: string;\n    v1: unknown;\n    v2: unknown;\n    v3: unknown;\n    v4: unknown;\n    v5: unknown;\n    v6: unknown;\n    v7: unknown;\n    v8: unknown;\n}>;\ndeclare namespace uuid {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        v1: string;\n        v2: string;\n        v3: string;\n        v4: string;\n        v5: string;\n        v6: string;\n        v7: string;\n        v8: string;\n    };\n    namespace $ {\n        type flat = {};\n    }\n}\ndeclare const string: Module<{\n    integer: Submodule<stringInteger.submodule>;\n    trim: Submodule<trim.submodule>;\n    normalize: Submodule<{\n        root: unknown;\n        NFC: Submodule<{\n            root: unknown;\n            preformatted: unknown;\n        }>;\n        NFD: Submodule<{\n            root: unknown;\n            preformatted: unknown;\n        }>;\n        NFKC: Submodule<{\n            root: unknown;\n            preformatted: unknown;\n        }>;\n        NFKD: Submodule<{\n            root: unknown;\n            preformatted: unknown;\n        }>;\n    }>;\n    root: unknown;\n    date: Submodule<stringDate.submodule>;\n    email: unknown;\n    uuid: Submodule<{\n        root: string;\n        v1: unknown;\n        v2: unknown;\n        v3: unknown;\n        v4: unknown;\n        v5: unknown;\n        v6: unknown;\n        v7: unknown;\n        v8: unknown;\n    }>;\n    regex: unknown;\n    json: Submodule<stringJson.submodule>;\n    lower: Submodule<lower.submodule>;\n    upper: Submodule<upper.submodule>;\n    alpha: unknown;\n    alphanumeric: unknown;\n    hex: unknown;\n    base64: Submodule<{\n        root: unknown;\n        url: unknown;\n    }>;\n    capitalize: Submodule<capitalize.submodule>;\n    creditCard: unknown;\n    digits: unknown;\n    ip: Submodule<ip.submodule>;\n    numeric: Submodule<stringNumeric.submodule>;\n    semver: unknown;\n    url: Submodule<url.submodule>;\n}>;\ndeclare namespace string {\n    type module = Module<string.submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: string;\n        alpha: string;\n        alphanumeric: string;\n        hex: string;\n        base64: base64.submodule;\n        capitalize: capitalize.submodule;\n        creditCard: string;\n        date: stringDate.submodule;\n        digits: string;\n        email: string;\n        integer: stringInteger.submodule;\n        ip: ip.submodule;\n        json: stringJson.submodule;\n        lower: lower.submodule;\n        normalize: normalize.submodule;\n        numeric: stringNumeric.submodule;\n        regex: string;\n        semver: string;\n        trim: trim.submodule;\n        upper: upper.submodule;\n        url: url.submodule;\n        uuid: uuid.submodule;\n    };\n}\n\ndeclare const arkTsKeywords: arkTsKeywords;\ntype arkTsKeywords = Module<arkTsKeywords.$>;\ndeclare namespace arkTsKeywords {\n    type submodule = Submodule<$>;\n    type $ = {\n        bigint: bigint;\n        boolean: boolean;\n        false: false;\n        never: never;\n        null: null;\n        number: number;\n        object: object;\n        string: string;\n        symbol: symbol;\n        true: true;\n        unknown: unknown;\n        undefined: undefined;\n    };\n}\ndeclare const unknown: Module<{\n    any: unknown;\n    root: unknown;\n}>;\ndeclare namespace unknown {\n    type submodule = Submodule<$>;\n    type $ = {\n        root: unknown;\n        any: any;\n    };\n}\ndeclare const json: Module<{\n    stringify: unknown;\n    root: unknown;\n}>;\ndeclare namespace json {\n    type submodule = Submodule<$>;\n    type $ = {\n        root: Json;\n        stringify: (In: Json) => To<string>;\n    };\n}\ndeclare const object: Module<{\n    root: unknown;\n    json: Submodule<{\n        stringify: unknown;\n        root: unknown;\n    }>;\n}>;\ndeclare namespace object {\n    type submodule = Submodule<$>;\n    type $ = {\n        root: object;\n        json: json.submodule;\n    };\n}\ndeclare class RecordHkt extends Hkt<[Key, unknown]> {\n    body: Record<this[0], this[1]>;\n    description: string;\n}\ndeclare const Record: _ark_schema.GenericRoot<readonly [[\"K\", Key], [\"V\", unknown]], RecordHkt>;\ndeclare class PickHkt extends Hkt<[object, Key]> {\n    body: pick<this[0], this[1] & keyof this[0]>;\n    description: string;\n}\ndeclare const Pick: _ark_schema.GenericRoot<readonly [[\"T\", object], [\"K\", Key]], PickHkt>;\ndeclare class OmitHkt extends Hkt<[object, Key]> {\n    body: omit<this[0], this[1] & keyof this[0]>;\n    description: string;\n}\ndeclare const Omit: _ark_schema.GenericRoot<readonly [[\"T\", object], [\"K\", Key]], OmitHkt>;\ndeclare class PartialHkt extends Hkt<[object]> {\n    body: show<Partial<this[0]>>;\n    description: string;\n}\ndeclare const Partial: _ark_schema.GenericRoot<readonly [[\"T\", object]], PartialHkt>;\ndeclare class RequiredHkt extends Hkt<[object]> {\n    body: show<Required<this[0]>>;\n    description: string;\n}\ndeclare const Required: _ark_schema.GenericRoot<readonly [[\"T\", object]], RequiredHkt>;\ndeclare class ExcludeHkt extends Hkt<[unknown, unknown]> {\n    body: Exclude<this[0], this[1]>;\n    description: string;\n}\ndeclare const Exclude: _ark_schema.GenericRoot<readonly [[\"T\", unknown], [\"U\", unknown]], ExcludeHkt>;\ndeclare class ExtractHkt extends Hkt<[unknown, unknown]> {\n    body: Extract<this[0], this[1]>;\n    description: string;\n}\ndeclare const Extract: _ark_schema.GenericRoot<readonly [[\"T\", unknown], [\"U\", unknown]], ExtractHkt>;\ndeclare const arkTsGenerics: arkTsGenerics.module;\ndeclare namespace arkTsGenerics {\n    type module = Module<arkTsGenerics.$>;\n    type submodule = Submodule<$>;\n    type $ = {\n        Exclude: typeof Exclude.t;\n        Extract: typeof Extract.t;\n        Omit: typeof Omit.t;\n        Partial: typeof Partial.t;\n        Pick: typeof Pick.t;\n        Record: typeof Record.t;\n        Required: typeof Required.t;\n    };\n}\n\ninterface Ark extends Omit<Ark.keywords, keyof Ark.wrapped>, Ark.wrapped {\n}\ndeclare namespace Ark {\n    interface keywords extends arkTsKeywords.$, arkTsGenerics.$, arkPrototypes.keywords, arkBuiltins.$ {\n    }\n    interface wrapped extends arkPrototypes.wrapped {\n        string: string.submodule;\n        number: number.submodule;\n        object: object.submodule;\n        unknown: unknown.submodule;\n    }\n    type flat = flatResolutionsOf<Ark>;\n    interface typeAttachments extends arkTsKeywords.$ {\n        arrayIndex: arkPrototypes.$[\"Array\"][\"index\"];\n        Key: arkBuiltins.$[\"Key\"];\n        Record: arkTsGenerics.$[\"Record\"];\n        Date: arkPrototypes.$[\"Date\"];\n        Array: arkPrototypes.$[\"Array\"][\"root\"];\n    }\n    interface boundTypeAttachments<$> extends Omit<BoundModule<typeAttachments, $>, arkKind> {\n    }\n}\ndeclare const ark: Scope<Ark>;\ndeclare const keywords: Module<Ark>;\ndeclare const type: TypeParser<{}>;\ndeclare namespace type {\n    interface cast<to> {\n        [inferred]?: to;\n    }\n    type errors = ArkErrors;\n    type validate<def, $ = {}, args = bindThis<def>> = validateDefinition<def, $, args>;\n    type instantiate<def, $ = {}, args = bindThis<def>> = instantiateType<inferDefinition<def, $, args>, $>;\n    type infer<def, $ = {}, args = bindThis<def>> = inferDefinition<def, $, args>;\n    namespace infer {\n        type In<def, $ = {}, args = {}> = distill.In<inferDefinition<def, $, args>>;\n        type Out<def, $ = {}, args = {}> = distill.Out<inferDefinition<def, $, args>>;\n        namespace introspectable {\n            type Out<def, $ = {}, args = {}> = distill.introspectable.Out<inferDefinition<def, $, args>>;\n        }\n    }\n    type brand<t, id> = t extends InferredMorph<infer i, infer o> ? o[\"introspectable\"] extends true ? (In: i) => To<Brand<o[\"t\"], id>> : (In: i) => Out<Brand<o[\"t\"], id>> : Brand<t, id>;\n    /** @ts-ignore cast variance */\n    interface Any<out t = any, $ = any> extends Type$1<t, $> {\n    }\n}\ntype type<t = unknown, $ = {}> = Type<t, $>;\ndeclare const match: MatchParser<{}>;\ndeclare const generic: GenericParser<{}>;\ndeclare const define: DefinitionParser<{}>;\ndeclare const declare: DeclarationParser<{}>;\n\ntype ParameterString<params extends string = string> = `<${params}>`;\ntype extractParams<s extends ParameterString> = s extends ParameterString<infer params> ? params : never;\ntype validateParameterString<s extends ParameterString, $> = parseGenericParams<extractParams<s>, $> extends infer e extends ErrorMessage ? e : s;\ntype validateGenericArg<arg, param extends GenericParamAst, $> = type.infer<arg, $> extends param[1] ? unknown : ErrorType<[`Invalid argument for ${param[0]}`, expected: param[1]]>;\ntype GenericInstantiator<params extends array<GenericParamAst>, def, $, args$> = params[\"length\"] extends 1 ? {\n    <const a, r = instantiateGeneric<def, params, [a], $, args$>>(a: type.validate<a, args$> & validateGenericArg<a, params[0], args$>): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 2 ? {\n    <const a, const b, r = instantiateGeneric<def, params, [a, b], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 3 ? {\n    <const a, const b, const c, r = instantiateGeneric<def, params, [a, b, c], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 4 ? {\n    <const a, const b, const c, const d, r = instantiateGeneric<def, params, [a, b, c, d], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>,\n        type.validate<d, args$> & validateGenericArg<d, params[3], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 5 ? {\n    <const a, const b, const c, const d, const e, r = instantiateGeneric<def, params, [a, b, c, d, e], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>,\n        type.validate<d, args$> & validateGenericArg<d, params[3], args$>,\n        type.validate<e, args$> & validateGenericArg<e, params[4], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 6 ? {\n    <const a, const b, const c, const d, const e, const f, r = instantiateGeneric<def, params, [a, b, c, d, e, f], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>,\n        type.validate<d, args$> & validateGenericArg<d, params[3], args$>,\n        type.validate<e, args$> & validateGenericArg<e, params[4], args$>,\n        type.validate<f, args$> & validateGenericArg<f, params[5], args$>\n    ]): r extends infer _ ? _ : never;\n} : (error: ErrorMessage<`You may not define more than 6 positional generic parameters`>) => never;\ntype instantiateGeneric<def, params extends array<GenericParamAst>, args, $, args$> = Type<[\n    def\n] extends [Hkt] ? Hkt.apply<def, {\n    [i in keyof args]: type.infer<args[i], args$>;\n}> : inferDefinition<def, $, bindGenericArgs<params, args$, args>>, args$>;\ntype bindGenericArgs<params extends array<GenericParamAst>, $, args> = {\n    [i in keyof params & `${number}` as params[i][0]]: type.infer<args[i & keyof args], $>;\n};\ntype baseGenericResolutions<params extends array<GenericParamAst>, $> = baseGenericConstraints<params> extends infer baseConstraints ? {\n    [k in keyof baseConstraints]: Type<baseConstraints[k], $>;\n} : never;\ntype baseGenericConstraints<params extends array<GenericParamAst>> = {\n    [i in keyof params & `${number}` as params[i][0]]: params[i][1];\n};\ntype GenericConstructor<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown, $ = {}, arg$ = {}> = new () => Generic<params, bodyDef, $, arg$>;\ninterface Generic<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown, $ = {}, arg$ = $> extends Callable<GenericInstantiator<params, bodyDef, $, arg$>> {\n    [arkKind]: \"generic\";\n    t: GenericAst<params, bodyDef, $, arg$>;\n    bodyDef: bodyDef;\n    params: {\n        [i in keyof params]: [params[i][0], Type<params[i][1], $>];\n    };\n    names: genericParamNames<params>;\n    constraints: {\n        [i in keyof params]: Type<params[i][1], $>;\n    };\n    $: Scope<$>;\n    arg$: Scope<arg$>;\n    internal: GenericRoot;\n    json: JsonStructure;\n}\ndeclare const Generic: GenericConstructor;\ntype GenericDeclaration<name extends string = string, params extends ParameterString = ParameterString> = `${name}${params}`;\ntype parseValidGenericParams<def extends ParameterString, $> = conform<parseGenericParams<extractParams<def>, $>, array<GenericParamAst>>;\ndeclare const emptyGenericParameterMessage = \"An empty string is not a valid generic parameter name\";\ntype emptyGenericParameterMessage = typeof emptyGenericParameterMessage;\ntype parseGenericParams<def extends string, $> = parseNextNameChar<Scanner.skipWhitespace<def>, \"\", [\n], $>;\ntype ParamsTerminator = WhitespaceChar | \",\";\ntype parseName<unscanned extends string, result extends array<GenericParamAst>, $> = parseNextNameChar<Scanner.skipWhitespace<unscanned>, \"\", result, $>;\ntype parseNextNameChar<unscanned extends string, name extends string, result extends array<GenericParamAst>, $> = unscanned extends `${infer lookahead}${infer nextUnscanned}` ? lookahead extends ParamsTerminator ? name extends \"\" ? ErrorMessage<emptyGenericParameterMessage> : lookahead extends \",\" ? parseName<nextUnscanned, [...result, [name, unknown]], $> : lookahead extends WhitespaceChar ? _parseOptionalConstraint<nextUnscanned, name, result, $> : never : parseNextNameChar<nextUnscanned, `${name}${lookahead}`, result, $> : name extends \"\" ? result : [...result, [name, unknown]];\ndeclare const extendsToken = \"extends \";\ntype extendsToken = typeof extendsToken;\ndeclare const _parseOptionalConstraint: (scanner: Scanner, name: string, result: GenericParamDef[], ctx: BaseParseContext) => GenericParamDef[];\ntype _parseOptionalConstraint<unscanned extends string, name extends string, result extends array<GenericParamAst>, $> = Scanner.skipWhitespace<unscanned> extends (`${extendsToken}${infer nextUnscanned}`) ? parseUntilFinalizer<s.initialize<nextUnscanned>, $, {}> extends (infer finalArgState extends StaticState) ? validateAst<finalArgState[\"root\"], $, {}> extends (infer e extends ErrorMessage) ? e : parseName<finalArgState[\"unscanned\"], [\n    ...result,\n    [name, inferAstRoot<finalArgState[\"root\"], $, {}>]\n], $> : never : parseName<Scanner.skipWhitespace<unscanned> extends `,${infer nextUnscanned}` ? nextUnscanned : unscanned, [\n    ...result,\n    [name, unknown]\n], $>;\ntype genericParamDefToAst<schema extends GenericParamDef, $> = schema extends string ? [schema, unknown] : schema extends readonly [infer name, infer def] ? [name, type.infer<def, $>] : never;\ntype genericParamDefsToAst<defs extends array<GenericParamDef>, $> = [\n    ...{\n        [i in keyof defs]: genericParamDefToAst<defs[i], $>;\n    }\n];\ntype GenericParser<$ = {}> = <const paramsDef extends array<GenericParamDef>>(...params: {\n    [i in keyof paramsDef]: paramsDef[i] extends (readonly [infer name, infer def]) ? readonly [name, type.validate<def, $>] : paramsDef[i];\n}) => GenericBodyParser<genericParamDefsToAst<paramsDef, $>, $>;\ninterface GenericBodyParser<params extends array<GenericParamAst>, $> {\n    <const body>(body: type.validate<body, $, baseGenericConstraints<params>>): Generic<params, body, $, $>;\n    <hkt extends Hkt.constructor>(instantiateDef: LazyGenericBody<baseGenericResolutions<params, $>>, hkt: hkt): Generic<params, InstanceType<hkt>, $, $>;\n}\n\ndeclare const Module: new <$ extends {}>(exports: exportScope<$>) => Module<$>;\ninterface Module<$ extends {} = {}> extends RootModule<exportScope<$>> {\n}\ntype exportScope<$> = bindExportsToScope<$, $>;\ndeclare const BoundModule: new <exports extends {}, $ extends {}>(exports: bindExportsToScope<exports, $>, $: $) => BoundModule<exports, $>;\ninterface BoundModule<exports extends {}, $> extends RootModule<bindExportsToScope<exports, $>> {\n}\ntype bindExportsToScope<exports, $> = {\n    [k in keyof exports]: instantiateExport<exports[k], $>;\n} & unknown;\ntype Submodule<exports extends {}> = RootModule<exports & (\"root\" extends keyof exports ? {\n    [inferred]: exports[\"root\"];\n} : {})>;\ntype instantiateExport<t, $> = [\n    t\n] extends [PreparsedNodeResolution] ? [\n    t\n] extends [anyOrNever] ? Type<t, $> : t extends GenericAst<infer params, infer body, infer body$> ? Generic<params, body, body$, $> : t extends Submodule<infer exports> ? BoundModule<exports, $> : never : Type<t, $>;\n\ndeclare class liftFromHkt extends Hkt<[element: unknown]> {\n    body: liftArray<this[0]> extends infer lifted ? (In: this[0] | lifted) => To<lifted> : never;\n}\ndeclare const liftFrom: _ark_schema.GenericRoot<readonly [[\"element\", unknown]], liftFromHkt>;\ndeclare const arkArray: arkArray.module;\ndeclare namespace arkArray {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: unknown[];\n        readonly: readonly unknown[];\n        index: NonNegativeIntegerString;\n        liftFrom: typeof liftFrom.t;\n    };\n}\ntype NonNegativeIntegerString = `${Digit}` | (`${Exclude<Digit, 0>}${string}` & `${bigint}`);\n\ntype FormDataValue = string | File;\ntype ParsedFormData = Record<string, FormDataValue | FormDataValue[]>;\ndeclare const arkFormData: arkFormData.module;\ndeclare namespace arkFormData {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    type $ = {\n        root: FormData;\n        value: FormDataValue;\n        parse: (In: FormData) => To<ParsedFormData>;\n        parsed: ParsedFormData;\n    };\n}\n\ndeclare const TypedArray: TypedArray.module;\ndeclare namespace TypedArray {\n    type module = Module<TypedArray.$>;\n    type submodule = Submodule<$>;\n    type $ = {\n        Int8: Int8Array;\n        Uint8: Uint8Array;\n        Uint8Clamped: Uint8ClampedArray;\n        Int16: Int16Array;\n        Uint16: Uint16Array;\n        Int32: Int32Array;\n        Uint32: Uint32Array;\n        Float32: Float32Array;\n        Float64: Float64Array;\n        BigInt64: BigInt64Array;\n        BigUint64: BigUint64Array;\n    };\n}\n\ndeclare const omittedPrototypes: {\n    Boolean: 1;\n    Number: 1;\n    String: 1;\n};\ndeclare const arkPrototypes: arkPrototypes.module;\ndeclare namespace arkPrototypes {\n    type module = Module<submodule>;\n    type submodule = Submodule<$>;\n    interface keywords extends ecmascript, platform {\n    }\n    interface $ extends Omit<keywords, keyof wrapped>, wrapped {\n    }\n    interface wrapped {\n        Array: arkArray.submodule;\n        TypedArray: TypedArray.submodule;\n        FormData: arkFormData.submodule;\n    }\n    type ecmascript = Omit<EcmascriptObjects, keyof typeof omittedPrototypes>;\n    type platform = PlatformObjects;\n    interface instances extends ecmascript, platform {\n    }\n    type NonDegenerateName = keyof instances extends infer k ? k extends keyof instances ? {} extends instances[k] ? never : k : never : never;\n    type instanceOf<name extends NonDegenerateName = NonDegenerateName> = instances[name];\n}\n\ntype DateLiteral<source extends string = string> = `d\"${source}\"` | `d'${source}'`;\ntype LimitLiteral = number | DateLiteral;\ntype distill<t, side extends distill.Side> = finalizeDistillation<t, _distill<t, side>>;\ndeclare namespace distill {\n    type Side = \"in\" | \"out\" | \"introspectableOut\";\n    type In<t> = distill<t, \"in\">;\n    type Out<t> = distill<t, \"out\">;\n    namespace introspectable {\n        type Out<t> = distill<t, \"introspectableOut\">;\n    }\n}\ntype finalizeDistillation<t, distilled> = equals<t, distilled> extends true ? t : distilled;\ntype _distill<t, side extends distill.Side> = t extends undefined ? t : [t] extends [anyOrNever] ? t : unknown extends t ? unknown : t extends Brand<infer base> ? side extends \"in\" ? base : t : t extends TerminallyInferredObject | Primitive ? t : t extends Function ? t extends (...args: never) => anyOrNever ? t : t extends InferredMorph<infer i, infer o> ? distillIo<i, o, side> : t : t extends Default<infer constraint> ? _distill<constraint, side> : t extends array ? distillArray<t, side> : isSafelyMappable<t> extends true ? distillMappable<t, side> : t;\ntype distillMappable<o, side extends distill.Side> = side extends \"in\" ? show<{\n    [k in keyof o as k extends inferredDefaultKeyOf<o> ? never : k]: _distill<o[k], side>;\n} & {\n    [k in inferredDefaultKeyOf<o>]?: _distill<o[k], side>;\n}> : {\n    [k in keyof o]: _distill<o[k], side>;\n};\ntype distillIo<i, o extends Out, side extends distill.Side> = side extends \"out\" ? _distill<o[\"t\"], side> : side extends \"in\" ? _distill<i, side> : o extends To<infer validatedOut> ? _distill<validatedOut, side> : unknown;\ntype unwrapInput<t> = t extends InferredMorph<infer i> ? t extends anyOrNever ? t : i : t;\ntype inferredDefaultKeyOf<o> = keyof o extends infer k ? k extends keyof o ? unwrapInput<o[k]> extends Default<infer t> ? [\n    t\n] extends [anyOrNever] ? never : k : never : never : never;\ntype distillArray<t extends array, side extends distill.Side> = t[number][] extends t ? alignReadonly<_distill<t[number], side>[], t> : distillNonArraykeys<t, alignReadonly<distillArrayFromPrefix<[...t], side, []>, t>, side>;\ntype alignReadonly<result extends unknown[], original extends array> = original extends unknown[] ? result : Readonly<result>;\ntype distillNonArraykeys<originalArray extends array, distilledArray, side extends distill.Side> = keyof originalArray extends keyof distilledArray ? distilledArray : distilledArray & _distill<{\n    [k in keyof originalArray as k extends keyof distilledArray ? never : k]: originalArray[k];\n}, side>;\ntype distillArrayFromPrefix<t extends array, side extends distill.Side, prefix extends array> = t extends readonly [infer head, ...infer tail] ? distillArrayFromPrefix<tail, side, [\n    side,\n    head\n] extends [\"in\", Default] ? [...prefix, _distill<head, side>?] : [...prefix, _distill<head, side>]> : [...prefix, ...distillArrayFromPostfix<t, side, []>];\ntype distillArrayFromPostfix<t extends array, side extends distill.Side, postfix extends array> = t extends readonly [...infer init, infer last] ? distillArrayFromPostfix<init, side, [_distill<last, side>, ...postfix]> : [...{\n    [i in keyof t]: _distill<t[i], side>;\n}, ...postfix];\ntype BuiltinTerminalObjectKind = Exclude<arkPrototypes.NonDegenerateName, \"Array\" | \"Function\">;\n/** Objects we don't want to expand during inference like Date or Promise */\ntype TerminallyInferredObject = arkPrototypes.instanceOf<BuiltinTerminalObjectKind> | ArkEnv.prototypes;\ntype inferPredicate<t, predicate> = predicate extends (data: any, ...args: any[]) => data is infer narrowed ? narrowed : t;\ntype inferNaryPipe<morphs extends readonly Morph[]> = _inferNaryPipe<morphs, unknown>;\ntype _inferNaryPipe<remaining extends readonly unknown[], result> = remaining extends (readonly [infer head extends Morph, ...infer tail extends Morph[]]) ? _inferNaryPipe<tail, inferMorph<result, head>> : result;\ntype inferNaryIntersection<types extends readonly unknown[]> = number extends types[\"length\"] ? _inferNaryIntersection<unionToTuple<types[number]>, unknown> : _inferNaryIntersection<types, unknown>;\ntype _inferNaryIntersection<remaining extends readonly unknown[], result> = remaining extends readonly [infer head, ...infer tail] ? _inferNaryIntersection<tail, inferIntersection<result, head>> : result;\ntype inferNaryMerge<types extends readonly unknown[]> = number extends types[\"length\"] ? _inferUnorderedMerge<types> : _inferNaryMerge<types, {}>;\ntype _inferUnorderedMerge<types extends readonly unknown[], optionalKey extends PropertyKey = optionalAtLeastOnceUnionKeyOf<types[number]>, requiredKey extends PropertyKey = Exclude<unionKeyOf<types[number]>, optionalKey>> = show<{\n    [k in requiredKey]: types[number] extends infer v ? v extends unknown ? k extends keyof v ? v[k] : never : never : never;\n} & {\n    [k in optionalKey]?: types[number] extends infer v ? v extends unknown ? k extends keyof v ? v[k] : never : never : never;\n}>;\n/** Coalesce keys that exist and are optional on one or more branches of a union */\ntype optionalAtLeastOnceUnionKeyOf<t> = t extends unknown ? optionalKeyOf<t> : never;\ntype _inferNaryMerge<remaining extends readonly unknown[], result> = remaining extends (readonly [infer head, ...infer tail extends readonly unknown[]]) ? _inferNaryMerge<tail, merge<result, head>> : result;\ntype inferMorphOut<morph extends Morph> = Exclude<ReturnType<morph>, ArkError | ArkErrors>;\ndeclare const isMorphOutKey: \" isMorphOut\";\ninterface Out<o = any> {\n    [isMorphOutKey]: true;\n    t: o;\n    introspectable: boolean;\n}\ninterface To<o = any> extends Out<o> {\n    introspectable: true;\n}\ntype InferredMorph<i = never, o extends Out = Out> = (In: i) => o;\ndeclare const defaultsToKey: \" defaultsTo\";\ntype Default<t = unknown, v = unknown> = {\n    [defaultsToKey]: [t, v];\n};\ntype withDefault<t, v, undistributed = t> = t extends InferredMorph ? addDefaultToMorph<t, v> : Default<Exclude<undistributed, InferredMorph>, v>;\ntype addDefaultToMorph<t extends InferredMorph, v> = [\n    normalizeMorphDistribution<t>\n] extends [InferredMorph<infer i, infer o>] ? (In: Default<i, v>) => o : never;\ntype normalizeMorphDistribution<t, undistributedIn = t extends InferredMorph<infer i> ? i : never, undistributedOut extends Out = t extends InferredMorph<never, infer o> ? [\n    o\n] extends [To<infer unwrappedOut>] ? To<unwrappedOut> : o : never> = (Extract<t, InferredMorph> extends anyOrNever ? never : Extract<t, InferredMorph> extends InferredMorph<infer i, infer o> ? [\n    undistributedOut\n] extends [o] ? (In: undistributedIn) => undistributedOut : [undistributedIn] extends [i] ? (In: undistributedIn) => undistributedOut : t : never) | Exclude<t, InferredMorph> extends infer _ ? _ : never;\ntype defaultFor<t = unknown> = (Primitive extends t ? Primitive : t extends Primitive ? t : never) | (() => t);\ntype inferIntersection<l, r> = normalizeMorphDistribution<_inferIntersection<l, r, false>>;\ntype inferMorph<t, morph extends Morph> = morph extends type.cast<infer tMorph> ? inferPipe<t, tMorph> : inferMorphOut<morph> extends infer out ? (In: distill.In<t>) => Out<out> : never;\ntype inferPipe<l, r> = normalizeMorphDistribution<_inferIntersection<l, r, true>>;\ntype _inferIntersection<l, r, piped extends boolean> = [\n    l & r\n] extends [infer t extends anyOrNever] ? t : l extends InferredMorph<infer lIn, infer lOut> ? r extends InferredMorph<never, infer rOut> ? piped extends true ? (In: lIn) => rOut : never : piped extends true ? (In: lIn) => To<r> : (In: _inferIntersection<lIn, r, false>) => lOut : r extends InferredMorph<infer rIn, infer rOut> ? (In: _inferIntersection<rIn, l, false>) => rOut : [l, r] extends [object, object] ? intersectObjects<l, r, piped> extends infer result ? result : never : l & r;\ninterface MorphableIntersection<piped extends boolean> extends Hkt<[unknown, unknown]> {\n    body: _inferIntersection<this[0], this[1], piped>;\n}\ntype intersectObjects<l, r, piped extends boolean> = l extends array ? r extends array ? intersectArrays<l, r, MorphableIntersection<piped>> : // for an intersection with exactly one array operand like { name: string } & string[],\nl & r : r extends array ? l & r : keyof l & keyof r extends never ? show<l & r> : show<{\n    [k in keyof l]: k extends keyof r ? _inferIntersection<l[k], r[k], piped> : l[k];\n} & {\n    [k in keyof r]: k extends keyof l ? _inferIntersection<l[k], r[k], piped> : r[k];\n}>;\n\nexport { Ark, ArkAmbient, type ArkConfig, type Type$1 as BaseType, BoundModule, Generic, type KeywordConfig, Module, type Out, Scope, type Submodule, Type, ark, type bindThis, configure, declare, define, distill, generic, type inferDefinition, keywords, match, scope, type, type validateDefinition };\n\n}"
