/** THIS FILE IS AUTOGENERATED FROM ark/repo/dtsGen.ts **/
// prettier-ignore
export const utilDts = "declare module \"@ark/util\" {\n    import * as buffer from 'buffer';\n\ntype Fn<args extends readonly any[] = readonly any[], returns = unknown> = (...args: args) => returns;\ndeclare const cached: <t>(thunk: () => t) => (() => t);\ndeclare const isThunk: <value>(value: value) => value is Extract<value, Thunk> extends never ? value & Thunk : Extract<value, Thunk>;\ntype Thunk<ret = unknown> = () => ret;\ntype thunkable<t> = t | Thunk<t>;\ndeclare const tryCatch: <returns, onError = never>(fn: () => returns, onError?: (e: unknown) => onError) => returns | onError;\ndeclare const DynamicFunction: DynamicFunction;\ntype DynamicFunction = new <fn extends Fn>(...args: ConstructorParameters<typeof Function>) => fn & {\n    apply(thisArg: null, args: Parameters<fn>): ReturnType<fn>;\n    call(thisArg: null, ...args: Parameters<fn>): ReturnType<fn>;\n};\ntype CallableOptions<attachments extends object> = {\n    attach?: attachments;\n    bind?: object;\n};\n/** @ts-ignore required to cast function type */\ninterface Callable<fn extends Fn, attachments extends object> extends fn, attachments {\n}\ndeclare class Callable<fn extends Fn, attachments extends object = {}> {\n    constructor(fn: fn, ...[opts]: {} extends attachments ? [opts?: CallableOptions<attachments>] : [opts: CallableOptions<attachments>]);\n}\ntype GuardablePredicate<input = unknown, narrowed extends input = input> = ((In: input) => In is narrowed) | ((In: input) => boolean);\ntype TypeGuard<input = unknown, narrowed extends input = input> = (In: input) => In is narrowed;\n/**\n * Checks if the environment has Content Security Policy (CSP) enabled,\n * preventing JIT-optimized code from being compiled via new Function().\n *\n * @returns `true` if a function created using new Function() can be\n * successfully invoked in the environment, `false` otherwise.\n *\n * The result is cached for subsequent invocations.\n */\ndeclare const envHasCsp: () => boolean;\n\ndeclare const ecmascriptConstructors: {\n    Array: ArrayConstructor;\n    Boolean: BooleanConstructor;\n    Date: DateConstructor;\n    Error: ErrorConstructor;\n    Function: FunctionConstructor;\n    Map: MapConstructor;\n    Number: NumberConstructor;\n    Promise: PromiseConstructor;\n    RegExp: RegExpConstructor;\n    Set: SetConstructor;\n    String: StringConstructor;\n    WeakMap: WeakMapConstructor;\n    WeakSet: WeakSetConstructor;\n};\ntype ecmascriptConstructors = typeof ecmascriptConstructors;\ntype EcmascriptObjects = satisfy<instantiateConstructors<keyof ecmascriptConstructors>, {\n    Array: Array<unknown>;\n    Boolean: Boolean;\n    Date: Date;\n    Error: Error;\n    Function: Function;\n    Map: Map<unknown, unknown>;\n    Number: Number;\n    RegExp: RegExp;\n    Set: Set<unknown>;\n    String: String;\n    WeakMap: WeakMap<object, unknown>;\n    WeakSet: WeakSet<object>;\n    Promise: Promise<unknown>;\n}>;\n/** Node18 */\ndeclare const FileConstructor: typeof buffer.File;\ntype platformConstructors = {\n    ArrayBuffer: ArrayBufferConstructor;\n    Blob: typeof Blob;\n    File: typeof File;\n    FormData: typeof FormData;\n    Headers: typeof Headers;\n    Request: typeof Request;\n    Response: typeof Response;\n    URL: typeof URL;\n};\ndeclare const platformConstructors: platformConstructors;\ntype PlatformObjects = instantiateConstructors<keyof platformConstructors>;\ndeclare const typedArrayConstructors: {\n    Int8Array: Int8ArrayConstructor;\n    Uint8Array: Uint8ArrayConstructor;\n    Uint8ClampedArray: Uint8ClampedArrayConstructor;\n    Int16Array: Int16ArrayConstructor;\n    Uint16Array: Uint16ArrayConstructor;\n    Int32Array: Int32ArrayConstructor;\n    Uint32Array: Uint32ArrayConstructor;\n    Float32Array: Float32ArrayConstructor;\n    Float64Array: Float64ArrayConstructor;\n    BigInt64Array: BigInt64ArrayConstructor;\n    BigUint64Array: BigUint64ArrayConstructor;\n};\ntype typedArrayConstructors = typeof typedArrayConstructors;\ntype TypedArrayObjects = instantiateConstructors<keyof typedArrayConstructors>;\ndeclare const builtinConstructors: {\n    String: StringConstructor;\n    Number: NumberConstructor;\n    Boolean: BooleanConstructor;\n    Int8Array: Int8ArrayConstructor;\n    Uint8Array: Uint8ArrayConstructor;\n    Uint8ClampedArray: Uint8ClampedArrayConstructor;\n    Int16Array: Int16ArrayConstructor;\n    Uint16Array: Uint16ArrayConstructor;\n    Int32Array: Int32ArrayConstructor;\n    Uint32Array: Uint32ArrayConstructor;\n    Float32Array: Float32ArrayConstructor;\n    Float64Array: Float64ArrayConstructor;\n    BigInt64Array: BigInt64ArrayConstructor;\n    BigUint64Array: BigUint64ArrayConstructor;\n    ArrayBuffer: ArrayBufferConstructor;\n    Blob: typeof Blob;\n    File: typeof File;\n    FormData: typeof FormData;\n    Headers: typeof Headers;\n    Request: typeof Request;\n    Response: typeof Response;\n    URL: typeof URL;\n    Array: ArrayConstructor;\n    Date: DateConstructor;\n    Error: ErrorConstructor;\n    Function: FunctionConstructor;\n    Map: MapConstructor;\n    Promise: PromiseConstructor;\n    RegExp: RegExpConstructor;\n    Set: SetConstructor;\n    WeakMap: WeakMapConstructor;\n    WeakSet: WeakSetConstructor;\n};\ntype builtinConstructors = typeof builtinConstructors;\ntype BuiltinObjectKind = keyof builtinConstructors;\ntype GlobalName = keyof typeof globalThis;\ntype instantiateConstructors<kind extends BuiltinObjectKind> = {\n    [k in kind]: k extends GlobalName ? InstanceType<(typeof globalThis)[k]> : `${k}Constructor` extends GlobalName ? InstanceType<(typeof globalThis)[`${k}Constructor`]> : never;\n};\ntype BuiltinObjects = instantiateConstructors<BuiltinObjectKind>;\ntype describeObject<o extends object, opts extends DescribeOptions = {}> = objectKindOf<o> extends string ? [\n    opts[\"includeArticles\"]\n] extends [true] ? objectKindDescriptions[objectKindOf<o>] : objectKindOf<o> : [opts[\"includeArticles\"]] extends [true] ? domainDescriptions[\"object\"] : \"object\";\ntype instantiableObjectKind<data extends object> = {\n    [kind in keyof builtinConstructors]: data extends (InstanceType<builtinConstructors[kind]>) ? kind : never;\n}[keyof builtinConstructors];\ntype objectKindOf<data extends object> = object extends data ? keyof builtinConstructors | undefined : data extends Fn ? \"Function\" : instantiableObjectKind<data> extends never ? undefined : instantiableObjectKind<data>;\ndeclare const objectKindOf: <data extends object>(data: data) => objectKindOf<data> | undefined;\ndeclare const objectKindOrDomainOf: <data>(data: data) => (objectKindOf<data & object> & {}) | domainOf<data>;\ntype objectKindOrDomainOf<data> = data extends object ? objectKindOf<data> extends undefined ? \"object\" : objectKindOf<data> : domainOf<data>;\ndeclare const hasObjectKind: <kind extends keyof builtinConstructors>(data: object, kind: kind) => data is InstanceType<builtinConstructors[kind]>;\ndeclare const isArray: (data: unknown) => data is readonly unknown[];\ndeclare const ecmascriptDescriptions: {\n    readonly Array: \"an array\";\n    readonly Function: \"a function\";\n    readonly Date: \"a Date\";\n    readonly RegExp: \"a RegExp\";\n    readonly Error: \"an Error\";\n    readonly Map: \"a Map\";\n    readonly Set: \"a Set\";\n    readonly String: \"a String object\";\n    readonly Number: \"a Number object\";\n    readonly Boolean: \"a Boolean object\";\n    readonly Promise: \"a Promise\";\n    readonly WeakMap: \"a WeakMap\";\n    readonly WeakSet: \"a WeakSet\";\n};\ndeclare const platformDescriptions: {\n    ArrayBuffer: string;\n    Blob: string;\n    File: string;\n    FormData: string;\n    Headers: string;\n    Request: string;\n    Response: string;\n    URL: string;\n};\ndeclare const typedArrayDescriptions: {\n    readonly Int8Array: \"an Int8Array\";\n    readonly Uint8Array: \"a Uint8Array\";\n    readonly Uint8ClampedArray: \"a Uint8ClampedArray\";\n    readonly Int16Array: \"an Int16Array\";\n    readonly Uint16Array: \"a Uint16Array\";\n    readonly Int32Array: \"an Int32Array\";\n    readonly Uint32Array: \"a Uint32Array\";\n    readonly Float32Array: \"a Float32Array\";\n    readonly Float64Array: \"a Float64Array\";\n    readonly BigInt64Array: \"a BigInt64Array\";\n    readonly BigUint64Array: \"a BigUint64Array\";\n};\n/** Each defaultObjectKind's completion for the phrase \"must be _____\" */\ndeclare const objectKindDescriptions: {\n    readonly Int8Array: \"an Int8Array\";\n    readonly Uint8Array: \"a Uint8Array\";\n    readonly Uint8ClampedArray: \"a Uint8ClampedArray\";\n    readonly Int16Array: \"an Int16Array\";\n    readonly Uint16Array: \"a Uint16Array\";\n    readonly Int32Array: \"an Int32Array\";\n    readonly Uint32Array: \"a Uint32Array\";\n    readonly Float32Array: \"a Float32Array\";\n    readonly Float64Array: \"a Float64Array\";\n    readonly BigInt64Array: \"a BigInt64Array\";\n    readonly BigUint64Array: \"a BigUint64Array\";\n    readonly ArrayBuffer: string;\n    readonly Blob: string;\n    readonly File: string;\n    readonly FormData: string;\n    readonly Headers: string;\n    readonly Request: string;\n    readonly Response: string;\n    readonly URL: string;\n    readonly Array: \"an array\";\n    readonly Function: \"a function\";\n    readonly Date: \"a Date\";\n    readonly RegExp: \"a RegExp\";\n    readonly Error: \"an Error\";\n    readonly Map: \"a Map\";\n    readonly Set: \"a Set\";\n    readonly String: \"a String object\";\n    readonly Number: \"a Number object\";\n    readonly Boolean: \"a Boolean object\";\n    readonly Promise: \"a Promise\";\n    readonly WeakMap: \"a WeakMap\";\n    readonly WeakSet: \"a WeakSet\";\n};\ntype objectKindDescriptions = typeof objectKindDescriptions;\n/**\n * this will only return an object kind if it's the root constructor\n * example TypeError would return null not 'Error'\n **/\ndeclare const getBuiltinNameOfConstructor: (ctor: Function) => BuiltinObjectKind | null;\ntype Constructor<instance = {}> = abstract new (...args: never[]) => instance;\ntype instanceOf<constructor> = constructor extends Constructor<infer instance> ? instance : never;\n/**\n * Returns an array of constructors for all ancestors (i.e., prototypes) of a given object.\n */\ndeclare const ancestorsOf: (o: object) => Function[];\ntype normalizedKeyOf<t> = keyof t extends infer k ? k extends number ? `${k}` : k : never;\ndeclare const constructorExtends: (ctor: Constructor, base: Constructor) => boolean;\n\ntype stringifyUnion<t extends string, delimiter extends string = \", \"> = join<unionToTuple<t>, delimiter>;\ntype unionToTuple<t> = _unionToTuple<t, []> extends infer result ? conform<result, t[]> : never;\ntype _unionToTuple<t, result extends unknown[]> = getLastBranch<t> extends infer current ? [\n    t\n] extends [never] ? result : _unionToTuple<Exclude<t, current>, [current, ...result]> : never;\ntype getLastBranch<t> = intersectUnion<t extends unknown ? (x: t) => void : never> extends ((x: infer branch) => void) ? branch : never;\ntype intersectUnion<t> = (t extends unknown ? (_: t) => void : never) extends ((_: infer intersection) => void) ? intersection : never;\ntype intersectOverloadReturns<fn extends Fn> = intersectUnion<ReturnType<overloadOf<fn>>>;\ntype overloadOf<fn extends Fn, givenArgs extends array = array> = Exclude<collectSignatures<(() => never) & fn, givenArgs, unknown>, fn extends () => never ? never : () => never>;\ntype collectSignatures<fn, givenArgs extends array, result> = result & fn extends (...args: infer args) => infer returns ? result extends fn ? never : collectSignatures<fn, givenArgs, Pick<fn, keyof fn> & result & ((...args: args) => returns)> | (args extends givenArgs ? (...args: args) => returns : never) : never;\n\ntype DescribeOptions = {\n    includeArticles?: boolean;\n    branchDelimiter?: string;\n};\ntype typeToString<t, opts extends DescribeOptions = {}> = stringifyUnion<[\n    t\n] extends [anyOrNever] ? unknown extends t ? \"any\" : \"never\" : unknown extends t ? \"unknown\" : boolean extends t ? \"boolean\" | ([t] extends [boolean] ? never : typeToString<Exclude<t, boolean>, opts>) : t extends array ? arrayTypeToString<t, opts> : t extends object ? describeObject<t, opts> : t extends Stringifiable ? stringifiableToString<t, opts> : describeDomainOf<t, opts>, opts[\"branchDelimiter\"] extends string ? opts[\"branchDelimiter\"] : describeDefaults[\"branchDelimiter\"]>;\ntype stringifiableToString<t extends Stringifiable, opts extends DescribeOptions> = inferDomain<domainOf<t>> extends t ? describeDomainOf<t, opts> : `${t}`;\ntype describe<t> = typeToString<t, {\n    includeArticles: true;\n    branchDelimiter: \" or \";\n}>;\ntype arrayTypeToString<t extends array, opts extends DescribeOptions> = typeToString<t[number], opts> extends infer element extends string ? opts[\"includeArticles\"] extends true ? describeArrayOf<element> : includesDelimiter<element, opts> extends true ? `(${element})[]` : `${element}[]` : never;\ntype describeArrayOf<element extends string> = element extends \"unknown\" ? \"an array\" : `an array of ${element}`;\ntype includesDelimiter<s extends string, opts extends DescribeOptions> = s extends (`${string}${opts[\"branchDelimiter\"] extends string ? opts[\"branchDelimiter\"] : describeDefaults[\"branchDelimiter\"]}${string}`) ? true : false;\ntype describeDefaults = satisfy<Required<DescribeOptions>, {\n    includeArticles: false;\n    branchDelimiter: \" | \";\n}>;\n\ntype JsTypeOf = \"object\" | \"function\" | \"number\" | \"bigint\" | \"boolean\" | \"string\" | \"symbol\" | \"undefined\" | \"null\";\ndeclare const hasDomain: <data, domain extends Domain>(data: data, kind: domain) => data is data & inferDomain<domain>;\ntype TypesByDomain = {\n    bigint: bigint;\n    boolean: boolean;\n    number: number;\n    object: object;\n    string: string;\n    symbol: symbol;\n    undefined: undefined;\n    null: null;\n};\ntype inferDomain<kind extends Domain> = Domain extends kind ? unknown : TypesByDomain[kind];\ntype Domain = show<keyof TypesByDomain>;\ntype NullishDomain = \"undefined\" | \"null\";\ntype NonNullishDomain = Exclude<Domain, NullishDomain>;\ntype PrimitiveDomain = Exclude<Domain, \"object\">;\ntype Primitive = inferDomain<PrimitiveDomain>;\ntype domainOf<data> = unknown extends data ? Domain : data extends object ? \"object\" : data extends string ? \"string\" : data extends number ? \"number\" : data extends boolean ? \"boolean\" : data extends undefined ? \"undefined\" : data extends null ? \"null\" : data extends bigint ? \"bigint\" : data extends symbol ? \"symbol\" : never;\ndeclare const domainOf: <data>(data: data) => domainOf<data>;\ndeclare const jsTypeOfDescriptions: {\n    readonly function: \"a function\";\n    readonly boolean: \"boolean\";\n    readonly null: \"null\";\n    readonly undefined: \"undefined\";\n    readonly bigint: \"a bigint\";\n    readonly number: \"a number\";\n    readonly object: \"an object\";\n    readonly string: \"a string\";\n    readonly symbol: \"a symbol\";\n};\n/** Each domain's completion for the phrase \"must be _____\" */\ndeclare const domainDescriptions: {\n    readonly boolean: \"boolean\";\n    readonly null: \"null\";\n    readonly undefined: \"undefined\";\n    readonly bigint: \"a bigint\";\n    readonly number: \"a number\";\n    readonly object: \"an object\";\n    readonly string: \"a string\";\n    readonly symbol: \"a symbol\";\n};\ntype domainDescriptions = typeof domainDescriptions;\ntype describeDomainOf<t, opts extends DescribeOptions = {}> = stringifyUnion<opts[\"includeArticles\"] extends true ? domainDescriptions[domainOf<t>] : domainOf<t>, opts[\"branchDelimiter\"] extends string ? opts[\"branchDelimiter\"] : describeDefaults[\"branchDelimiter\"]>;\n\ndeclare class InternalArktypeError extends Error {\n}\ndeclare const throwInternalError: (message: string) => never;\ndeclare const throwError: (message: string, ctor?: new (message: string) => Error) => never;\ndeclare class ParseError extends Error {\n    name: string;\n}\ndeclare const throwParseError: (message: string) => never;\n/**\n *  TypeScript won't suggest strings beginning with a space as properties.\n *  Useful for symbol-like string properties.\n */\ndeclare const noSuggest: <s extends string>(s: s) => noSuggest<s>;\n/**\n *  TypeScript won't suggest strings beginning with a space as properties.\n *  Useful for symbol-like string properties.\n */\ntype noSuggest<s extends string = string> = ` ${s}`;\n/** \"Hair Space\" character, used  as a non-rendered sentinel for an error message string:\n *  https://www.compart.com/en/unicode/U+200A\n */\ndeclare const zeroWidthSpace = \"\\u200A\";\n/** \"Hair Space\" character, used  as a non-rendered sentinel for an error message string:\n *  https://www.compart.com/en/unicode/U+200A\n */\ntype ZeroWidthSpace = typeof zeroWidthSpace;\ntype ErrorMessage<message extends string = string> = `${message}${ZeroWidthSpace}`;\ninterface ErrorType<message extends string = string, ctx extends {} = {}> {\n    [brand]: \"ErrorObject\";\n    message: message;\n    ctx: ctx;\n}\ntype Completion<text extends string = string> = `${text}${ZeroWidthSpace}${ZeroWidthSpace}`;\n\ntype Stringifiable = string | boolean | number | bigint | null | undefined;\n/** Force an operation like `{ a: 0 } & { b: 1 }` to be computed so that it displays `{ a: 0; b: 1 }`. */\ntype show<t> = {\n    [k in keyof t]: t[k];\n} & unknown;\n/** @deprecated use \"show\" instead */\ntype evaluate<t> = {\n    [k in keyof t]: t[k];\n} & unknown;\ntype exact<t extends object, u extends object> = {\n    [k in keyof t]: k extends keyof u ? conform<t[k], u[k]> : never;\n};\ntype exactMessageOnError<t extends object, u extends object> = {\n    [k in keyof t]: k extends keyof u ? conform<t[k], u[k]> : ErrorMessage<`'${k & string}' is not a valid key`>;\n} & u;\ntype promisable<t> = t | Promise<t>;\ntype leftIfEqual<l, r> = [l, r] extends [r, l] ? l : r;\ntype UnknownUnion = string | number | symbol | bigint | boolean | object | null | undefined;\n/**\n * Interesection (`&`) that avoids evaluating `unknown` to `{}`\n */\ntype andPreserveUnknown<l, r> = unknown extends l & r ? unknown : show<l & r>;\n/** Can be used to test for the universal subtypes, `any` and `never`, e.g.:\n *\n * ```ts\n * type isAnyOrNever<t> = [t] extends [anyOrNever] ? true : false\n * ```\n *\n *  The actual value is a string literal, but the only realistic subtypes\n *  of that literal are `any` and `never`.\n */\ntype anyOrNever = \" anyOrNever\";\ntype conform<t, base> = t extends base ? t : base;\ntype equals<l, r> = [l, r] extends [r, l] ? true : false;\ntype exactEquals<l, r> = (<_>() => _ extends l ? 1 : 2) extends <_>() => _ extends r ? 1 : 2 ? true : false;\ndeclare const brand: \" brand\";\ntype Brand<t = unknown, id = unknown> = t & {\n    readonly [brand]: [t, id];\n};\ntype unbrand<t> = t extends Brand<infer base, string> ? base : never;\ntype satisfy<base, t extends base> = t;\ntype defined<t> = t & ({} | null);\ntype autocomplete<suggestions extends string> = suggestions | (string & {});\ntype widen<t, supertypes> = collectWidenedType<t, unionToTuple<supertypes>>;\ntype collectWidenedType<t, remaining extends unknown[], result = never> = remaining extends [infer head, ...infer tail] ? collectWidenedType<t, tail, t extends head ? result | head : result> : result;\ntype narrowTuple<t extends readonly unknown[]> = t extends readonly [infer head, ...infer tail] ? readonly [head, ...narrowTuple<tail>] : [];\ntype narrow<t> = t extends Primitive ? t : t extends readonly unknown[] ? narrowTuple<t> : {\n    [k in keyof t]: narrow<t[k]>;\n};\ndeclare const narrow: <t>(t: narrow<t>) => t;\n/** primitive key used to represent an inferred type at compile-time */\ndeclare const inferred: \" arkInferred\";\n/** primitive key used to represent an inferred type at compile-time */\ntype inferred = typeof inferred;\n\ndeclare const args: \" args\";\ntype args = typeof args;\ndeclare abstract class Hkt<constraints extends unknown[] = any> {\n    [args]: unknown[];\n    constraints: constraints;\n    args: this[args] extends infer args extends unknown[] ? args : never;\n    0: this[args] extends [infer arg, ...any] ? arg : never;\n    1: this[args] extends [any, infer arg, ...any] ? arg : never;\n    2: this[args] extends [any, any, infer arg, ...any] ? arg : never;\n    3: this[args] extends [any, any, any, infer arg, ...any] ? arg : never;\n    abstract body: unknown;\n    description?: string;\n    constructor();\n}\n/** A small set of HKT utility types based on https://github.com/gvergnaud/hotscript\n *  See https://github.com/gvergnaud/hotscript/blob/main/src/internals/core/Core.ts\n */\ndeclare namespace Hkt {\n    type constructor<constraints extends unknown[] = any> = new () => Hkt<constraints>;\n    type args = typeof args;\n    type apply<hkt extends Hkt, args extends {\n        [i in keyof args]: hkt[\"constraints\"][i];\n    }> = (hkt & {\n        [args]: args;\n    })[\"body\"];\n}\n\ntype Digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\ntype NumberLiteral<n extends number = number> = `${n}`;\ntype BigintLiteral<n extends bigint = bigint> = `${n}n`;\ntype IntegerLiteral<n extends bigint = bigint> = `${n}`;\ntype NonNegativeIntegerLiteral<n extends bigint = bigint> = `${Digit}` | (`${Exclude<Digit, 0>}${string}` & `${n}`);\n/**\n *  Matches a well-formatted numeric expression according to the following rules:\n *    1. Must include an integer portion (i.e. '.321' must be written as '0.321')\n *    2. The first digit of the value must not be 0, unless the entire integer portion is 0\n *    3. If the value includes a decimal, its last digit may not be 0\n *    4. The value may not be \"-0\"\n */\ndeclare const wellFormedNumberMatcher: RegExp;\ndeclare const isWellFormedNumber: RegExp[\"test\"];\n/**\n * Similar to wellFormedNumber but more permissive in the following ways:\n *\n *  - Allows numbers without an integer portion like \".5\" (well-formed equivalent is \"0.5\")\n *  - Allows decimals with trailing zeroes like \"0.10\" (well-formed equivalent is \"0.1\")\n */\ndeclare const numericStringMatcher: RegExp;\ndeclare const isNumericString: (string: string) => boolean;\ndeclare const numberLikeMatcher: RegExp;\n/**\n *  Matches a well-formatted integer according to the following rules:\n *    1. must begin with an integer, the first digit of which cannot be 0 unless the entire value is 0\n *    2. The value may not be \"-0\"\n */\ndeclare const wellFormedIntegerMatcher: RegExp;\ndeclare const isWellFormedInteger: RegExp[\"test\"];\ndeclare const integerLikeMatcher: RegExp;\ntype NumericLiteralKind = \"number\" | \"bigint\" | \"integer\";\ndeclare const numericLiteralDescriptions: {\n    readonly number: \"a number\";\n    readonly bigint: \"a bigint\";\n    readonly integer: \"an integer\";\n};\ntype numericLiteralDescriptions = typeof numericLiteralDescriptions;\ntype writeMalformedNumericLiteralMessage<def extends string, kind extends NumericLiteralKind> = `'${def}' was parsed as ${numericLiteralDescriptions[kind]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;\ndeclare const writeMalformedNumericLiteralMessage: <def extends string, kind extends NumericLiteralKind>(def: def, kind: kind) => writeMalformedNumericLiteralMessage<def, kind>;\ndeclare const tryParseWellFormedNumber: typeof tryParseNumber;\ndeclare const tryParseNumber: <errorOnFail extends boolean | string>(token: string, options?: NumericParseOptions<errorOnFail>) => errorOnFail extends true | string ? number : number | undefined;\ntype tryParseNumber<token extends string, messageOnFail extends string> = token extends `${infer n extends number}` ? number extends n ? writeMalformedNumericLiteralMessage<token, \"number\"> : n : messageOnFail;\ntype parseNumber<token extends string> = token extends `${infer n extends number}` ? n : never;\ndeclare const tryParseInteger: <errorOnFail extends boolean | string>(token: string, options?: NumericParseOptions<errorOnFail>) => errorOnFail extends true | string ? number : number | undefined;\ntype tryParseInteger<token extends string, messageOnFail extends string> = token extends `${infer b extends bigint}` ? bigint extends b ? writeMalformedNumericLiteralMessage<token, \"integer\"> : token extends `${infer n extends number}` ? n : never : messageOnFail;\ntype parseInteger<token extends string> = token extends `${bigint}` ? token extends `${infer n extends number}` ? n : never : never;\ntype parseNonNegativeInteger<token extends string> = token extends `-${string}` ? never : parseInteger<token>;\ntype NumericParseOptions<errorOnFail extends boolean | string> = {\n    errorOnFail?: errorOnFail;\n    strict?: boolean;\n};\ndeclare const tryParseWellFormedBigint: (def: string) => bigint | undefined;\n/**\n * Returns the next or previous representable floating-point number after the given input.\n *\n * @param {\"+\" | \"-\"} [direction=\"+\"] - The direction to find the nearest float. \"+\" for the next float, \"-\" for the previous float.\n * @throws {Error} If the input is not a finite number.\n *\n * @example\n * console.log(nearestFloat(0)); // Smallest positive number\n * console.log(nearestFloat(2)); // 2.0000000000000004\n * console.log(nearestFloat(2.1)); // 2.1000000000000005\n * console.log(nearestFloat(2, \"-\")); // 1.9999999999999998\n * console.log(nearestFloat(2.1, \"-\")); // 2.0999999999999996\n * // as size of input increases, the increments become larger to stay within what\n * // JS can represent in a numeric value\n * console.log(nearestFloat(5555555555555555)); // 5555555555555556\n * console.log(nearestFloat(5555555555555555, \"-\")); // 5555555555555554\n */\ndeclare const nearestFloat: (n: number, direction?: \"+\" | \"-\") => number;\n\ntype Key = string | symbol;\ntype toArkKey<o, k extends keyof o> = k extends number ? [\n    o,\n    number\n] extends [array, k] ? NonNegativeIntegerLiteral : `${k}` : k;\ntype arkIndexableOf<o> = arkKeyOf<o> extends infer k ? k extends `${infer index extends number}` ? index | k : k : never;\ntype arkKeyOf<o> = [\n    o\n] extends [object] ? [\n    o\n] extends [array] ? arkArrayKeyOf<o> : arkObjectLiteralKeyOf<o> : never;\ntype arkArrayKeyOf<a extends array> = number extends a[\"length\"] ? NonNegativeIntegerLiteral : keyof a extends infer i ? i extends `${number}` ? i : never : never;\ntype arkObjectLiteralKeyOf<o extends object> = keyof o extends infer k ? k extends number ? `${k}` : k : never;\ntype arkGet<o, k extends arkIndexableOf<o>> = o[k extends keyof o ? k : NonNegativeIntegerLiteral extends k ? number & keyof o : k extends number ? `${k}` & keyof o : never];\ntype writeInvalidKeysMessage<o extends string, keys extends array<string>> = `Key${keys[\"length\"] extends 1 ? \"\" : \"s\"} ${join<keys, \", \">} ${keys[\"length\"] extends 1 ? \"does\" : \"do\"} not exist on ${o}`;\n\ntype Dict<k extends string = string, v = unknown> = {\n    readonly [_ in k]: v;\n};\ntype dict<v = unknown, k extends string = string> = {\n    [_ in k]: v;\n};\n/** Either:\n * A, with all properties of B undefined\n * OR\n * B, with all properties of A undefined\n **/\ntype propwiseXor<a, b> = show<a & {\n    [k in keyof b]?: undefined;\n}> | show<b & {\n    [k in keyof a]?: undefined;\n}>;\ntype unionToPropwiseXor<props extends object, branchKey extends PropertyKey = keyof intersectUnion<props>> = props extends infer distributed ? show<distributed & {\n    [k in branchKey]?: k extends keyof distributed ? unknown : undefined;\n}> : never;\ntype requireKeys<o, key extends keyof o> = o & {\n    [requiredKey in key]-?: defined<o[requiredKey]>;\n};\ntype require<o, maxDepth extends number = 1> = _require<o, [], maxDepth>;\ntype _require<o, depth extends 1[], maxDepth extends number> = depth[\"length\"] extends maxDepth ? o : o extends object ? o extends Fn ? o : {\n    [k in keyof o]-?: _require<o[k], [...depth, 1], maxDepth>;\n} : o;\ntype PartialRecord<k extends PropertyKey = PropertyKey, v = unknown> = {\n    [_ in k]?: v;\n};\n/** Returns true if a type can be homomorphically mapped without losing information.\n * Useful for avoiding e.g. classes with private properties while mapping.\n */\ntype isSafelyMappable<t> = {\n    [k in keyof t]: t[k];\n} extends t ? true : false;\ntype KeySet<key extends string = string> = {\n    readonly [_ in key]?: 1;\n};\ntype keySetOf<o extends object> = KeySet<Extract<keyof o, string>>;\ntype mutable<o, maxDepth extends number = 1> = _mutable<o, [], maxDepth>;\ntype _mutable<o, depth extends 1[], maxDepth extends number> = depth[\"length\"] extends maxDepth ? o : o extends object ? o extends Fn ? o : {\n    -readonly [k in keyof o]: _mutable<o[k], [...depth, 1], maxDepth>;\n} : o;\n/**\n * extracts entries mimicking Object.entries, accounting for whether the\n * object is an array\n **/\ntype entryOf<o> = {\n    [k in keyof o]-?: [k, o[k] & ({} | null)];\n}[o extends readonly unknown[] ? keyof o & number : keyof o] & unknown;\ntype entriesOf<o extends object> = entryOf<o>[];\n/**\n * Object.entries wrapper providing narrowed types for objects with known sets\n * of keys, e.g. those defined internally as configs\n */\ndeclare const entriesOf: <o extends object>(o: o) => entryOf<o>[];\ntype Entry<key extends PropertyKey = PropertyKey, value = unknown> = readonly [key: key, value: value];\ntype fromEntries<entries extends readonly Entry[]> = show<{\n    [entry in entries[number] as entry[0]]: entry[1];\n}>;\ndeclare const fromEntries: <const entries extends readonly Entry[]>(entries: entries) => fromEntries<entries>;\n/** Mimics the result of Object.keys(...) */\ntype keyOf<o> = o extends array ? number extends o[\"length\"] ? `${number}` : keyof o & `${number}` : keyof o extends infer k ? k extends string ? k : k extends number ? `${k}` : never : never;\ndeclare const keysOf: <o extends object>(o: o) => keyOf<o>[];\ndeclare const isKeyOf: <k extends string | number | symbol, o extends object>(k: k, o: o) => k is Extract<keyof o, k>;\n/** Coalesce keys that exist on one or more branches of a union */\ntype unionKeyOf<t> = t extends unknown ? keyof t : never;\ntype extractKeyed<o extends object, k extends unionKeyOf<o>> = Extract<o, {\n    [_ in k]?: unknown;\n}>;\ndeclare const hasKey: <o extends object, k extends unionKeyOf<o>>(o: o, k: k) => o is extractKeyed<o, k>;\ntype extractDefinedKey<o extends object, k extends unionKeyOf<o>> = show<extractKeyed<o, k> & {\n    [_ in k]: {} | null;\n}>;\ndeclare const hasDefinedKey: <o extends object, k extends unionKeyOf<o>>(o: o, k: k) => o is extractDefinedKey<o, k>;\ntype requiredKeyOf<o> = keyof o extends infer k ? k extends keyof o ? o extends {\n    [_ in k]-?: o[k];\n} ? k : never : never : never;\ntype optionalKeyOf<o> = Exclude<keyof o, requiredKeyOf<o>>;\ntype merge<base, props> = base extends unknown ? props extends unknown ? show<omit<base, keyof props & keyof base> & props> : never : never;\ntype mergeExact<base, props> = base extends unknown ? props extends unknown ? show<omitMerged<base, props> & props> : never : never;\ntype omitMerged<base, props> = {\n    [k in keyof base as excludeExactKeyOf<k, props>]: base[k];\n};\ntype excludeExactKeyOf<key extends PropertyKey, o> = Exclude<key, extractExactKeyOf<key, o>>;\ntype extractExactKeyOf<key extends PropertyKey, base> = keyof {\n    [k in keyof base as [key, k] extends [k, key] ? key : never]: 1;\n};\ntype override<base, merged extends {\n    [k in keyof base]?: unknown;\n}> = merge<base, merged>;\ntype propValueOf<o> = o[keyof o];\ndeclare const InnerDynamicBase: new <t extends object>(base: t) => t;\n/** @ts-ignore (needed to extend `t`) **/\ninterface DynamicBase<t extends object> extends t {\n}\ndeclare class DynamicBase<t extends object> {\n    constructor(properties: t);\n}\ndeclare const NoopBase: new <t extends object>() => t;\n/** @ts-ignore (needed to extend `t`) **/\ndeclare class CastableBase<t extends object> extends NoopBase<t> {\n}\ndeclare const splitByKeys: <o extends object, leftKeys extends keySetOf<o>>(o: o, leftKeys: leftKeys) => [show<Pick<o, keyof leftKeys & keyof o>>, show<Omit<o, keyof leftKeys & keyof o>>];\n/** Homomorphic implementation of the builtin Pick.\n *\n * Gives different results for certain union expressions like the following:\n *\n * @example\n * // flattens result to { a?: 1 | 2; b?: 1 | 2 }\n * type PickResult = Pick<{ a: 1; b?: 1 } | { a?: 2; b: 2 }, \"a\" | \"b\">\n *\n * @example\n * // preserves original type w/ modifier groupings\n * type pickResult = pick<{ a: 1; b?: 1 } | { a?: 2; b: 2 }, \"a\" | \"b\">\n */\ntype pick<o, key extends keyof o> = o extends unknown ? {\n    [k in keyof o as k extends key ? k : never]: o[k];\n} : never;\ndeclare const pick: <o extends object, keys extends keySetOf<o>>(o: o, keys: keys) => pick<o, keyof keys & keyof o>;\n/** Homomorphic implementation of the builtin Omit.\n *\n * Gives different results for many union expressions like the following:\n *\n * @example\n * // {}\n * type OmitResult = Omit<{ a: 1 } | { b: 2 }, never>\n *\n * @example\n * // preserves original type w/ modifier groupings\n * type omitResult = omit<{ a: 1 } | { b: 2 }, never>\n */\ntype omit<o, key extends keyof o> = {\n    [k in keyof o as k extends key ? never : k]: o[k];\n};\ndeclare const omit: <o extends object, keys extends keySetOf<o>>(o: o, keys: keys) => omit<o, keyof keys & keyof o>;\n/** Returns onTrue if the type is exactly `{}` and onFalse otherwise*/\ntype ifEmptyObjectLiteral<t, onTrue = true, onFalse = false> = [\n    unknown,\n    t & (null | undefined)\n] extends [t | null | undefined, never] ? onTrue : onFalse;\ntype EmptyObject = Record<PropertyKey, never>;\ndeclare const isEmptyObject: (o: object) => o is EmptyObject;\ndeclare const stringAndSymbolicEntriesOf: (o: object) => Entry<Key>[];\n/** Like Object.assign, but it will preserve getters instead of evaluating them. */\ndeclare const defineProperties: <base extends object, merged extends object>(base: base, merged: merged) => merge<base, merged>;\n/** Copies enumerable keys of o to a new object in alphabetical order */\ndeclare const withAlphabetizedKeys: <o extends object>(o: o) => o;\ntype invert<t extends Record<PropertyKey, PropertyKey>> = {\n    [k in t[keyof t]]: {\n        [k2 in keyof t]: t[k2] extends k ? k2 : never;\n    }[keyof t];\n} & unknown;\ndeclare const invert: <t extends Record<PropertyKey, PropertyKey>>(t: t) => invert<t>;\ndeclare const unset: \" represents an uninitialized value\";\ntype unset = typeof unset;\n/**\n *  For each keyof o that also exists on jsDocSource, add associated JsDoc annotations to o.\n *  Does not preserve modifiers on o like optionality.\n */\ntype withJsDoc<o, jsDocSource> = show<keyof o extends keyof jsDocSource ? keyof jsDocSource extends keyof o ? _withJsDoc<o, jsDocSource> : Pick<_withJsDoc<o, jsDocSource>, keyof o & keyof jsDocSource> : Pick<_withJsDoc<o, jsDocSource>, keyof o & keyof jsDocSource> & {\n    [k in Exclude<keyof o, keyof jsDocSource>]: o[k];\n}>;\ntype _withJsDoc<o, jsDocSource> = {\n    [k in keyof jsDocSource]-?: o[k & keyof o];\n};\ntype propertyDescriptorsOf<o extends object> = {\n    [k in keyof o]: TypedPropertyDescriptor<o[k]>;\n};\ntype keyWithValue<t, constraint> = keyof t extends infer k ? k extends keyof t ? t[k] extends constraint ? k : never : never : never;\ndeclare const enumValues: <tsEnum extends object>(tsEnum: tsEnum) => tsEnum[keyof tsEnum][];\n\ninterface AndPreserveUnknown extends Hkt<[unknown, unknown]> {\n    body: andPreserveUnknown<this[0], this[1]>;\n}\ntype SequenceIntersectionKind = \"array\" | \"parameters\";\ntype intersectArrays<l extends array, r extends array, operator extends Hkt = AndPreserveUnknown> = intersectSequences<l, r, [], [], operator, \"array\">;\ntype intersectParameters<l extends array, r extends array, operator extends Hkt = AndPreserveUnknown> = intersectSequences<l, r, [], [], operator, \"parameters\">;\ntype intersectSequences<l extends array, r extends array, acc extends array, postfix extends array, operation extends Hkt, kind extends SequenceIntersectionKind> = l extends readonly [] ? kind extends \"array\" ? [\n] extends r ? [\n    ...acc,\n    ...postfix\n] : never : [...acc, ...r, ...postfix] : r extends readonly [] ? kind extends \"array\" ? [\n] extends l ? [\n    ...acc,\n    ...postfix\n] : never : [...acc, ...l, ...postfix] : [\n    l,\n    r\n] extends ([\n    readonly [(infer lHead)?, ...infer lTail],\n    readonly [(infer rHead)?, ...infer rTail]\n]) ? [\n    \"0\",\n    lHead,\n    rHead\n] extends [keyof l | keyof r, l[0], r[0]] ? intersectSequences<lTail, rTail, [\n    [],\n    []\n] extends [l, r] ? [\n    ...acc,\n    Hkt.apply<operation, [lHead, rHead]>?\n] : [...acc, Hkt.apply<operation, [lHead, rHead]>], postfix, operation, kind> : l extends readonly [...infer lInit, infer lLast] ? r extends readonly [...infer rInit, infer rLast] ? intersectSequences<lInit, rInit, acc, [\n    Hkt.apply<operation, [lLast, rLast]>,\n    ...postfix\n], operation, kind> : intersectSequences<lInit, r, acc, [\n    Hkt.apply<operation, [lLast, r[number]]>,\n    ...postfix\n], operation, kind> : r extends readonly [...infer rInit, infer rLast] ? intersectSequences<l, rInit, acc, [\n    Hkt.apply<operation, [l[number], rLast]>,\n    ...postfix\n], operation, kind> : [...acc, ...Hkt.apply<operation, [lHead, rHead]>[], ...postfix] : never;\ntype isDisjoint<l, r> = overlaps<l, r> extends true ? false : true;\ntype overlaps<l, r> = l & r extends never ? false : domainOf<l> & domainOf<r> extends never ? false : [l, r] extends [object, object] ? false extends (propValueOf<{\n    [k in Extract<keyof l & keyof r, requiredKeyOf<l> | requiredKeyOf<r>>]: overlaps<l[k], r[k]>;\n}>) ? false : true : true;\n\ntype DuplicateData<val = unknown> = {\n    element: val;\n    indices: number[];\n};\n/**\n * Extracts duplicated elements and their indices from an array, returning them.\n *\n * Note that given `a === b && b === c`, then `c === a` must be `true` for this to give accurate results.\n *\n * @param arr The array to extract duplicate elements from.\n */ declare const getDuplicatesOf: <const arr extends array>(arr: arr, opts?: ComparisonOptions<arr[number]>) => DuplicateData<arr[number]>[];\ntype pathToString<segments extends string[], delimiter extends string = \"/\"> = segments extends [] ? \"/\" : join<segments, delimiter>;\ndeclare const join: <segments extends array<string>, delimiter extends string>(segments: segments, delimiter: delimiter) => join<segments, delimiter>;\ntype join<segments extends array<string>, delimiter extends string, result extends string = \"\"> = segments extends (readonly [infer head extends string, ...infer tail extends string[]]) ? join<tail, delimiter, result extends \"\" ? head : `${result}${delimiter}${head}`> : result;\ndeclare const getPath: (root: unknown, path: string[]) => unknown;\ndeclare const intersectUniqueLists: <item>(l: readonly item[], r: readonly item[]) => item[];\ntype filter<t extends array, constraint, result extends unknown[] = []> = t extends readonly [infer head, ...infer tail] ? filter<tail, constraint, head extends constraint ? [...result, head] : result> : result;\ntype array<t = unknown> = readonly t[];\ntype listable<t> = t | readonly t[];\ntype flattenListable<t> = t extends array<infer element> ? element : t;\ntype NonEmptyList<t = unknown> = readonly [t, ...t[]];\ntype repeat<t extends array, count extends number> = _repeat<t, [\n], count, [\n]>;\ntype _repeat<base extends array, result extends array, maxDepth extends number, depth extends 1[]> = depth[\"length\"] extends maxDepth ? result : _repeat<base, [...result, ...base], maxDepth, [...depth, 1]>;\ntype CollapsingList<t = unknown> = readonly [] | t | readonly [t, t, ...t[]];\ntype headOf<t extends array> = t[0];\ntype tailOf<t extends array> = t extends readonly [unknown, ...infer tail] ? tail : never;\ntype lastIndexOf<t extends array> = tailOf<t>[\"length\"];\ntype lastOf<t extends array> = t[lastIndexOf<t>];\ntype initOf<t extends array> = t extends readonly [...infer init, unknown] ? init : never;\ntype numericStringKeyOf<t extends array> = Extract<keyof t, `${number}`>;\ntype arrayIndexOf<a extends array> = keyof a extends infer k ? parseNonNegativeInteger<k & string> : never;\ntype liftArray<t> = t extends array ? [\n    t\n] extends [anyOrNever] ? t[] : t : t[];\ndeclare const liftArray: <t>(data: t) => liftArray<t>;\n/**\n * Splits an array into two arrays based on the result of a predicate\n *\n * @param predicate - The guard function used to determine which items to include.\n * @returns A tuple containing two arrays:\n * \t\t\t\t- the first includes items for which `predicate` returns true\n * \t\t\t\t- the second includes items for which `predicate` returns false\n *\n * @example\n * const list = [1, \"2\", \"3\", 4, 5];\n * const [numbers, strings] = spliterate(list, (x) => typeof x === \"number\");\n * // Type: number[]\n * // Output: [1, 4, 5]\n * console.log(evens);\n * // Type: string[]\n * // Output: [\"2\", \"3\"]\n * console.log(odds);\n */\ndeclare const spliterate: <item, included extends item>(arr: readonly item[], predicate: GuardablePredicate<item, included>) => [included: included[], excluded: [item] extends [included] ? item[] : Exclude<item, included>[]];\ndeclare const ReadonlyArray: new <T>(...args: ConstructorParameters<typeof Array<T>>) => ReadonlyArray<T>;\ndeclare const includes: <a extends array>(array: a, element: unknown) => element is a[number];\ndeclare const range: (length: number, offset?: number) => number[];\ntype AppendOptions = {\n    /** If true, adds the element to the beginning of the array instead of the end */\n    prepend?: boolean;\n};\n/**\n * Adds a value or array to an array, returning the concatenated result\n */\ndeclare const append: <to extends unknown[] | undefined, value extends appendableValue<to>>(to: to, value: value, opts?: AppendOptions) => to & {};\ntype appendableValue<to extends array | undefined> = to extends array<infer element> ? element extends array ? array<element> : listable<element> : never;\n/**\n * Concatenates an element or list with a readonly list\n */\ndeclare const conflatenate: <element>(to: readonly element[] | undefined | null, elementOrList: appendableValue<readonly element[]> | undefined | null) => readonly element[];\n/**\n * Concatenates a variadic list of elements or lists with a readonly list\n */\ndeclare const conflatenateAll: <element>(...elementsOrLists: (listable<element> | undefined | null)[]) => readonly element[];\ninterface ComparisonOptions<t = unknown> {\n    isEqual?: (l: t, r: t) => boolean;\n}\n/**\n * Appends a value or concatenates an array to an array if it is not already included, returning the array\n */\ndeclare const appendUnique: <to extends unknown[]>(to: to | undefined, value: NoInfer<Readonly<to> | to[number]>, opts?: ComparisonOptions<to[number]>) => to;\ntype groupableKeyOf<o> = keyof o extends infer k ? k extends keyof o ? o[k] extends PropertyKey ? k : never : never : never;\ntype groupBy<element, discriminant extends groupableKeyOf<element>> = {\n    [k in element[discriminant] & PropertyKey]?: (element extends unknown ? isDisjoint<element[discriminant], k> extends true ? never : element : never)[];\n} & unknown;\ndeclare const groupBy: <element, discriminant extends groupableKeyOf<element>>(array: readonly element[], discriminant: discriminant) => groupBy<element, discriminant>;\ndeclare const arrayEquals: <element>(l: array<element>, r: array<element>, opts?: ComparisonOptions<element>) => boolean;\ntype validateExhaustiveKeys<keys extends readonly PropertyKey[], expectedKey extends PropertyKey> = keys extends readonly [infer head, ...infer tail extends PropertyKey[]] ? readonly [\n    conform<head, expectedKey>,\n    ...validateExhaustiveKeys<tail, Exclude<expectedKey, head>>\n] : [expectedKey] extends [never] ? [] : [expectedKey];\n\n/** Shallowly copy the properties of the object. */\ndeclare const shallowClone: <input extends object>(input: input) => input;\n/** Deeply copy the properties of the a non-subclassed Object, Array or Date.*/\ndeclare const deepClone: <input extends object>(input: input) => input;\n\ntype objectFromListableEntries<transformed extends readonly GroupableEntry[]> = show<intersectUnion<fromGroupableEntries<transformed>>>;\ntype fromGroupableEntries<entries extends readonly GroupableEntry[]> = {\n    [entry in entries[number] as entry extends GroupedEntry ? entry[0][\"group\"] : conform<entry[0], PropertyKey>]: entry extends GroupedEntry ? entry[1][] : entry[1];\n};\ntype arrayFromListableEntries<transformed extends Entry> = Entry<number, never> extends transformed ? transformed[1][] : _arrayFromListableEntries<transformed, []>;\ntype _arrayFromListableEntries<transformed extends Entry, result extends unknown[]> = [\n    transformed\n] extends [never] ? result : Extract<transformed, Entry<result[\"length\"]>> extends (infer next extends Entry) ? Exclude<transformed, next> extends infer remaining extends Entry ? [\n    transformed\n] extends [remaining] ? [\n    ...result,\n    ...transformed[1][]\n] : _arrayFromListableEntries<remaining, [...result, next[1]]> : never : [...result, ...transformed[1][]];\ntype extractEntrySets<e extends listable<GroupableEntry>> = e extends readonly GroupableEntry[] ? e : [e];\ntype extractEntries<e extends listable<Entry>> = e extends readonly Entry[] ? e[number] : e;\ntype entryArgsWithIndex<o> = {\n    [k in keyof o]-?: [k: k, v: Exclude<o[k], undefined>, i: number];\n}[keyof o];\ntype numericArrayEntry<a extends array> = number extends a[\"length\"] ? [number, a[number]] : {\n    [i in keyof a]: i extends `${infer n extends number}` ? [n, a[i]] : never;\n}[number];\ntype GroupedEntry = readonly [key: {\n    group: Key;\n}, value: unknown];\ntype GroupableEntry = Entry<Key> | Entry<number> | GroupedEntry;\ntype ListableEntry = listable<GroupableEntry>;\ntype fromMappedEntries<transformed extends ListableEntry> = [\n    transformed\n] extends [listable<Entry<number>>] ? arrayFromListableEntries<extractEntries<transformed>> : objectFromListableEntries<extractEntrySets<transformed>>;\ntype FlatMorph = {\n    <const o extends array, transformed extends ListableEntry>(o: o, flatMapEntry: (...args: numericArrayEntry<o>) => transformed): fromMappedEntries<transformed>;\n    <const o extends object, transformed extends ListableEntry>(o: o, flatMapEntry: (...args: entryOf<o>) => transformed): fromMappedEntries<transformed>;\n    <const o extends object, transformed extends ListableEntry>(o: o, flatMapEntry: (...args: entryArgsWithIndex<o>) => transformed): fromMappedEntries<transformed>;\n};\ndeclare const flatMorph: FlatMorph;\n\ndeclare const isomorphic: {\n    fileName: () => string;\n    env: Record<autocomplete<\"ARK_DEBUG\">, string | undefined>;\n};\n\ndeclare const lazily: <t extends object>(thunk: () => t) => t;\n\ntype SerializationOptions = {\n    onCycle?: (value: object) => string;\n    onSymbol?: (value: symbol) => string;\n    onFunction?: (value: Function) => string;\n    onUndefined?: string;\n    onBigInt?: (value: bigint) => string;\n};\ntype JsonStructure = JsonObject | JsonArray;\ninterface JsonObject {\n    [k: string]: Json;\n}\ntype JsonArray = Json[];\ntype JsonPrimitive = string | boolean | number | null;\ntype Json = JsonStructure | JsonPrimitive;\ndeclare const snapshot: <t>(data: t, opts?: SerializationOptions) => snapshot<t>;\ntype snapshot<t, depth extends 1[] = []> = unknown extends t ? unknown : t extends Primitive ? snapshotPrimitive<t> : t extends {\n    toJSON: () => infer serialized;\n} ? serialized : t extends Function ? `Function(${string})` : t extends Date ? string : depth[\"length\"] extends 10 ? unknown : t extends array<infer item> ? array<snapshot<item, [...depth, 1]>> : {\n    [k in keyof t as snapshotPrimitive<k>]: snapshot<t[k], [...depth, 1]>;\n};\ntype snapshotPrimitive<t> = t extends symbol ? `Symbol(${string})` : t;\ndeclare const print: (data: unknown, indent?: number) => void;\ndeclare const printable: (data: unknown, indent?: number) => string;\n/**\n * Converts a Date instance to a human-readable description relative to its precision\n */\ndeclare const describeCollapsibleDate: (date: Date) => string;\n\ntype StringifyPathOptions<stringifiable = PropertyKey> = requireKeys<{\n    stringifySymbol?: (s: symbol) => string;\n    stringifyNonKey?: (o: Exclude<stringifiable, PropertyKey>) => string;\n}, stringifiable extends PropertyKey ? never : \"stringifyNonKey\">;\ntype StringifyPathFn = <stringifiable>(path: array<stringifiable>, ...[opts]: [stringifiable] extends [PropertyKey] ? [\n    opts?: StringifyPathOptions\n] : NoInfer<[opts: StringifyPathOptions<stringifiable>]>) => string;\ntype AppendStringifiedKeyFn = <stringifiable>(path: string, prop: stringifiable, ...[opts]: [stringifiable] extends [PropertyKey] ? [\n    opts?: StringifyPathOptions\n] : NoInfer<[opts: StringifyPathOptions<stringifiable>]>) => string;\ndeclare const appendStringifiedKey: AppendStringifiedKeyFn;\ndeclare const stringifyPath: StringifyPathFn;\ndeclare class ReadonlyPath extends ReadonlyArray<PropertyKey> {\n    private cache;\n    constructor(...items: array<PropertyKey>);\n    toJSON(): JsonArray;\n    stringify(): string;\n    stringifyAncestors(): readonly string[];\n}\n\ntype SerializedString<value extends string = string> = `\"${value}\"`;\ntype SerializedPrimitives = {\n    string: SerializedString;\n    number: `${number}`;\n    bigint: BigintLiteral;\n    boolean: \"true\" | \"false\";\n    null: \"null\";\n    undefined: \"undefined\";\n};\ntype SerializedPrimitive = SerializedPrimitives[keyof SerializedPrimitives];\ntype SerializablePrimitive = inferDomain<keyof SerializedPrimitives>;\ndeclare const serializePrimitive: <value extends SerializablePrimitive>(value: value) => serializePrimitive<value>;\ntype serializePrimitive<value extends SerializablePrimitive> = value extends string ? `\"${value}\"` : value extends bigint ? `${value}n` : `${value}`;\n\ndeclare const arkUtilVersion = \"0.45.10\";\ndeclare const initialRegistryContents: {\n    version: string;\n    filename: string;\n    FileConstructor: typeof buffer.File;\n};\ntype InitialRegistryContents = typeof initialRegistryContents;\ninterface ArkRegistry extends InitialRegistryContents {\n    [k: string]: unknown;\n}\ndeclare const registry: ArkRegistry;\ndeclare global {\n    export interface ArkEnv {\n        prototypes(): never;\n    }\n    export namespace ArkEnv {\n        type prototypes = ReturnType<ArkEnv[\"prototypes\"]>;\n    }\n}\ndeclare const register: (value: object | symbol) => string;\ndeclare const isDotAccessible: (keyName: string) => boolean;\n\ndeclare class Scanner<lookahead extends string = string> {\n    chars: string[];\n    i: number;\n    def: string;\n    constructor(def: string);\n    /** Get lookahead and advance scanner by one */\n    shift(): this[\"lookahead\"];\n    get lookahead(): lookahead;\n    get nextLookahead(): string;\n    get length(): number;\n    shiftUntil(condition: Scanner.UntilCondition): string;\n    shiftUntilLookahead(charOrSet: string | KeySet): string;\n    shiftUntilNonWhitespace(): string;\n    jumpToIndex(i: number): void;\n    jumpForward(count: number): void;\n    get location(): number;\n    get unscanned(): string;\n    get scanned(): string;\n    sliceChars(start: number, end?: number): string;\n    lookaheadIs<char extends lookahead>(char: char): this is Scanner<char>;\n    lookaheadIsIn<keySet extends KeySet>(tokens: keySet): this is Scanner<Extract<keyof keySet, string>>;\n}\ndeclare namespace Scanner {\n    type UntilCondition = (scanner: Scanner, shifted: string) => boolean;\n}\n\ndeclare const capitalize: <s extends string>(s: s) => Capitalize<s>;\ndeclare const uncapitalize: <s extends string>(s: s) => Uncapitalize<s>;\ntype firstChar<s extends string> = s extends `${infer head}${string}` ? head : \"\";\ntype charsAfterFirst<s extends string> = s extends `${string}${infer tail}` ? tail : \"\";\ntype lastChar<s extends string> = s extends `${infer head}${infer tail}` ? tail extends \"\" ? head : lastChar<tail> : s;\ntype charsBeforeLast<s extends string> = s extends `${infer head}${infer tail}` ? tail extends \"\" ? \"\" : `${head}${charsBeforeLast<tail>}` : \"\";\ndeclare const anchoredRegex: (regex: RegExp | string) => RegExp;\ndeclare const deanchoredRegex: (regex: RegExp | string) => RegExp;\ndeclare const anchoredSource: (regex: RegExp | string) => string;\ndeclare const deanchoredSource: (regex: RegExp | string) => string;\ndeclare const RegexPatterns: {\n    negativeLookahead: (pattern: string) => `(?!${string})`;\n    nonCapturingGroup: (pattern: string) => `(?:${string})`;\n};\ndeclare const escapeChar = \"\\\\\";\ntype EscapeChar = typeof escapeChar;\ndeclare const whitespaceChars: {\n    readonly \" \": 1;\n    readonly \"\\n\": 1;\n    readonly \"\\t\": 1;\n};\ntype WhitespaceChar = keyof typeof whitespaceChars;\ntype trim<s extends string> = trimEnd<trimStart<s>>;\ntype trimStart<s extends string> = s extends `${WhitespaceChar}${infer tail}` ? trimEnd<tail> : s;\ntype trimEnd<s extends string> = s extends `${infer init}${WhitespaceChar}` ? trimEnd<init> : s;\ntype isStringLiteral<t> = [\n    t\n] extends [string] ? [\n    string\n] extends [t] ? false : Uppercase<t> extends Uppercase<Lowercase<t>> ? Lowercase<t> extends Lowercase<Uppercase<t>> ? true : false : false : false;\ndeclare const emojiToUnicode: (emoji: string) => string;\n\ntype TraitImplementation = <traits extends TraitConstructor[], implementation extends implementationOf<s>, s extends CompositionState = composeTraits<[\n    ...traits,\n    implementation\n], \"implementation\">, cls extends TraitConstructor = TraitConstructor<s[\"params\"], s[\"implemented\"], s[\"statics\"], s[\"abstractMethods\"], s[\"abstractProps\"], s[\"abstractStatics\"]>>(...args: [...traits, implementation & ThisType<InstanceType<cls>>]) => cls;\ntype TraitComposition = <traits extends TraitConstructor[], s extends CompositionState = composeTraits<traits, \"abstract\">>(...traits: conform<traits, s[\"validated\"]>) => TraitConstructor<s[\"params\"], s[\"implemented\"], s[\"statics\"], s[\"abstractMethods\"], s[\"abstractProps\"], s[\"abstractStatics\"]>;\ndeclare const hasTrait: (traitClass: Constructor) => (o: unknown) => boolean;\ntype TraitDeclaration = {\n    abstractMethods?: object;\n    abstractProps?: object;\n    abstractStatics?: object;\n    dynamicBase?: object;\n};\n/** @ts-ignore required to extend NoopBase */\ndeclare abstract class Trait<d extends TraitDeclaration = {}, abstractMethods extends object = d[\"abstractMethods\"] & {}, abstractProps extends object = d[\"abstractProps\"] & {}, abstractStatics extends object = d[\"abstractStatics\"] & {}, dynamicBase extends object = d[\"dynamicBase\"] & {}> extends NoopBase<abstractMethods & abstractProps & dynamicBase> {\n    abstractMethods: abstractMethods;\n    abstractProps: abstractProps;\n    abstractStatic: abstractStatics;\n    static get [Symbol.hasInstance](): (o: unknown) => boolean;\n    traitsOf(): readonly TraitConstructor[];\n}\ndeclare const compose: TraitComposition;\ndeclare const implement: TraitImplementation;\ntype TraitConstructor<params extends array = any[], instance extends object = {}, statics = {}, abstractMethods extends object = {}, abstractProps extends object = {}, abstractStatics extends object = {}> = statics & (new (...args: params) => Trait<{\n    abstractMethods: abstractMethods;\n    abstractProps: abstractProps;\n    abstractStatics: abstractStatics;\n}> & instance);\ntype CompositionState = {\n    validated: array;\n    remaining: array;\n    params: array;\n    kind: TraitCompositionKind;\n    implemented: object;\n    abstractMethods: object;\n    abstractProps: object;\n    abstractStatics: object;\n    statics: object;\n};\ntype TraitCompositionKind = \"abstract\" | \"implementation\";\ntype composeTraits<traits extends array, kind extends TraitCompositionKind> = _compose<{\n    validated: [];\n    remaining: traits;\n    kind: kind;\n    params: [];\n    implemented: {};\n    abstractMethods: {};\n    abstractProps: {};\n    abstractStatics: {};\n    statics: {};\n}>;\ntype intersectImplementations<l, r> = {\n    [k in keyof l]: k extends keyof r ? l[k] extends (...args: infer lArgs) => infer lReturn ? r[k] extends (...args: infer rArgs) => infer rReturn ? (...args: intersectParameters<lArgs, rArgs>) => lReturn & rReturn : l[k] & r[k] : l[k] & r[k] : l[k];\n} & Omit<r, keyof l>;\ntype _compose<s extends CompositionState> = s[\"remaining\"] extends (readonly [\n    TraitConstructor<infer params, infer instance, infer statics, infer abstractMethods, infer abstractProps, infer abstractStatics>,\n    ...infer tail\n]) ? _compose<{\n    validated: [...s[\"validated\"], s[\"remaining\"][0]];\n    remaining: tail;\n    kind: s[\"kind\"];\n    params: intersectParameters<s[\"params\"], params>;\n    implemented: intersectImplementations<s[\"implemented\"], Omit<instance, keyof abstractMethods | keyof abstractProps>>;\n    statics: intersectImplementations<s[\"statics\"], Omit<statics, keyof abstractStatics>>;\n    abstractMethods: intersectImplementations<s[\"abstractMethods\"], abstractMethods>;\n    abstractProps: intersectImplementations<s[\"abstractProps\"], abstractProps>;\n    abstractStatics: intersectImplementations<s[\"abstractStatics\"], abstractStatics>;\n}> : finalizeState<s>;\ntype finalizeState<s extends CompositionState> = satisfy<CompositionState, {\n    params: s[\"params\"];\n    validated: s[\"validated\"];\n    remaining: s[\"remaining\"];\n    kind: s[\"kind\"];\n    implemented: show<s[\"implemented\"]>;\n    statics: show<Omit<s[\"statics\"], keyof typeof Trait>>;\n    abstractMethods: show<Omit<s[\"abstractMethods\"], keyof s[\"implemented\"]>>;\n    abstractProps: show<Omit<s[\"abstractProps\"], keyof s[\"implemented\"]>>;\n    abstractStatics: show<Omit<s[\"abstractStatics\"], keyof s[\"statics\"]>>;\n}>;\ntype implementationOf<s extends CompositionState> = s[\"abstractMethods\"] & ({} extends s[\"abstractProps\"] ? {} : {\n    construct: (...args: s[\"params\"]) => s[\"abstractProps\"];\n}) & ({} extends s[\"abstractStatics\"] ? {} : {\n    statics: s[\"abstractStatics\"];\n});\n\nexport { type AndPreserveUnknown, type AppendOptions, type AppendStringifiedKeyFn, type ArkRegistry, type BigintLiteral, type Brand, type BuiltinObjectKind, type BuiltinObjects, Callable, type CallableOptions, CastableBase, type CollapsingList, type ComparisonOptions, type Completion, type Constructor, type DescribeOptions, type Dict, type Digit, type Domain, DynamicBase, DynamicFunction, type EcmascriptObjects, type EmptyObject, type Entry, type ErrorMessage, type ErrorType, type EscapeChar, FileConstructor, type FlatMorph, type Fn, type GlobalName, type GroupableEntry, type GroupedEntry, type GuardablePredicate, Hkt, type InitialRegistryContents, InnerDynamicBase, type IntegerLiteral, InternalArktypeError, type JsTypeOf, type Json, type JsonArray, type JsonObject, type JsonPrimitive, type JsonStructure, type Key, type KeySet, type ListableEntry, type NonEmptyList, type NonNegativeIntegerLiteral, type NonNullishDomain, NoopBase, type NullishDomain, type NumberLiteral, type NumericParseOptions, ParseError, type PartialRecord, type PlatformObjects, type Primitive, type PrimitiveDomain, ReadonlyArray, ReadonlyPath, RegexPatterns, Scanner, type SerializablePrimitive, type SerializationOptions, type SerializedPrimitive, type SerializedPrimitives, type Stringifiable, type StringifyPathFn, type StringifyPathOptions, type Thunk, Trait, type TraitComposition, type TraitCompositionKind, type TraitConstructor, type TraitDeclaration, type TraitImplementation, type TypeGuard, type TypedArrayObjects, type UnknownUnion, type WhitespaceChar, type ZeroWidthSpace, ancestorsOf, anchoredRegex, anchoredSource, type andPreserveUnknown, type anyOrNever, append, appendStringifiedKey, appendUnique, type appendableValue, type arkGet, type arkIndexableOf, type arkKeyOf, arkUtilVersion, type array, arrayEquals, type arrayIndexOf, type autocomplete, brand, builtinConstructors, cached, capitalize, type charsAfterFirst, type charsBeforeLast, compose, type composeTraits, conflatenate, conflatenateAll, type conform, constructorExtends, deanchoredRegex, deanchoredSource, deepClone, defineProperties, type defined, type describe, describeCollapsibleDate, type describeDefaults, type describeDomainOf, type describeObject, type dict, domainDescriptions, domainOf, ecmascriptConstructors, ecmascriptDescriptions, emojiToUnicode, entriesOf, type entryOf, enumValues, envHasCsp, type equals, escapeChar, type evaluate, type exact, type exactEquals, type exactMessageOnError, type extractDefinedKey, type extractKeyed, type filter, type firstChar, flatMorph, type flattenListable, fromEntries, type fromMappedEntries, getBuiltinNameOfConstructor, getDuplicatesOf, getPath, groupBy, type groupableKeyOf, hasDefinedKey, hasDomain, hasKey, hasObjectKind, hasTrait, type headOf, type ifEmptyObjectLiteral, implement, type implementationOf, includes, type inferDomain, inferred, type initOf, initialRegistryContents, type instanceOf, integerLikeMatcher, type intersectArrays, type intersectOverloadReturns, type intersectParameters, type intersectUnion, intersectUniqueLists, invert, isArray, type isDisjoint, isDotAccessible, isEmptyObject, isKeyOf, isNumericString, type isSafelyMappable, type isStringLiteral, isThunk, isWellFormedInteger, isWellFormedNumber, isomorphic, join, jsTypeOfDescriptions, type keyOf, type keySetOf, type keyWithValue, keysOf, type lastChar, type lastIndexOf, type lastOf, lazily, type leftIfEqual, liftArray, type listable, type merge, type mergeExact, type mutable, narrow, nearestFloat, noSuggest, type normalizedKeyOf, numberLikeMatcher, type numericStringKeyOf, numericStringMatcher, objectKindDescriptions, objectKindOf, objectKindOrDomainOf, omit, type optionalKeyOf, type overlaps, type overloadOf, type override, type parseInteger, type parseNonNegativeInteger, type parseNumber, type pathToString, pick, platformConstructors, platformDescriptions, print, printable, type promisable, type propValueOf, type propertyDescriptorsOf, type propwiseXor, range, register, registry, type repeat, type require, type requireKeys, type requiredKeyOf, type satisfy, serializePrimitive, shallowClone, type show, snapshot, splitByKeys, spliterate, stringAndSymbolicEntriesOf, stringifyPath, type stringifyUnion, type tailOf, throwError, throwInternalError, throwParseError, type thunkable, type toArkKey, type trim, type trimEnd, type trimStart, tryCatch, tryParseInteger, tryParseNumber, tryParseWellFormedBigint, tryParseWellFormedNumber, type typeToString, typedArrayConstructors, typedArrayDescriptions, type unbrand, uncapitalize, type unionKeyOf, type unionToPropwiseXor, type unionToTuple, unset, type validateExhaustiveKeys, wellFormedIntegerMatcher, wellFormedNumberMatcher, whitespaceChars, type widen, withAlphabetizedKeys, type withJsDoc, type writeInvalidKeysMessage, writeMalformedNumericLiteralMessage, zeroWidthSpace };\n\n}"
