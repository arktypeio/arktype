/** THIS FILE IS AUTOGENERATED FROM ark/repo/dtsGen.ts **/
// prettier-ignore
export const regexDts = "declare module \"@ark/regex\" {\n    import { Scanner, conform, array, longerThan, leftIfEqual, contains, ZeroWidthSpace, WhitespaceChar, ErrorMessage, Backslash, writeUnclosedGroupMessage, inferred } from '@ark/util';\n\ntype parseBuiltinQuantifier<s extends State, quantifier extends QuantifyingChar, unscanned extends string> = s[\"root\"] extends \"\" ? s.error<writeUnmatchedQuantifierError<quantifier>> : s.pushQuantified<s, quantifyBuiltin<quantifier, s[\"root\"]>, unscanned extends Scanner.shift<\"?\", infer lazyUnscanned> ? lazyUnscanned : unscanned>;\ntype ParsedRange = {\n    min: number;\n    max: number | null;\n    unscanned: string;\n};\ndeclare namespace ParsedRange {\n    type from<r extends ParsedRange> = r;\n}\ntype skipPossibleQuestionMark<unscanned extends string> = unscanned extends `?${infer next}` ? next : unscanned;\ntype parsePossibleRangeString<unscanned extends string> = unscanned extends (`${infer l extends number},${infer r extends number}}${infer next}`) ? ParsedRange.from<{\n    min: l;\n    max: r;\n    unscanned: skipPossibleQuestionMark<next>;\n}> : unscanned extends `${infer l extends number},}${infer next}` ? ParsedRange.from<{\n    min: l;\n    max: null;\n    unscanned: skipPossibleQuestionMark<next>;\n}> : unscanned extends `${infer l extends number}}${infer next}` ? ParsedRange.from<{\n    min: l;\n    max: l;\n    unscanned: skipPossibleQuestionMark<next>;\n}> : null;\ntype parsePossibleRange<s extends State, unscanned extends string, parsed extends ParsedRange | null = parsePossibleRangeString<unscanned>> = parsed extends ParsedRange ? s[\"root\"] extends \"\" ? s.error<writeUnmatchedQuantifierError<unscanned extends `${infer range}${parsed[\"unscanned\"]}` ? `{${range}` : never>> : applyQuantified<s, conform<quantify<s[\"root\"], parsed[\"min\"], parsed[\"max\"]>, PatternTree>, parsed[\"unscanned\"]> : s.shiftQuantifiable<s, \"{\", unscanned>;\ntype applyQuantified<s extends State, quantified extends PatternTree, unscanned extends string> = s.pushQuantified<s, quantified, unscanned extends Scanner.shift<\"?\", infer lazyUnscanned> ? lazyUnscanned : unscanned>;\ntype quantifyBuiltin<quantifier extends QuantifyingChar, tree extends PatternTree> = quantifier extends \"?\" ? UnionTree<[tree, \"\"], [...depthOf<tree>, 1]> : quantifier extends \"+\" ? pushQuantifiable<tree, string> : quantifier extends \"*\" ? UnionTree<[pushQuantifiable<tree, string>, \"\"], [...depthOf<tree>, 1]> : never;\ntype quantify<base extends PatternTree, min extends number, max extends number | null> = _loopUntilMin<base, depthOf<base>, min, max, [], [1]>;\ntype _loopUntilMin<base extends PatternTree, baseDepth extends 1[], min extends number, max extends number | null, repetitions extends PatternTree[], repetitionDepth extends 1[]> = repetitions[\"length\"] extends min ? max extends number ? max extends min ? repetitions[\"length\"] extends 1 ? repetitions[0] : SequenceTree<repetitions, repetitionDepth> : _loopUntilMax<base, baseDepth, min, max, repetitions, repetitionDepth, [\n    SequenceTree<repetitions, repetitionDepth>\n], repetitionDepth> : SequenceTree<[...repetitions, string], repetitionDepth> : _loopUntilMin<base, baseDepth, min, max, [\n    ...repetitions,\n    base\n], array.multiply<repetitionDepth, baseDepth[\"length\"]>>;\ntype _loopUntilMax<base extends PatternTree, baseDepth extends 1[], min extends number, max extends number, repetitions extends PatternTree[], repetitionDepth extends 1[], branches extends SequenceTree[], branchesDepth extends 1[], nextRepetitions extends PatternTree[] = [...repetitions, base], nextRepetitionDepth extends 1[] = array.multiply<repetitionDepth, baseDepth[\"length\"]>> = repetitions[\"length\"] extends max ? UnionTree<branches, branchesDepth> : _loopUntilMax<base, baseDepth, min, max, nextRepetitions, nextRepetitionDepth, [\n    ...branches,\n    SequenceTree<nextRepetitions, nextRepetitionDepth>\n], [\n    ...branchesDepth,\n    ...nextRepetitionDepth\n]>;\ntype QuantifyingChar = \"*\" | \"+\" | \"?\";\ndeclare const writeUnmatchedQuantifierError: <quantifier extends string>(quantifier: quantifier) => writeUnmatchedQuantifierError<quantifier>;\ntype writeUnmatchedQuantifierError<quantifier extends string> = `Quantifier ${quantifier} requires a preceding token`;\n\ninterface State extends State.Group {\n    unscanned: string;\n    captures: Record<string | number, unknown>;\n    groups: State.Group[];\n}\ndeclare namespace State {\n    type from<s extends State> = s;\n    type initialize<source extends string, flags extends string> = from<{\n        unscanned: source;\n        groups: [];\n        captures: {};\n        name: never;\n        branches: [];\n        sequence: SequenceTree.Empty;\n        root: \"\";\n        caseInsensitive: contains<flags, \"i\">;\n    }>;\n    type Group = {\n        name: string | number;\n        branches: PatternTree[];\n        sequence: PatternTree;\n        root: PatternTree;\n        caseInsensitive: boolean;\n    };\n    namespace Group {\n        type from<g extends Group> = g;\n        type pop<init extends Group, last extends Group[]> = [...last, init];\n        type finalize<g extends Group> = g[\"branches\"] extends [] ? pushQuantifiable<g[\"sequence\"], g[\"root\"]> : UnionTree<[\n            ...g[\"branches\"],\n            pushQuantifiable<g[\"sequence\"], g[\"root\"]>\n        ], [\n            1\n        ]>;\n        type branchStateToTree<branches extends PatternTree[]> = UnionTree<branches, unionDepth<branches, [1]>>;\n        type unionDepth<branches extends unknown[], depth extends 1[]> = branches extends [infer head, ...infer tail] ? unionDepth<tail, [...depth, ...depthOf<head>]> : depth;\n    }\n}\ntype Boundary = Anchor | \"(\" | \")\" | \"[\" | \"]\";\ntype Anchor = \"^\" | \"$\";\ntype Control = QuantifyingChar | Boundary | \"|\" | \".\" | \"{\" | \"-\" | \"\\\\\";\ntype AnchorMarker<inner extends Anchor = Anchor> = `<${ZeroWidthSpace}${inner}${ZeroWidthSpace}>`;\ntype PatternTree = string | UnionTree | SequenceTree;\ninterface SequenceTree<elements extends PatternTree[] = PatternTree[], depth extends 1[] = 1[]> {\n    sequence: elements;\n    depth: depth;\n}\ndeclare namespace SequenceTree {\n    type Empty = SequenceTree<[], [1]>;\n    type finalize<self extends SequenceTree> = longerThan<self[\"depth\"], ArkEnv.maxDepth> extends true ? `${self[\"depth\"][\"length\"]}` : _finalize<self[\"sequence\"], self[\"depth\"], \"\">;\n    type _finalize<tree extends unknown[], depth extends 1[], result extends string> = tree extends [infer head, ...infer tail] ? _finalize<tail, depth, appendNonRedundant<result, finalizeTree<head>>> : result;\n}\ninterface UnionTree<branches extends PatternTree[] = PatternTree[], depth extends 1[] = 1[]> {\n    union: branches;\n    depth: depth;\n}\ndeclare namespace UnionTree {\n    type finalize<self extends UnionTree> = longerThan<self[\"depth\"], ArkEnv.maxDepth> extends true ? \"toolong\" : _finalize<self[\"union\"], never>;\n    type _finalize<branches extends unknown[], pattern extends string> = branches extends [infer head, ...infer tail] ? _finalize<tail, pattern | finalizeTree<head>> : pattern;\n}\ndeclare global {\n    export interface ArkEnv {\n        maxDepth(): 1000;\n    }\n    export namespace ArkEnv {\n        type maxDepth = ReturnType<ArkEnv[\"maxDepth\"]>;\n    }\n}\ntype pushQuantifiable<sequence extends PatternTree, root extends PatternTree> = root extends \"\" ? sequence : sequence extends string ? sequence extends \"\" ? root : SequenceTree<[sequence, root], depthOf<root>> : sequence extends SequenceTree ? sequence extends SequenceTree.Empty ? root : pushToSequence<sequence, root> : SequenceTree<[\n    sequence,\n    root\n], array.multiply<depthOf<sequence>, depthOf<root>[\"length\"]>>;\ntype pushToSequence<sequence extends SequenceTree, root extends PatternTree> = root extends string ? SequenceTree<[...sequence[\"sequence\"], root], sequence[\"depth\"]> : root extends SequenceTree<infer rootSequence, infer rootDepth> ? SequenceTree<[\n    ...sequence[\"sequence\"],\n    ...rootSequence\n], array.multiply<sequence[\"depth\"], rootDepth[\"length\"]>> : root extends UnionTree<any, infer rootDepth> ? SequenceTree<[\n    ...sequence[\"sequence\"],\n    root\n], array.multiply<sequence[\"depth\"], rootDepth[\"length\"]>> : never;\ntype depthOf<tree> = tree extends {\n    depth: infer depth extends 1[];\n} ? depth : [1];\ntype finalizeTree<tree> = tree extends string ? tree : tree extends SequenceTree ? SequenceTree.finalize<tree> : tree extends UnionTree ? UnionTree.finalize<tree> : never;\ntype appendNonRedundant<base extends string, suffix extends string> = leftIfEqual<base, `${base}${suffix}`>;\n\ntype parseEscape<s extends State, unscanned extends string> = unscanned extends Scanner.shift<infer char, infer nextUnscanned> ? char extends NonZeroDigit ? parseNumericBackreference<s, unscanned> : char extends \"k\" ? parseNamedBackreference<s, nextUnscanned> : char extends UnicodePropertyChar ? parseUnicodeProperty<s, char, nextUnscanned> : parseSingleEscapedCharacter<s, char, nextUnscanned> : s.error<trailingBackslashMessage>;\ntype parseNumericBackreference<s extends State, fullUnscanned extends string> = fullUnscanned extends (`${infer ref extends keyof s[\"captures\"] & number}${infer remaining}`) ? s.shiftQuantifiable<s, getCapturedSequence<s[\"captures\"], ref>, remaining> : fullUnscanned extends `${infer b extends bigint}${string}` ? s.error<writeUnresolvableBackreferenceMessage<`${b}`>> : never;\ntype parseNamedBackreference<s extends State, unscanned extends string> = unscanned extends `<${infer ref}>${infer following}` ? ref extends keyof s[\"captures\"] ? s.shiftQuantifiable<s, getCapturedSequence<s[\"captures\"], ref>, following> : s.error<writeUnresolvableBackreferenceMessage<ref>> : s.error<missingBackreferenceNameMessage>;\ntype getCapturedSequence<captures, ref extends keyof captures> = captures[ref] extends PatternTree ? captures[ref] : \"\";\ntype parseUnicodeProperty<s extends State, char extends UnicodePropertyChar, unscanned extends string> = unscanned extends `{${string}}${infer following}` ? s.shiftQuantifiable<s, string, following> : s.error<writeInvalidUnicodePropertyMessage<char>>;\ntype parseSingleEscapedCharacter<s extends State, char extends string, remaining extends string> = parseEscapedChar<char> extends infer result extends string ? result extends ErrorMessage ? s.error<result> : s.shiftQuantifiable<s, result, remaining> : never;\ntype parseEscapedChar<char extends string> = char extends RegexClassChar ? string : char extends \"d\" ? `${bigint}` : char extends \"s\" ? WhitespaceChar : char extends BoundaryChar ? \"\" : char extends Control ? char : char extends \"c\" ? ErrorMessage<caretNotationMessage> : char extends StringEscapableChar ? ErrorMessage<writeStringEscapableMessage<char>> : ErrorMessage<writeUnnecessaryEscapeMessage<char>>;\ndeclare const trailingBackslashMessage = \"A regex cannot end with \\\\\";\ntype trailingBackslashMessage = typeof trailingBackslashMessage;\ndeclare const writeUnresolvableBackreferenceMessage: <ref extends string>(ref: ref) => writeUnresolvableBackreferenceMessage<ref>;\ntype writeUnresolvableBackreferenceMessage<ref extends string> = `Group ${ref} does not exist`;\ndeclare const missingBackreferenceNameMessage = \"\\\\k must be followed by a named reference like <name>\";\ntype missingBackreferenceNameMessage = typeof missingBackreferenceNameMessage;\ndeclare const writeInvalidUnicodePropertyMessage: <char extends UnicodePropertyChar>(char: char) => writeInvalidUnicodePropertyMessage<char>;\ntype writeInvalidUnicodePropertyMessage<char extends UnicodePropertyChar> = `\\\\${char} must be followed by a property like \\\\${char}{Emoji_Presentation}`;\ndeclare const writeUnnecessaryEscapeMessage: <char extends string>(char: char) => writeUnnecessaryEscapeMessage<char>;\ntype writeUnnecessaryEscapeMessage<char extends string> = `Escape preceding ${char} is unnecessary and should be removed.`;\ndeclare const writeStringEscapableMessage: <char extends StringEscapableChar>(char: char) => writeStringEscapableMessage<char>;\ntype writeStringEscapableMessage<char extends StringEscapableChar> = `\\\\${char} should be specified with a single backslash like regex('\\n')`;\ndeclare const caretNotationMessage = \"\\\\cX notation is not supported. Use hex (\\\\x) or unicode (\\\\u) instead.\";\ntype caretNotationMessage = typeof caretNotationMessage;\ntype StringEscapableChar = \"t\" | \"n\" | \"r\" | \"f\" | \"v\" | \"0\" | \"x\" | \"u\";\ntype RegexClassChar = \"w\" | \"W\" | \"D\" | \"S\";\ntype BoundaryChar = \"b\" | \"B\";\ntype UnicodePropertyChar = \"p\" | \"P\";\ntype NonZeroDigit = \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\";\n\ntype parseCharset<s extends State, unscanned extends string> = Scanner.shiftUntilEscapable<unscanned, \"]\", Backslash> extends (Scanner.shiftResult<infer scanned, infer nextUnscanned>) ? nextUnscanned extends `]${infer remaining}` ? scanned extends Scanner.shift<\"^\", string> ? s.shiftQuantifiable<s, string, remaining> : parseNonNegatedCharset<scanned, []> extends infer branches ? branches extends string[] ? branches extends [] ? s.error<emptyCharacterSetMessage> : s.shiftQuantifiable<s, UnionTree<branches, {\n    [i in keyof branches]: 1;\n}>, remaining> : never : never : writeUnclosedGroupMessage<\"]\"> : never;\ntype parseNonNegatedCharset<chars extends string, set extends string[]> = parseChar<chars> extends Scanner.shiftResult<infer result, infer unscanned> ? result extends UnescapedDashMarker ? parseDash<unscanned, set> : result extends ErrorMessage ? result : parseNonNegatedCharset<unscanned, [...set, result]> : set;\ntype parseDash<unscanned extends string, set extends string[]> = set extends [] ? parseNonNegatedCharset<unscanned, [\"-\"]> : parseChar<unscanned> extends Scanner.shiftResult<string, infer next> ? next extends `-${infer postLiteralDash}` ? parseNonNegatedCharset<postLiteralDash, [...set, string, \"-\"]> : parseNonNegatedCharset<next, [...set, string]> : [\n    ...set,\n    \"-\"\n];\ntype UnescapedDashMarker = \"dash\";\ntype parseChar<unscanned extends string> = unscanned extends Scanner.shift<infer lookahead, infer next> ? lookahead extends Backslash ? next extends Scanner.shift<infer escaped, infer postEscaped> ? Scanner.shiftResult<parseEscapedChar<escaped>, postEscaped> : never : Scanner.shiftResult<lookahead extends \"-\" ? UnescapedDashMarker : lookahead, next> : null;\ndeclare const emptyCharacterSetMessage = \"Empty character set [] is unsatisfiable\";\ntype emptyCharacterSetMessage = typeof emptyCharacterSetMessage;\n\ntype LookaroundChar = \"=\" | \"!\";\ntype ModifiableFlag = \"i\" | \"m\" | \"s\";\ntype parseGroup<s extends State, unscanned extends string> = unscanned extends Scanner.shift<infer lookahead, infer next> ? lookahead extends \"?\" ? parseNonCapturingGroup<s, next> : s.pushGroup<s, nextCaptureIndex<s[\"captures\"]>, unscanned, false, undefined> : s.error<writeUnclosedGroupMessage<\")\">>;\ntype parseNonCapturingGroup<s extends State, unscanned extends string> = unscanned extends Scanner.shift<infer lookahead, infer next> ? lookahead extends \":\" ? s.pushGroup<s, never, next, false, undefined> : lookahead extends LookaroundChar ? s.pushGroup<s, never, next, true, undefined> : lookahead extends \"<\" ? parseNamedGroupOrLookbehind<s, next> : shiftModifiers<unscanned> extends (ShiftedModifiers<infer flags, infer negated, infer following>) ? following extends ErrorMessage<infer message> ? s.error<message> : s.pushGroup<s, never, following, false, \"i\" extends flags ? true : \"i\" extends negated ? false : undefined> : never : s.error<writeUnclosedGroupMessage<\")\">>;\ntype ShiftedModifiers<flags extends ModifiableFlag = ModifiableFlag, negated extends ModifiableFlag = ModifiableFlag, unscanned extends string = string> = [ParsedModifiers<flags, negated>, unscanned];\ntype ParsedModifiers<flags extends ModifiableFlag = ModifiableFlag, negated extends ModifiableFlag = ModifiableFlag> = {\n    flags: flags;\n    negated: negated;\n};\ntype shiftModifiers<unscanned extends string> = Scanner.shiftUntil<unscanned, \":\" | \")\"> extends (Scanner.shiftResult<infer scanned, infer next>) ? next extends Scanner.shift<infer terminator, infer following> ? terminator extends \":\" ? parseModifiers<scanned> extends (ParsedModifiers<infer flags, infer negated>) ? ShiftedModifiers<flags, negated, following> : ShiftedModifiers<never, never, ErrorMessage<parseModifiers<scanned> & string>> : ShiftedModifiers<never, never, ErrorMessage<unescapedLiteralQuestionMarkMessage>> : ShiftedModifiers<never, never, ErrorMessage<writeUnclosedGroupMessage<\")\">>> : never;\ntype parseModifiers<unscanned extends string> = _parseModifiers<unscanned, never, never>;\ntype _parseModifiers<unscanned extends string, flags extends ModifiableFlag, negated extends ModifiableFlag> = unscanned extends Scanner.shift<infer lookahead, infer next> ? lookahead extends \"-\" ? [\n    negated\n] extends [never] ? next extends Scanner.shift<infer modifier, infer next> ? modifier extends ModifiableFlag ? modifier extends flags | negated ? writeDuplicateModifierMessage<modifier> : _parseModifiers<next, flags, negated | modifier> : writeInvalidModifierMessage<modifier> : missingNegatedModifierMessage : multipleModifierDashesMessage : lookahead extends ModifiableFlag ? lookahead extends flags | negated ? writeDuplicateModifierMessage<lookahead> : [\n    negated\n] extends [never] ? _parseModifiers<next, flags | lookahead, negated> : _parseModifiers<next, flags, negated | lookahead> : writeInvalidModifierMessage<lookahead> : ParsedModifiers<flags, negated>;\ndeclare const writeDuplicateModifierMessage: <modifier extends ModifiableFlag>(modifier: modifier) => writeDuplicateModifierMessage<modifier>;\ntype writeDuplicateModifierMessage<modifier extends ModifiableFlag> = `modifier ${modifier} cannot appear multiple times in a single group`;\ndeclare const multipleModifierDashesMessage = \"modifiers can include at most one '-' to negate subsequent flags\";\ntype multipleModifierDashesMessage = typeof multipleModifierDashesMessage;\ndeclare const missingNegatedModifierMessage = \"- must be followed by the modifier flag to negate ('i', 'm' or 's')\";\ntype missingNegatedModifierMessage = typeof missingNegatedModifierMessage;\ndeclare const writeInvalidModifierMessage: <char extends string>(char: char) => writeInvalidModifierMessage<char>;\ntype writeInvalidModifierMessage<char extends string> = `Modifier flag ${char} must be 'i', 'm' or 's'`;\ntype parseNamedGroupOrLookbehind<s extends State, unscanned extends string> = unscanned extends Scanner.shift<LookaroundChar, infer next> ? s.pushGroup<s, never, next, true, undefined> : shiftNamedGroup<unscanned> extends (Scanner.shiftResult<infer name, infer following>) ? s.pushGroup<s, name | nextCaptureIndex<s[\"captures\"]>, following, false, undefined> : s.error<writeUnclosedGroupMessage<\")\">>;\ntype shiftNamedGroup<unscanned extends string> = unscanned extends `${infer name}>${infer next}` ? name extends \"\" ? Scanner.shiftResult<\"\", ErrorMessage<unnamedCaptureGroupMessage>> : Scanner.shiftResult<name, next> : Scanner.shiftResult<\"\", ErrorMessage<writeUnclosedGroupMessage<\">\">>>;\ntype nextCaptureIndex<captures, counter extends 1[] = [1]> = counter[\"length\"] extends keyof captures ? nextCaptureIndex<captures, [...counter, 1]> : counter[\"length\"];\ndeclare const unnamedCaptureGroupMessage = \"Capture group <> requires a name\";\ntype unnamedCaptureGroupMessage = typeof unnamedCaptureGroupMessage;\ndeclare const unescapedLiteralQuestionMarkMessage = \"literal ? must be escaped at the start of a group\";\ntype unescapedLiteralQuestionMarkMessage = typeof unescapedLiteralQuestionMarkMessage;\n\ntype parseState<s extends State> = s[\"unscanned\"] extends ErrorMessage ? Regex<s[\"unscanned\"]> : s[\"unscanned\"] extends \"\" ? s.finalize<s> : parseState<next<s>>;\ntype next<s extends State> = s[\"unscanned\"] extends Scanner.shift<infer lookahead, infer unscanned> ? lookahead extends \".\" ? s.shiftQuantifiable<s, string, unscanned> : lookahead extends Backslash ? parseEscape<s, unscanned> : lookahead extends \"|\" ? s.finalizeBranch<s, unscanned> : lookahead extends Anchor ? s.anchor<s, AnchorMarker<lookahead>, unscanned> : lookahead extends \"(\" ? parseGroup<s, unscanned> : lookahead extends \")\" ? s.popGroup<s, unscanned> : lookahead extends QuantifyingChar ? parseBuiltinQuantifier<s, lookahead, unscanned> : lookahead extends \"{\" ? parsePossibleRange<s, unscanned> : lookahead extends \"[\" ? parseCharset<s, unscanned> : s.shiftQuantifiable<s, maybeSplitCasing<s[\"caseInsensitive\"], lookahead>, unscanned> : never;\ntype maybeSplitCasing<caseInsensitive extends boolean, char extends string> = caseInsensitive extends false ? char : Lowercase<char> extends Uppercase<char> ? char : UnionTree<[Lowercase<char>, Capitalize<char>], [1, 1]>;\n\ninterface Regex<pattern extends string = string, groups extends Record<string | number, string> = {}> extends RegExp {\n    [inferred]: pattern;\n    infer: pattern;\n    inferGroups: groups;\n    test(s: string): s is pattern;\n}\ndeclare const regex: <src extends string, flags extends string = \"\">(src: regex.validate<src>, flags?: flags) => regex.parse<src, flags>;\ntype regex<pattern extends string = string, groups extends Record<string | number, string> = {}> = Regex<pattern, groups>;\ndeclare namespace regex {\n    type parse<src extends string, flags extends string = \"\"> = parseState<State.initialize<src, flags>>;\n    type infer<src extends string, flags extends string = \"\"> = parse<src, flags> extends Regex<infer pattern> ? pattern : never;\n    type validate<src extends string, flags extends string = \"\"> = parse<src, flags> extends Regex<infer e extends ErrorMessage> ? e : src;\n}\n\nexport { type Regex, regex };\n\n}"
