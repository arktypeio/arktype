/** THIS FILE IS AUTOGENERATED FROM ark/repo/dtsGen.ts **/
// prettier-ignore
export const regexDts = "declare module \"@ark/regex\" {\n    import { Scanner, ErrorMessage, conform, leftIfEqual, WhitespaceChar, Backslash, writeUnclosedGroupMessage, inferred } from '@ark/util';\n\ntype NonEmptyQuantifiable = [string, ...string[]];\ntype parseBuiltinQuantifier<s extends State, quantifier extends BuiltinQuantifier, unscanned extends string> = s[\"quantifiable\"] extends NonEmptyQuantifiable ? s.pushQuantified<s, quantifyBuiltin<quantifier, s[\"quantifiable\"]>, unscanned extends Scanner.shift<\"?\", infer lazyUnscanned> ? lazyUnscanned : unscanned> : s.error<writeUnmatchedQuantifierError<quantifier>>;\ntype ParsedRange = {\n    min: number;\n    max: number | null;\n    unscanned: string;\n};\ndeclare namespace ParsedRange {\n    type from<r extends ParsedRange> = r;\n}\ntype skipPossibleQuestionMark<unscanned extends string> = unscanned extends `?${infer next}` ? next : unscanned;\ntype parsePossibleRangeString<unscanned extends string> = unscanned extends (`${infer l extends number},${infer r extends number}}${infer next}`) ? ParsedRange.from<{\n    min: l;\n    max: r;\n    unscanned: skipPossibleQuestionMark<next>;\n}> : unscanned extends `${infer l extends number},}${infer next}` ? ParsedRange.from<{\n    min: l;\n    max: null;\n    unscanned: skipPossibleQuestionMark<next>;\n}> : unscanned extends `${infer l extends number}}${infer next}` ? ParsedRange.from<{\n    min: l;\n    max: l;\n    unscanned: skipPossibleQuestionMark<next>;\n}> : null;\ntype parsePossibleRange<s extends State, unscanned extends string, parsed extends ParsedRange | null = parsePossibleRangeString<unscanned>> = parsed extends ParsedRange ? s[\"quantifiable\"] extends NonEmptyQuantifiable ? applyQuantified<s, quantify<s[\"quantifiable\"], parsed[\"min\"], parsed[\"max\"]>, parsed[\"unscanned\"]> : s.error<writeUnmatchedQuantifierError<unscanned extends `${infer range}${parsed[\"unscanned\"]}` ? `{${range}` : never>> : s.shiftQuantifiable<s, [\"{\"], unscanned>;\ntype applyQuantified<s extends State, quantified, unscanned extends string> = s.pushQuantified<s, conform<quantified, string[]>, unscanned extends Scanner.shift<\"?\", infer lazyUnscanned> ? lazyUnscanned : unscanned>;\ntype quantifyBuiltin<quantifier extends BuiltinQuantifier, token extends NonEmptyQuantifiable> = quantifier extends \"?\" ? [...token, \"\"] : quantifier extends \"+\" ? suffix<token, string> : quantifier extends \"*\" ? [\"\", ...suffix<token, string>] : never;\ntype quantify<token extends NonEmptyQuantifiable, min extends number, max extends number | null> = _loopUntilMin<token, min, max, [], {\n    [i in keyof token]: \"\";\n}>;\ntype _loopUntilMin<token extends NonEmptyQuantifiable, min extends number, max extends number | null, i extends 1[], repetitions extends string[]> = i[\"length\"] extends min ? max extends number ? _loopUntilMax<token, min, max, i, repetitions> : suffix<repetitions, string> : _loopUntilMin<token, min, max, [\n    ...i,\n    1\n], {\n    [i in keyof token]: `${repetitions[i & keyof repetitions]}${token[i]}`;\n}>;\ntype _loopUntilMax<quantifiable extends NonEmptyQuantifiable, min extends number, max extends number, i extends 1[], repetitions extends string[]> = i[\"length\"] extends max ? repetitions : [\n    ...repetitions,\n    ..._loopUntilMax<quantifiable, min, max, [\n        ...i,\n        1\n    ], {\n        [i in keyof quantifiable]: `${repetitions[i & keyof repetitions]}${quantifiable[i]}`;\n    }>\n];\ntype BuiltinQuantifier = \"*\" | \"+\" | \"?\";\ntype writeUnmatchedQuantifierError<quantifier extends string> = ErrorMessage<`Quantifier ${quantifier} requires a preceding token`>;\ntype suffix<token extends string[], suffix extends string> = [\n    ...token,\n    ...{\n        [i in keyof token]: `${token[i]}${suffix}`;\n    }\n];\n\ninterface State extends State.Group {\n    unscanned: string;\n    groups: State.Group[];\n}\ndeclare namespace State {\n    type from<s extends State> = s;\n    type initialize<source extends string> = from<{\n        unscanned: source;\n        groups: [];\n        branches: [];\n        sequence: [\"\"];\n        quantifiable: [];\n    }>;\n    type Group = {\n        branches: string[];\n        sequence: string[];\n        quantifiable: string[];\n    };\n    namespace Group {\n        type from<g extends Group> = g;\n        type pop<init extends Group, last extends Group[]> = [...last, init];\n        type finalize<g extends Group> = from<{\n            branches: [\n                ...g[\"branches\"],\n                ...appendQuantifiableOuter<g[\"sequence\"], g[\"quantifiable\"]>\n            ];\n            sequence: [\"\"];\n            quantifiable: [];\n        }>;\n    }\n}\ntype Boundary = Anchor | \"(\" | \")\" | \"[\" | \"]\";\ntype Anchor = \"^\" | \"$\";\ntype Control = BuiltinQuantifier | Boundary | \"|\" | \".\" | \"{\" | \"-\" | \"\\\\\";\ntype shiftTokens<head extends string, tail extends string[]> = [head, ...tail];\ntype appendQuantifiableOuter<sequence extends string[], quantifiable extends string[], result extends string[] = []> = quantifiable extends [] ? sequence : sequence extends shiftTokens<infer seqHead, infer seqTail> ? appendQuantifiableOuter<seqTail, quantifiable, [\n    ...result,\n    ...appendQuantifiableInner<seqHead, quantifiable, []>\n]> : result;\ntype appendQuantifiableInner<seqHead extends string, quantifiable extends string[], result extends string[]> = quantifiable extends (shiftTokens<infer quantifiableHead, infer quantifiableTail>) ? appendQuantifiableInner<seqHead, quantifiableTail, [\n    ...result,\n    appendNonRedundant<seqHead, quantifiableHead>\n]> : result;\ntype appendNonRedundant<base extends string, suffix extends string> = leftIfEqual<base, `${base}${suffix}`>;\n\ntype parseEscape<s extends State, unscanned extends string> = unscanned extends Scanner.shift<infer char, infer nextUnscanned> ? char extends `${bigint}` ? s.shiftQuantifiable<s, [\n    string\n], nextUnscanned extends `${bigint}${infer following}` ? following : nextUnscanned> : char extends \"k\" ? s.shiftQuantifiable<s, [\n    string\n], nextUnscanned extends `<${string}>${infer following}` ? following : ErrorMessage<\"\\\\k must be followed by a named reference like <name>\">> : parseEscapedChar<char> extends infer result extends string ? result extends ErrorMessage ? s.error<result> : s.shiftQuantifiable<s, [result], nextUnscanned> : never : s.error<`A regex cannot end with \\\\`>;\ntype parseEscapedChar<char extends string> = char extends StringClassChar ? string : char extends \"d\" ? `${bigint}` : char extends \"s\" ? WhitespaceChar : char extends Control ? char : ErrorMessage<`Escape preceding ${char} is unnecessary and should be removed.`>;\ntype StringClassChar = \"w\" | \"W\" | \"D\" | \"S\";\n\ntype parseCharset<s extends State, unscanned extends string> = Scanner.shiftUntil<unscanned, \"]\"> extends (Scanner.shiftResult<infer scanned, infer nextUnscanned>) ? nextUnscanned extends `]${infer remaining}` ? scanned extends Scanner.shift<\"^\", string> ? s.shiftQuantifiable<s, [string], remaining> : parseNonNegatedCharset<scanned, []> extends (infer result extends string[]) ? result extends [] ? s.error<\"Empty character set [] is unsatisfiable\"> : s.shiftQuantifiable<s, result, remaining> : never : writeUnclosedGroupMessage<\"]\"> : never;\ntype parseNonNegatedCharset<chars extends string, set extends string[]> = parseChar<chars> extends Scanner.shiftResult<infer result, infer unscanned> ? result extends UnescapedDashMarker ? parseDash<unscanned, set> : parseNonNegatedCharset<unscanned, [...set, result]> : set;\ntype parseDash<unscanned extends string, set extends string[]> = set extends [] ? parseNonNegatedCharset<unscanned, [\"-\"]> : unscanned extends Scanner.shift<infer rangeEnd, infer next> ? rangeEnd extends Backslash ? {} : next extends `-${infer postLiteralDash}` ? parseNonNegatedCharset<postLiteralDash, [...set, string, \"-\"]> : parseNonNegatedCharset<next, [...set, string]> : [\n    ...set,\n    \"-\"\n];\ntype UnescapedDashMarker = \"dash\";\ntype parseChar<unscanned extends string> = unscanned extends Scanner.shift<infer lookahead, infer next> ? lookahead extends Backslash ? next extends Scanner.shift<infer escaped, infer postEscaped> ? Scanner.shiftResult<parseEscapedChar<escaped>, postEscaped> : never : Scanner.shiftResult<lookahead extends \"-\" ? UnescapedDashMarker : lookahead, next> : null;\n\ntype parse<s extends State> = s[\"unscanned\"] extends \"\" ? s.finalize<s> : s[\"unscanned\"] extends ErrorMessage ? s[\"unscanned\"] : parse<next<s>>;\ntype next<s extends State> = s[\"unscanned\"] extends Scanner.shift<infer lookahead, infer unscanned> ? lookahead extends \".\" ? s.shiftQuantifiable<s, [string], unscanned> : lookahead extends Backslash ? parseEscape<s, unscanned> : lookahead extends \"|\" ? s.finalizeBranch<s, unscanned> : lookahead extends Anchor ? s.anchor<s, lookahead, unscanned> : lookahead extends \"(\" ? s.pushGroup<s, unscanned> : lookahead extends \")\" ? s.popGroup<s, unscanned> : lookahead extends BuiltinQuantifier ? parseBuiltinQuantifier<s, lookahead, unscanned> : lookahead extends \"{\" ? parsePossibleRange<s, unscanned> : lookahead extends \"[\" ? parseCharset<s, unscanned> : s.shiftQuantifiable<s, [lookahead], unscanned> : never;\n\ninterface Regex<pattern extends string = string> extends RegExp {\n    [inferred]: pattern;\n    infer: pattern;\n    test(s: string): s is pattern;\n}\ndeclare const regex: <src extends string>(src: regex.validate<src>) => Regex<regex.infer<src>>;\ntype regex<pattern extends string = string> = Regex<pattern>;\ndeclare namespace regex {\n    type infer<src extends string> = parse<State.initialize<src>>;\n    type validate<src extends string> = regex.infer<src> extends ErrorMessage ? regex.infer<src> : src;\n}\n\nexport { regex };\n\n}"
