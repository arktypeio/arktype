/** THIS FILE IS AUTOGENERATED FROM ark/repo/dtsGen.ts **/
// prettier-ignore
export const regexDts = "declare module \"arkregex\" {\n    import { DynamicBase, Scanner, parseNonNegativeInteger, ErrorMessage, NumberLiteral, noSuggest, setIndex, ZeroWidthSpace, unionKeyOf, contains, WhitespaceChar, Backslash, writeUnclosedGroupMessage, inferred } from '@ark/util';\n\ninterface RegexExecArray<patternAndCaptures extends IndexedCaptures, namedCaptures extends NamedCaptures, flags extends Flags> extends DynamicBase<patternAndCaptures> {\n    /**\n     * The index of the search at which the result was found.\n     */\n    index: number;\n    /**\n     * A copy of the search string.\n     */\n    input: patternAndCaptures[0];\n    indices: flags extends `${string}d${string}` ? RegexIndicesArray<patternAndCaptures, namedCaptures> : undefined;\n    groups: keyof namedCaptures extends never ? undefined : namedCaptures;\n}\ntype RegexIndexRange = [start: number, end: number];\ninterface RegexIndicesArray<patternAndCaptures extends IndexedCaptures, namedCaptures extends NamedCaptures> extends DynamicBase<{\n    [i in keyof patternAndCaptures]: RegexIndexRange;\n}> {\n    groups: keyof namedCaptures extends never ? undefined : {\n        [k in keyof namedCaptures]: RegexIndexRange;\n    };\n}\n\ntype parseBuiltinQuantifier<s extends State, quantifier extends QuantifyingChar, unscanned extends string> = s[\"root\"] extends \"\" ? s.error<writeUnmatchedQuantifierError<quantifier>> : quantifyBuiltin<s, quantifier, unscanned extends Scanner.shift<\"?\", infer lazyUnscanned> ? lazyUnscanned : unscanned>;\ntype quantifyBuiltin<s extends State, quantifier extends QuantifyingChar, unscanned extends string> = quantifier extends \"?\" ? s.pushQuantifier<s, 0, 1, unscanned> : quantifier extends \"+\" ? s.pushQuantifier<s, 1, null, unscanned> : quantifier extends \"*\" ? s.pushQuantifier<s, 0, null, unscanned> : never;\ntype ParsedRange = {\n    min: number;\n    max: number | null;\n    unscanned: string;\n};\ndeclare namespace ParsedRange {\n    type from<r extends ParsedRange> = r;\n}\ntype skipPossibleQuestionMark<unscanned extends string> = unscanned extends `?${infer next}` ? next : unscanned;\ntype parsePossibleRangeString<unscanned extends string> = unscanned extends (`${infer l extends `${number}`},${infer r extends `${number}`}}${infer next}`) ? ParsedRange.from<{\n    min: parseNonNegativeInteger<l>;\n    max: parseNonNegativeInteger<r>;\n    unscanned: skipPossibleQuestionMark<next>;\n}> : unscanned extends `${infer l extends `${number}`},}${infer next}` ? ParsedRange.from<{\n    min: parseNonNegativeInteger<l>;\n    max: null;\n    unscanned: skipPossibleQuestionMark<next>;\n}> : unscanned extends `${infer l extends `${number}`}}${infer next}` ? ParsedRange.from<{\n    min: parseNonNegativeInteger<l>;\n    max: parseNonNegativeInteger<l>;\n    unscanned: skipPossibleQuestionMark<next>;\n}> : null;\ntype parseQuantifier<unscanned extends string, parsed extends ParsedRange> = unscanned extends `${infer range}${parsed[\"unscanned\"]}` ? `{${range}` : never;\ntype parsePossibleRange<s extends State, unscanned extends string, parsed extends ParsedRange | null = parsePossibleRangeString<unscanned>> = parsed extends ParsedRange ? s[\"root\"] extends \"\" ? s.error<writeUnmatchedQuantifierError<parseQuantifier<unscanned, parsed>>> : [parsed[\"min\"], parsed[\"max\"]] extends ([\n    never,\n    unknown\n] | [unknown, never]) ? s.error<writeUnnaturalNumberQuantifierError<parseQuantifier<unscanned, parsed>>> : s.pushQuantifier<s, parsed[\"min\"], parsed[\"max\"], parsed[\"unscanned\"] extends Scanner.shift<\"?\", infer lazyUnscanned> ? lazyUnscanned : parsed[\"unscanned\"]> : s.shiftQuantifiable<s, \"{\", unscanned>;\ntype quantify<pattern extends string, min extends number, max extends number | null> = tryFastPath<pattern, min, max>;\ntype tryFastPath<pattern extends string, min extends number, max extends number | null> = max extends 0 ? \"\" : string extends pattern ? string : `${number}` extends pattern ? `${number}` : min extends 0 ? max extends 1 ? \"\" | pattern : max extends number ? loopFromZero<pattern, max, \"\", []> : // max is null, all we can do is append ${string}\n\"\" | `${pattern}${string}` : loopUntilMin<pattern, min, max, \"\", []>;\ntype loopFromZero<base extends string, max extends number, acc extends string, repetitions extends 1[]> = repetitions[\"length\"] extends max ? acc : loopFromZero<base, max, acc | `${acc}${base}`, [...repetitions, 1]>;\ntype loopUntilMin<base extends string, min extends number, max extends number | null, acc extends string, repetitions extends 1[]> = repetitions[\"length\"] extends min ? max extends number ? loopUntilMax<base, min, max, acc, repetitions> : repetitions[\"length\"] extends 0 ? acc | `${acc}${base}${string}` : `${acc}${string}` : loopUntilMin<base, min, max, `${acc}${base}`, [...repetitions, 1]>;\ntype loopUntilMax<base extends string, min extends number, max extends number, acc extends string, repetitions extends 1[]> = repetitions[\"length\"] extends max ? acc : loopUntilMax<base, min, max, acc | `${acc}${base}`, [...repetitions, 1]>;\ntype QuantifyingChar = \"*\" | \"+\" | \"?\";\ndeclare const writeUnmatchedQuantifierError: <quantifier extends string>(quantifier: quantifier) => writeUnmatchedQuantifierError<quantifier>;\ntype writeUnmatchedQuantifierError<quantifier extends string> = `Quantifier ${quantifier} requires a preceding token`;\ndeclare const writeUnnaturalNumberQuantifierError: <quantifier extends string>(quantifier: quantifier) => writeUnnaturalNumberQuantifierError<quantifier>;\ntype writeUnnaturalNumberQuantifierError<quantifier extends string> = `Quantifier ${quantifier} must use natural numbers`;\n\ninterface State extends State.Group {\n    unscanned: string;\n    groups: State.Group[];\n    /** the initial flags passed to the root of the expression */\n    flags: Flags;\n}\ndeclare namespace State {\n    type from<s extends State> = s;\n    type initialize<source extends string, flags extends Flags> = from<{\n        unscanned: source;\n        groups: [];\n        capture: never;\n        branches: [];\n        sequence: SequenceTree.Empty;\n        root: \"\";\n        caseInsensitive: contains<flags, \"i\">;\n        flags: flags;\n    }>;\n    enum UnnamedCaptureKind {\n        indexed,\n        lookaround,\n        noncapturing\n    }\n    type CaptureKind = string | UnnamedCaptureKind;\n    type Group = {\n        /** the name of the group or its kind */\n        capture: CaptureKind;\n        branches: RegexAst[];\n        sequence: RegexAst;\n        root: RegexAst;\n        caseInsensitive: boolean;\n    };\n    namespace Group {\n        type from<g extends Group> = g;\n        type pop<init extends Group, last extends Group[]> = [...last, init];\n        type finalize<g extends Group> = g[\"branches\"] extends [] ? pushQuantifiable<g[\"sequence\"], g[\"root\"]> : [...g[\"branches\"], pushQuantifiable<g[\"sequence\"], g[\"root\"]>] extends (infer branches extends RegexAst[]) ? finalizeUnion<branches, []> : never;\n        type finalizeUnion<remaining extends RegexAst[], flattened extends RegexAst[]> = remaining extends ([\n            infer head extends RegexAst,\n            ...infer tail extends RegexAst[]\n        ]) ? head extends UnionTree<infer headBranches> ? finalizeUnion<tail, [...flattened, ...headBranches]> : finalizeUnion<tail, [...flattened, head]> : UnionTree<flattened>;\n    }\n}\ntype Boundary = Anchor | \"(\" | \")\" | \"[\" | \"]\";\ntype Anchor = \"^\" | \"$\";\ntype Control = QuantifyingChar | Boundary | \"|\" | \".\" | \"{\" | \"-\" | \"\\\\\";\ntype AnchorMarker<inner extends Anchor = Anchor> = `<${ZeroWidthSpace}${inner}${ZeroWidthSpace}>`;\ntype StartAnchorMarker = AnchorMarker<\"^\">;\ntype EndAnchorMarker = AnchorMarker<\"$\">;\ntype RegexAst = string | ReferenceNode | UnionTree | SequenceTree | GroupTree | QuantifierTree;\ninterface ReferenceNode<to extends string = string> {\n    kind: \"reference\";\n    to: to;\n}\ndeclare namespace ReferenceNode {\n    type finalize<self extends ReferenceNode, ctx extends FinalizationContext, to extends string = self[\"to\"]> = to extends NumberLiteral & keyof ctx[\"captures\"] ? ctx[\"captures\"][to] extends IncompleteCaptureGroup ? FinalizationResult.error<ctx, writeIncompleteReferenceError<to>> : FinalizationResult.from<{\n        pattern: inferReference<ctx[\"captures\"][to]>;\n        ctx: ctx;\n    }> : to extends keyof ctx[\"names\"] ? ctx[\"names\"][to] extends IncompleteCaptureGroup ? FinalizationResult.error<ctx, writeIncompleteReferenceError<to>> : FinalizationResult.from<{\n        pattern: inferReference<ctx[\"names\"][to]>;\n        ctx: ctx;\n    }> : FinalizationResult.error<ctx, writeUnresolvableBackreferenceMessage<to>>;\n    type inferReference<to extends string | undefined> = to extends string ? to : \"\";\n}\ndeclare const writeIncompleteReferenceError: <ref extends string>(ref: ref) => writeIncompleteReferenceError<ref>;\ntype writeIncompleteReferenceError<ref extends string> = `Reference to incomplete group '${ref}' has no effect`;\ninterface SequenceTree<ast extends RegexAst[] = RegexAst[]> {\n    kind: \"sequence\";\n    ast: ast;\n}\ndeclare namespace SequenceTree {\n    type Empty = SequenceTree<[]>;\n    type finalize<self extends SequenceTree, ctx extends FinalizationContext> = _finalize<self[\"ast\"], \"\", ctx>;\n    type _finalize<tree extends unknown[], pattern extends string, ctx extends FinalizationContext> = tree extends [infer head, ...infer tail] ? finalizeTree<head, ctx> extends infer r ? r extends FinalizationResult ? _finalize<tail, appendNonRedundant<pattern, r[\"pattern\"]>, r[\"ctx\"]> : never : never : FinalizationResult.from<{\n        pattern: pattern;\n        ctx: ctx;\n    }>;\n}\ninterface UnionTree<ast extends RegexAst[] = RegexAst[]> {\n    kind: \"union\";\n    ast: ast;\n}\ndeclare namespace UnionTree {\n    type finalize<self extends UnionTree, ctx extends FinalizationContext> = _finalize<self[\"ast\"], [], ctx>;\n    type FinalizedBranch = {\n        pattern: string;\n        captures: IndexedCaptures;\n        names: NamedCaptures;\n    };\n    namespace FinalizedBranch {\n        type from<b extends FinalizedBranch> = b;\n    }\n    type _finalize<astBranches extends unknown[], acc extends FinalizedBranch[], ctx extends FinalizationContext> = astBranches extends [infer head, ...infer tail] ? finalizeTree<head, ctx> extends infer r ? r extends FinalizationResult ? _finalize<tail, finalizeBranch<acc, ctx, r>, ctx> : never : never : finalizeBranches<keyof acc, acc, ctx>;\n    type finalizeBranch<acc extends FinalizedBranch[], ctx extends FinalizationContext, r extends FinalizationResult> = [\n        ...acc,\n        FinalizedBranch.from<{\n            pattern: r[\"pattern\"];\n            captures: finalizeBranchCaptures<acc, ctx, r>;\n            names: r[\"ctx\"][\"names\"];\n        }>\n    ];\n    type finalizeBranchCaptures<acc extends FinalizedBranch[], ctx extends FinalizationContext, r extends FinalizationResult, branchCaptures extends IndexedCaptures = extractNewCaptures<ctx[\"captures\"], r[\"ctx\"][\"captures\"]>> = acc extends [] ? branchCaptures : acc[0][\"captures\"] extends (infer firstCaptureBranch extends IndexedCaptures) ? branchCaptures extends [] ? {\n        [i in keyof firstCaptureBranch]: undefined;\n    } : [...{\n        [i in keyof firstCaptureBranch]: undefined;\n    }, ...branchCaptures] : never;\n    type finalizeBranches<i, acc extends FinalizedBranch[], ctx extends FinalizationContext> = i extends keyof acc & NumberLiteral ? FinalizationResult.from<{\n        pattern: acc[i][\"pattern\"];\n        ctx: {\n            flags: ctx[\"flags\"];\n            captures: [...ctx[\"captures\"], ...acc[i][\"captures\"]];\n            names: {\n                [k in unionKeyOf<acc[number][\"names\"]>]: k extends (keyof acc[i][\"names\"]) ? acc[i][\"names\"][k] : undefined;\n            };\n            errors: ctx[\"errors\"];\n        };\n    }> : never;\n}\ntype CapturedGroupKind = string | State.UnnamedCaptureKind.indexed;\ntype IncompleteCaptureGroup = noSuggest<\"incompleteCaptureGroup\">;\ninterface GroupTree<ast extends RegexAst = RegexAst, capture extends CapturedGroupKind = CapturedGroupKind> {\n    kind: \"group\";\n    capture: capture;\n    ast: ast;\n}\ndeclare namespace GroupTree {\n    type finalize<self extends GroupTree, ctx extends FinalizationContext> = finalizeGroupAst<self, ctx> extends infer r ? r extends FinalizationResult ? finalizeGroupResult<self, ctx, r> : never : never;\n    type finalizeGroupAst<self extends GroupTree, ctx extends FinalizationContext> = finalizeTree<self[\"ast\"], self[\"capture\"] extends string ? {\n        captures: [...ctx[\"captures\"], IncompleteCaptureGroup];\n        names: ctx[\"names\"] & {\n            [_ in self[\"capture\"]]: IncompleteCaptureGroup;\n        };\n        flags: ctx[\"flags\"];\n        errors: ctx[\"errors\"];\n    } : self[\"capture\"] extends State.UnnamedCaptureKind.indexed ? {\n        captures: [...ctx[\"captures\"], IncompleteCaptureGroup];\n        names: ctx[\"names\"];\n        flags: ctx[\"flags\"];\n        errors: ctx[\"errors\"];\n    } : ctx>;\n    type finalizeGroupResult<self extends GroupTree, ctx extends FinalizationContext, r extends FinalizationResult> = FinalizationResult.from<{\n        pattern: r[\"pattern\"];\n        ctx: self[\"capture\"] extends string ? finalizeNamedCapture<self[\"capture\"], ctx[\"captures\"][\"length\"], r[\"pattern\"], r[\"ctx\"]> : self[\"capture\"] extends State.UnnamedCaptureKind.indexed ? finalizeUnnamedCapture<ctx[\"captures\"][\"length\"], r[\"pattern\"], r[\"ctx\"]> : r[\"ctx\"];\n    }>;\n    type finalizeNamedCapture<name extends string, index extends number, pattern extends string, ctx extends FinalizationContext> = FinalizationContext.from<{\n        captures: setIndex<ctx[\"captures\"], index, anchorsAway<pattern>>;\n        names: {\n            [k in keyof ctx[\"names\"]]: k extends name ? anchorsAway<pattern> : ctx[\"names\"][k];\n        };\n        flags: ctx[\"flags\"];\n        errors: ctx[\"errors\"];\n    }>;\n    type finalizeUnnamedCapture<index extends number, pattern extends string, ctx extends FinalizationContext> = FinalizationContext.from<{\n        captures: setIndex<ctx[\"captures\"], index, anchorsAway<pattern>>;\n        names: ctx[\"names\"];\n        flags: ctx[\"flags\"];\n        errors: ctx[\"errors\"];\n    }>;\n}\ninterface QuantifierTree<ast extends RegexAst = RegexAst> {\n    kind: \"quantifier\";\n    ast: ast;\n    min: number;\n    max: number | null;\n}\ndeclare namespace QuantifierTree {\n    type finalize<self extends QuantifierTree, ctx extends FinalizationContext> = finalizeTree<self[\"ast\"], ctx> extends infer r extends FinalizationResult ? finalizeQuantifierResult<self, ctx, r> : never;\n    type finalizeQuantifierResult<self extends QuantifierTree, ctx extends FinalizationContext, r extends FinalizationResult, quantifiedCaptures extends IndexedCaptures = extractNewCaptures<ctx[\"captures\"], r[\"ctx\"][\"captures\"]>> = self[\"min\"] extends 0 ? quantifiedCaptures extends [] ? finalizeNonZeroMinQuantified<self, r> : finalizeZeroMinQuantifiedWithCaptures<self, ctx, r, quantifiedCaptures> : finalizeNonZeroMinQuantified<self, r>;\n    type finalizeNonZeroMinQuantified<self extends QuantifierTree, r extends FinalizationResult> = FinalizationResult.from<{\n        pattern: quantify<r[\"pattern\"], self[\"min\"], self[\"max\"]>;\n        ctx: r[\"ctx\"];\n    }>;\n    type finalizeZeroMinQuantifiedWithCaptures<self extends QuantifierTree, ctx extends FinalizationContext, r extends FinalizationResult, quantifiedCaptures extends IndexedCaptures> = finalizeZeroQuantified<ctx, r, quantifiedCaptures> | finalizeOnePlusQuantified<self[\"max\"], r>;\n    type finalizeZeroQuantified<ctx extends FinalizationContext, r extends FinalizationResult, quantifiedCaptures extends IndexedCaptures> = FinalizationResult.from<{\n        pattern: \"\";\n        ctx: {\n            captures: [\n                ...ctx[\"captures\"],\n                ...{\n                    [i in keyof quantifiedCaptures]: undefined;\n                }\n            ];\n            flags: r[\"ctx\"][\"flags\"];\n            names: zeroQuantifiedNames<ctx[\"names\"], r[\"ctx\"][\"names\"]>;\n            errors: r[\"ctx\"][\"errors\"];\n        };\n    }>;\n    type zeroQuantifiedNames<base extends NamedCaptures, result extends NamedCaptures> = {\n        [k in keyof result]: k extends keyof base ? result[k] : undefined;\n    } & unknown;\n    type finalizeOnePlusQuantified<max extends number | null, r extends FinalizationResult> = max extends 1 ? r : FinalizationResult.from<{\n        pattern: quantify<r[\"pattern\"], 1, max>;\n        ctx: r[\"ctx\"];\n    }>;\n}\ntype pushQuantifiable<sequence extends RegexAst, root extends RegexAst> = root extends \"\" ? sequence : sequence extends string ? sequence extends \"\" ? root : root extends string ? appendNonRedundant<sequence, root> : SequenceTree<[sequence, root]> : sequence extends SequenceTree ? pushToSequence<sequence, root> : SequenceTree<[sequence, root]>;\ntype pushToSequence<sequence extends SequenceTree, root extends RegexAst> = sequence extends SequenceTree.Empty ? root : root extends SequenceTree ? SequenceTree<[...sequence[\"ast\"], ...root[\"ast\"]]> : SequenceTree<[...sequence[\"ast\"], root]>;\ntype extractNewCaptures<base extends IndexedCaptures, result extends IndexedCaptures> = result extends readonly [...base, ...infer elements extends IndexedCaptures] ? elements : [];\ninterface FinalizationContext extends Required<RegexContext> {\n    errors: ErrorMessage[];\n}\ndeclare namespace FinalizationContext {\n    type from<ctx extends FinalizationContext> = ctx;\n}\ntype FinalizationResult = {\n    pattern: string;\n    ctx: FinalizationContext;\n};\ndeclare namespace FinalizationResult {\n    type from<r extends FinalizationResult> = r;\n    type error<ctx extends FinalizationContext, message extends string> = from<{\n        pattern: string;\n        ctx: {\n            captures: ctx[\"captures\"];\n            names: ctx[\"names\"];\n            flags: ctx[\"flags\"];\n            errors: [...ctx[\"errors\"], ErrorMessage<message>];\n        };\n    }>;\n}\ntype finalizeTree<tree, ctx extends FinalizationContext> = tree extends string ? FinalizationResult.from<{\n    pattern: tree;\n    ctx: ctx;\n}> : tree extends SequenceTree ? SequenceTree.finalize<tree, ctx> : tree extends UnionTree ? UnionTree.finalize<tree, ctx> : tree extends GroupTree ? GroupTree.finalize<tree, ctx> : tree extends QuantifierTree ? QuantifierTree.finalize<tree, ctx> : tree extends ReferenceNode ? ReferenceNode.finalize<tree, ctx> : never;\ntype anchorsAway<pattern extends string> = pattern extends `${StartAnchorMarker}${infer startStripped}` ? startStripped extends `${infer bothStripped}${EndAnchorMarker}` ? bothStripped : startStripped : pattern extends `${infer endStripped}${EndAnchorMarker}` ? endStripped : pattern;\ntype appendNonRedundant<base extends string, suffix extends string> = string extends base ? string extends suffix ? string : `${base}${suffix}` : `${number}` extends base ? `${number}` extends suffix ? `${number}` : `${base}${suffix}` : `${base}${suffix}`;\n\ntype parseEscape<s extends State, unscanned extends string> = unscanned extends Scanner.shift<infer char, infer nextUnscanned> ? char extends NonZeroDigit ? parseNumericBackreference<s, unscanned> : char extends \"k\" ? parseNamedBackreference<s, nextUnscanned> : char extends UnicodePropertyChar ? parseUnicodeProperty<s, char, nextUnscanned> : parseSingleEscapedCharacter<s, char, nextUnscanned> : s.error<trailingBackslashMessage>;\ntype parseNumericBackreference<s extends State, fullUnscanned extends string> = Scanner.shiftUntilNot<fullUnscanned, StringDigit> extends (Scanner.shiftResult<infer ref, infer remaining>) ? s.shiftQuantifiable<s, ReferenceNode<ref>, remaining> : never;\ntype parseNamedBackreference<s extends State, unscanned extends string> = unscanned extends `<${infer ref}>${infer following}` ? s.shiftQuantifiable<s, ReferenceNode<ref>, following> : s.error<missingBackreferenceNameMessage>;\ntype parseUnicodeProperty<s extends State, char extends UnicodePropertyChar, unscanned extends string> = unscanned extends `{${string}}${infer following}` ? s.shiftQuantifiable<s, string, following> : s.error<writeInvalidUnicodePropertyMessage<char>>;\ntype parseSingleEscapedCharacter<s extends State, char extends string, remaining extends string> = parseEscapedChar<char> extends infer result extends string ? result extends ErrorMessage ? s.error<result> : s.shiftQuantifiable<s, result, remaining> : never;\ntype parseEscapedChar<char extends string> = char extends RegexClassChar ? string : char extends \"d\" ? `${number}` : char extends \"s\" ? WhitespaceChar : char extends BoundaryChar ? \"\" : char extends Control ? char : char extends \"c\" ? ErrorMessage<caretNotationMessage> : char extends StringEscapableChar ? ErrorMessage<writeStringEscapableMessage<char>> : ErrorMessage<writeUnnecessaryEscapeMessage<char>>;\ndeclare const trailingBackslashMessage = \"A regex cannot end with \\\\\";\ntype trailingBackslashMessage = typeof trailingBackslashMessage;\ndeclare const writeUnresolvableBackreferenceMessage: <ref extends string | number>(ref: ref) => writeUnresolvableBackreferenceMessage<ref>;\ntype writeUnresolvableBackreferenceMessage<ref extends string | number> = `Group ${ref} does not exist`;\ndeclare const missingBackreferenceNameMessage = \"\\\\k must be followed by a named reference like <name>\";\ntype missingBackreferenceNameMessage = typeof missingBackreferenceNameMessage;\ndeclare const writeInvalidUnicodePropertyMessage: <char extends UnicodePropertyChar>(char: char) => writeInvalidUnicodePropertyMessage<char>;\ntype writeInvalidUnicodePropertyMessage<char extends UnicodePropertyChar> = `\\\\${char} must be followed by a property like \\\\${char}{Emoji_Presentation}`;\ndeclare const writeUnnecessaryEscapeMessage: <char extends string>(char: char) => writeUnnecessaryEscapeMessage<char>;\ntype writeUnnecessaryEscapeMessage<char extends string> = `Escape preceding ${char} is unnecessary and should be removed.`;\ndeclare const writeStringEscapableMessage: (char: StringEscapableChar) => \"\\\\f should be specified with a single backslash like regex('\\\\n')\" | \"\\\\n should be specified with a single backslash like regex('\\\\n')\" | \"\\\\r should be specified with a single backslash like regex('\\\\n')\" | \"\\\\t should be specified with a single backslash like regex('\\\\n')\" | \"\\\\u should be specified with a single backslash like regex('\\\\n')\" | \"\\\\v should be specified with a single backslash like regex('\\\\n')\" | \"\\\\x should be specified with a single backslash like regex('\\\\n')\" | \"\\\\0 should be specified with a single backslash like regex('\\\\n')\";\ntype writeStringEscapableMessage<char extends StringEscapableChar> = `\\\\${char} should be specified with a single backslash like regex('\\n')`;\ndeclare const caretNotationMessage = \"\\\\\\\\cX notation is not supported. Use hex (\\\\\\\\x) or unicode (\\\\\\\\u) instead.\";\ntype caretNotationMessage = \"\\\\cX notation is not supported. Use hex (\\\\x) or unicode (\\\\u) instead.\";\ntype StringEscapableChar = \"t\" | \"n\" | \"r\" | \"f\" | \"v\" | \"0\" | \"x\" | \"u\";\ntype RegexClassChar = \"w\" | \"W\" | \"D\" | \"S\";\ntype BoundaryChar = \"b\" | \"B\";\ntype UnicodePropertyChar = \"p\" | \"P\";\ntype NonZeroDigit = \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\";\ntype StringDigit = \"0\" | NonZeroDigit;\n\ntype parseCharset<s extends State, unscanned extends string> = Scanner.shiftUntilEscapable<unscanned, \"]\", Backslash> extends (Scanner.shiftResult<infer scanned, infer nextUnscanned>) ? nextUnscanned extends `]${infer remaining}` ? scanned extends Scanner.shift<\"^\", string> ? s.shiftQuantifiable<s, string, remaining> : parseNonNegatedCharset<scanned, never, null> extends (infer result extends string) ? [\n    result\n] extends [never] ? s.error<emptyCharacterSetMessage> : s.shiftQuantifiable<s, result, remaining> : never : s.error<writeUnclosedGroupMessage<\"]\">> : never;\ntype parseNonNegatedCharset<chars extends string, set extends string, lastChar extends string | null> = parseChar<chars> extends Scanner.shiftResult<infer result, infer unscanned> ? result extends UnescapedDashMarker ? parseDash<unscanned, set, lastChar> : result extends ErrorMessage ? result : parseNonNegatedCharset<unscanned, set | result, result> : set;\ntype parseDash<unscanned extends string, set extends string, lastChar extends string | null> = lastChar extends string ? parseChar<unscanned> extends (Scanner.shiftResult<infer rangeEnd, infer next>) ? parseNonNegatedCharset<next, set | inferRange<lastChar, rangeEnd>, null> : // trailing -, treat as literal\nset | \"-\" : parseNonNegatedCharset<unscanned, set | \"-\", \"-\">;\ntype inferRange<start extends string, end extends string> = start | end extends StringDigit ? `${number}` : string;\ntype UnescapedDashMarker = noSuggest<\"dash\">;\ntype parseChar<unscanned extends string> = unscanned extends Scanner.shift<infer lookahead, infer next> ? lookahead extends Backslash ? next extends Scanner.shift<infer escaped, infer postEscaped> ? Scanner.shiftResult<parseEscapedChar<escaped>, postEscaped> : never : Scanner.shiftResult<lookahead extends \"-\" ? UnescapedDashMarker : lookahead, next> : null;\ndeclare const emptyCharacterSetMessage = \"Empty character set [] is unsatisfiable\";\ntype emptyCharacterSetMessage = typeof emptyCharacterSetMessage;\n\ntype LookaroundChar = \"=\" | \"!\";\ntype ModifiableFlag = \"i\" | \"m\" | \"s\";\ntype parseGroup<s extends State, unscanned extends string> = unscanned extends Scanner.shift<infer lookahead, infer next> ? lookahead extends \"?\" ? parseNonCapturingGroup<s, next> : s.pushGroup<s, State.UnnamedCaptureKind.indexed, unscanned, undefined> : s.error<writeUnclosedGroupMessage<\")\">>;\ntype parseNonCapturingGroup<s extends State, unscanned extends string> = unscanned extends Scanner.shift<infer lookahead, infer next> ? lookahead extends \":\" ? s.pushGroup<s, State.UnnamedCaptureKind.noncapturing, next, undefined> : lookahead extends LookaroundChar ? s.pushGroup<s, State.UnnamedCaptureKind.lookaround, next, undefined> : lookahead extends \"<\" ? parseNamedGroupOrLookbehind<s, next> : shiftModifiers<unscanned> extends (ShiftedModifiers<infer flags, infer negated, infer following>) ? following extends ErrorMessage<infer message> ? s.error<message> : s.pushGroup<s, State.UnnamedCaptureKind.noncapturing, following, \"i\" extends flags ? true : \"i\" extends negated ? false : undefined> : never : s.error<writeUnclosedGroupMessage<\")\">>;\ntype ShiftedModifiers<flags extends ModifiableFlag = ModifiableFlag, negated extends ModifiableFlag = ModifiableFlag, unscanned extends string = string> = [ParsedModifiers<flags, negated>, unscanned];\ntype ParsedModifiers<flags extends ModifiableFlag = ModifiableFlag, negated extends ModifiableFlag = ModifiableFlag> = {\n    flags: flags;\n    negated: negated;\n};\ntype shiftModifiers<unscanned extends string> = Scanner.shiftUntil<unscanned, \":\" | \")\"> extends (Scanner.shiftResult<infer scanned, infer next>) ? next extends Scanner.shift<infer terminator, infer following> ? terminator extends \":\" ? parseModifiers<scanned> extends (ParsedModifiers<infer flags, infer negated>) ? ShiftedModifiers<flags, negated, following> : ShiftedModifiers<never, never, ErrorMessage<parseModifiers<scanned> & string>> : ShiftedModifiers<never, never, ErrorMessage<unescapedLiteralQuestionMarkMessage>> : ShiftedModifiers<never, never, ErrorMessage<writeUnclosedGroupMessage<\")\">>> : never;\ntype parseModifiers<unscanned extends string> = _parseModifiers<unscanned, never, never>;\ntype _parseModifiers<unscanned extends string, flags extends ModifiableFlag, negated extends ModifiableFlag> = unscanned extends Scanner.shift<infer lookahead, infer next> ? lookahead extends \"-\" ? [\n    negated\n] extends [never] ? next extends Scanner.shift<infer modifier, infer next> ? modifier extends ModifiableFlag ? modifier extends flags | negated ? writeDuplicateModifierMessage<modifier> : _parseModifiers<next, flags, negated | modifier> : writeInvalidModifierMessage<modifier> : missingNegatedModifierMessage : multipleModifierDashesMessage : lookahead extends ModifiableFlag ? lookahead extends flags | negated ? writeDuplicateModifierMessage<lookahead> : [\n    negated\n] extends [never] ? _parseModifiers<next, flags | lookahead, negated> : _parseModifiers<next, flags, negated | lookahead> : writeInvalidModifierMessage<lookahead> : ParsedModifiers<flags, negated>;\ndeclare const writeDuplicateModifierMessage: <modifier extends ModifiableFlag>(modifier: modifier) => writeDuplicateModifierMessage<modifier>;\ntype writeDuplicateModifierMessage<modifier extends ModifiableFlag> = `Modifier ${modifier} cannot appear multiple times in a single group`;\ndeclare const multipleModifierDashesMessage = \"Modifiers can include at most one '-' to negate subsequent flags\";\ntype multipleModifierDashesMessage = typeof multipleModifierDashesMessage;\ndeclare const missingNegatedModifierMessage = \"- must be followed by the modifier flag to negate ('i', 'm' or 's')\";\ntype missingNegatedModifierMessage = typeof missingNegatedModifierMessage;\ndeclare const writeInvalidModifierMessage: <char extends string>(char: char) => writeInvalidModifierMessage<char>;\ntype writeInvalidModifierMessage<char extends string> = `Modifier flag ${char} must be 'i', 'm' or 's'`;\ntype parseNamedGroupOrLookbehind<s extends State, unscanned extends string> = unscanned extends Scanner.shift<LookaroundChar, infer next> ? s.pushGroup<s, State.UnnamedCaptureKind.lookaround, next, undefined> : shiftNamedGroup<unscanned> extends (Scanner.shiftResult<infer name, infer following>) ? s.pushGroup<s, name, following, undefined> : s.error<writeUnclosedGroupMessage<\")\">>;\ntype shiftNamedGroup<unscanned extends string> = unscanned extends `${infer name}>${infer next}` ? name extends \"\" ? Scanner.shiftResult<\"\", ErrorMessage<unnamedCaptureGroupMessage>> : Scanner.shiftResult<name, next> : Scanner.shiftResult<\"\", ErrorMessage<writeUnclosedGroupMessage<\">\">>>;\ndeclare const unnamedCaptureGroupMessage = \"Capture group <> requires a name\";\ntype unnamedCaptureGroupMessage = typeof unnamedCaptureGroupMessage;\ndeclare const unescapedLiteralQuestionMarkMessage = \"literal ? must be escaped at the start of a group\";\ntype unescapedLiteralQuestionMarkMessage = typeof unescapedLiteralQuestionMarkMessage;\n\ntype parseState<s extends State> = s[\"unscanned\"] extends ErrorMessage ? s[\"unscanned\"] : s[\"unscanned\"] extends \"\" ? s.finalize<s> : parseState<next<s>>;\ntype next<s extends State> = s[\"unscanned\"] extends Scanner.shift<infer lookahead, infer unscanned> ? lookahead extends \".\" ? s.shiftQuantifiable<s, string, unscanned> : lookahead extends Backslash ? parseEscape<s, unscanned> : lookahead extends \"|\" ? s.finalizeBranch<s, unscanned> : lookahead extends Anchor ? s.anchor<s, AnchorMarker<lookahead>, unscanned> : lookahead extends \"(\" ? parseGroup<s, unscanned> : lookahead extends \")\" ? s.popGroup<s, unscanned> : lookahead extends QuantifyingChar ? parseBuiltinQuantifier<s, lookahead, unscanned> : lookahead extends \"{\" ? parsePossibleRange<s, unscanned> : lookahead extends \"[\" ? parseCharset<s, unscanned> : s.shiftQuantifiable<s, maybeSplitCasing<s[\"caseInsensitive\"], lookahead>, unscanned> : never;\ntype maybeSplitCasing<caseInsensitive extends boolean, char extends string> = caseInsensitive extends false ? char : Lowercase<char> extends Uppercase<char> ? char : UnionTree<[Lowercase<char>, Capitalize<char>]>;\n\ntype IndexedCaptures = Array<string | undefined>;\ntype NamedCaptures = Record<string, string | undefined>;\ntype UnicodeFlag = \"v\" | \"u\";\ntype Flags = `${\"d\" | \"\"}${\"g\" | \"\"}${\"i\" | \"\"}${\"m\" | \"\"}${\"s\" | \"\"}${UnicodeFlag | \"\"}${\"y\" | \"\"}`;\ntype RegexContext = {\n    flags?: Flags;\n    captures?: IndexedCaptures;\n    names?: NamedCaptures;\n};\ninterface Regex<out pattern extends string = string, out ctx extends RegexContext = RegexContext> extends RegExp {\n    [inferred]: pattern;\n    infer: pattern;\n    inferCaptures: ctx[\"captures\"] extends IndexedCaptures ? ctx[\"captures\"] : [];\n    inferNamedCaptures: ctx[\"names\"] extends NamedCaptures ? ctx[\"names\"] : {};\n    inferExecArray: RegexExecArray<[\n        pattern,\n        ...this[\"inferCaptures\"]\n    ], this[\"inferNamedCaptures\"], this[\"flags\"]>;\n    flags: ctx[\"flags\"] extends Flags ? ctx[\"flags\"] : \"\";\n    test(s: string): s is pattern;\n    exec(s: string): this[\"inferExecArray\"] | null;\n    exec(s: string): never;\n}\ninterface RegexParser {\n    <src extends string, flags extends Flags = \"\">(src: regex.validate<src, flags>, flags?: flags): regex.parse<src, flags>;\n    as: <pattern extends string = string, ctx extends RegexContext = {}>(src: string, flags?: Flags) => Regex<pattern, ctx>;\n}\ndeclare const regex: RegexParser;\ntype regex<pattern extends string = string, ctx extends RegexContext = RegexContext> = Regex<pattern, ctx>;\ndeclare namespace regex {\n    type infer<src extends string, flags extends Flags = \"\"> = parse<src, flags> extends Regex<infer pattern> ? pattern : never;\n    type validate<src extends string, flags extends Flags = \"\"> = parse<src, flags> extends infer e extends ErrorMessage ? e : src;\n    type parse<src extends string, flags extends Flags = \"\"> = parseState<State.initialize<src, flags>>;\n}\n\nexport { type Regex, regex };\n\n}"
