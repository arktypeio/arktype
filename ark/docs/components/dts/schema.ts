/** THIS FILE IS AUTOGENERATED FROM ark/repo/dtsGen.ts **/
// prettier-ignore
export const schemaDts = "declare module \"@ark/schema\" {\n    import { DynamicBase, anyOrNever, ReadonlyArray as ReadonlyArray$1, array, propwiseXor, merge, show, CastableBase, ReadonlyPath, JsonObject, JsonArray, mutable, Thunk, Callable, Hkt, JsonStructure, autocomplete, listable, satisfy, Domain as Domain$1, Constructor, Json, requireKeys, NonNegativeIntegerLiteral, flattenListable, noSuggest, intersectUnion, conform, ParseError, Key, propValueOf, Entry, KeySet, keySetOf, arrayIndexOf, JsonPrimitive, SerializedPrimitive, inferred, Fn, BuiltinObjectKind, describe, GuardablePredicate, Brand, dict, ArkRegistry } from '@ark/util';\nexport { ParseError } from '@ark/util';\n\ndeclare const intrinsic: {\n    emptyStructure: StructureNode;\n    jsonPrimitive: BaseRoot<InternalRootDeclaration>;\n    jsonObject: BaseRoot<InternalRootDeclaration>;\n    jsonData: BaseRoot<InternalRootDeclaration>;\n    integer: BaseRoot<InternalRootDeclaration>;\n    key: BaseRoot<InternalRootDeclaration>;\n    lengthBoundable: BaseRoot<InternalRootDeclaration>;\n    nonNegativeIntegerString: BaseRoot<InternalRootDeclaration>;\n    string: BaseRoot<InternalRootDeclaration>;\n    number: BaseRoot<InternalRootDeclaration>;\n    bigint: BaseRoot<InternalRootDeclaration>;\n    boolean: BaseRoot<InternalRootDeclaration>;\n    symbol: BaseRoot<InternalRootDeclaration>;\n    undefined: BaseRoot<InternalRootDeclaration>;\n    object: BaseRoot<InternalRootDeclaration>;\n    null: BaseRoot<InternalRootDeclaration>;\n    Array: BaseRoot<InternalRootDeclaration>;\n    Date: BaseRoot<InternalRootDeclaration>;\n    never: BaseRoot<InternalRootDeclaration>;\n    unknown: BaseRoot<InternalRootDeclaration>;\n    true: BaseRoot<InternalRootDeclaration>;\n    false: BaseRoot<InternalRootDeclaration>;\n};\n\ntype PreparsedNodeResolution = {\n    [arkKind]: \"generic\" | \"module\";\n};\ndeclare class RootModule<exports extends {} = {}> extends DynamicBase<exports> {\n    get [arkKind](): \"module\";\n}\ninterface InternalModule<exports extends InternalResolutions = InternalResolutions> extends RootModule<exports> {\n    root?: BaseRoot;\n}\ndeclare const bindModule: (module: InternalModule, $: BaseScope) => InternalModule;\ntype exportSchemaScope<$> = {\n    [k in keyof $]: instantiateRoot<$[k]>;\n};\ntype instantiateRoot<t> = t extends InternalResolution ? [\n    t\n] extends [anyOrNever] ? BaseRoot : t : BaseRoot;\ndeclare const SchemaModule: new <$ = {}>(types: exportSchemaScope<$>) => SchemaModule<$>;\ninterface SchemaModule<$ = {}> extends RootModule<exportSchemaScope<$>> {\n}\n\n/** From https://github.com/standard-schema/standard-schema */\n/**\n * The Standard Schema interface.\n */\ntype StandardSchemaV1<Input = unknown, Output = Input> = {\n    /**\n     * The Standard Schema properties.\n     */\n    readonly \"~standard\": StandardSchemaV1.Props<Input, Output>;\n};\ndeclare namespace StandardSchemaV1 {\n    /**\n     * The Standard Schema properties interface.\n     */\n    export interface Props<Input = unknown, Output = Input> {\n        /**\n         * The version number of the standard.\n         */\n        readonly version: 1;\n        /**\n         * The vendor name of the schema library.\n         */\n        readonly vendor: string;\n        /**\n         * Validates unknown input values.\n         */\n        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;\n        /**\n         * Inferred types associated with the schema.\n         */\n        readonly types?: Types<Input, Output> | undefined;\n    }\n    export interface ArkTypeProps<Input = unknown, Output = Input> extends Props<Input, Output> {\n        readonly vendor: \"arktype\";\n    }\n    /**\n     * The result interface of the validate function.\n     */\n    export type Result<Output> = SuccessResult<Output> | FailureResult;\n    /**\n     * The result interface if validation succeeds.\n     */\n    export interface SuccessResult<Output> {\n        /**\n         * The typed output value.\n         */\n        readonly value: Output;\n        /**\n         * The non-existent issues.\n         */\n        readonly issues?: undefined;\n    }\n    /**\n     * The result interface if validation fails.\n     */\n    export interface FailureResult {\n        /**\n         * The issues of failed validation.\n         */\n        readonly issues: ReadonlyArray<Issue>;\n    }\n    /**\n     * The issue interface of the failure output.\n     */\n    export interface Issue {\n        /**\n         * The error message of the issue.\n         */\n        readonly message: string;\n        /**\n         * The path of the issue, if any.\n         */\n        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;\n    }\n    /**\n     * The path segment interface of the issue.\n     */\n    export interface PathSegment {\n        /**\n         * The key representing a path segment.\n         */\n        readonly key: PropertyKey;\n    }\n    /**\n     * The Standard Schema types interface.\n     */\n    export interface Types<Input = unknown, Output = Input> {\n        /**\n         * The input type of the schema.\n         */\n        readonly input: Input;\n        /**\n         * The output type of the schema.\n         */\n        readonly output: Output;\n    }\n    /**\n     * Infers the input type of a Standard Schema.\n     */\n    export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"input\"];\n    /**\n     * Infers the output type of a Standard Schema.\n     */\n    export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema[\"~standard\"][\"types\"]>[\"output\"];\n    export {  };\n}\n\ntype ArkErrorResult = ArkError | ArkErrors;\ndeclare class ArkError<code extends ArkErrorCode = ArkErrorCode> extends CastableBase<ArkErrorContextInput<code>> {\n    readonly [arkKind] = \"error\";\n    path: ReadonlyPath;\n    data: Prerequisite<code>;\n    private nodeConfig;\n    protected input: ArkErrorContextInput<code>;\n    protected ctx: Traversal;\n    constructor(input: ArkErrorContextInput<code>, ctx: Traversal);\n    transform(f: (input: ArkErrorContextInput<code>) => ArkErrorContextInput): ArkError;\n    hasCode<code extends ArkErrorCode>(code: code): this is ArkError<code>;\n    get propString(): string;\n    get expected(): string;\n    get actual(): string;\n    get problem(): string;\n    get message(): string;\n    get flat(): ArkError[];\n    toJSON(): JsonObject;\n    toString(): string;\n    throw(): never;\n}\ndeclare namespace ArkErrors {\n    type Handler<returns = unknown> = (errors: ArkErrors) => returns;\n}\n/**\n * A ReadonlyArray of `ArkError`s returned by a Type on invalid input.\n *\n * Subsequent errors added at an existing path are merged into an\n * ArkError intersection.\n */\ndeclare class ArkErrors extends ReadonlyArray$1<ArkError> implements StandardSchemaV1.FailureResult {\n    readonly [arkKind] = \"errors\";\n    protected ctx: Traversal;\n    constructor(ctx: Traversal);\n    /**\n     * Errors by a pathString representing their location.\n     */\n    byPath: Record<string, ArkError>;\n    /**\n     * {@link byPath} flattened so that each value is an array of ArkError instances at that path.\n     *\n     * âœ… Since \"intersection\" errors will be flattened to their constituent `.errors`,\n     * they will never be directly present in this representation.\n     */\n    get flatByPath(): Record<string, ArkError[]>;\n    /**\n     * {@link byPath} flattened so that each value is an array of problem strings at that path.\n     */\n    get flatProblemsByPath(): Record<string, string[]>;\n    /**\n     * All pathStrings at which errors are present mapped to the errors occuring\n     * at that path or any nested path within it.\n     */\n    byAncestorPath: Record<string, ArkError[]>;\n    count: number;\n    private mutable;\n    /**\n     * Throw a TraversalError based on these errors.\n     */\n    throw(): never;\n    /**\n     * Converts ArkErrors to TraversalError, a subclass of `Error` suitable for throwing with nice\n     * formatting.\n     */\n    toTraversalError(): TraversalError;\n    /**\n     * Append an ArkError to this array, ignoring duplicates.\n     */\n    add(error: ArkError): void;\n    transform(f: (e: ArkError) => ArkError): ArkErrors;\n    /**\n     * Add all errors from an ArkErrors instance, ignoring duplicates and\n     * prefixing their paths with that of the current Traversal.\n     */\n    merge(errors: ArkErrors): void;\n    /**\n     * A human-readable summary of all errors.\n     */\n    get summary(): string;\n    /**\n     * Alias of this ArkErrors instance for StandardSchema compatibility.\n     */\n    get issues(): this;\n    toJSON(): JsonArray;\n    toString(): string;\n    private _add;\n    private addAncestorPaths;\n}\ndeclare class TraversalError extends Error {\n    readonly name = \"TraversalError\";\n    arkErrors: ArkErrors;\n    constructor(errors: ArkErrors);\n}\ninterface DerivableErrorContext<code extends ArkErrorCode = ArkErrorCode> {\n    expected: string;\n    actual: string;\n    problem: string;\n    message: string;\n    data: Prerequisite<code>;\n    path: array<PropertyKey>;\n    propString: string;\n}\ntype DerivableErrorContextInput<code extends ArkErrorCode = ArkErrorCode> = Partial<DerivableErrorContext<code>> & propwiseXor<{\n    path?: array<PropertyKey>;\n}, {\n    relativePath?: array<PropertyKey>;\n    prefixPath?: array<PropertyKey>;\n}>;\ntype ArkErrorCode = {\n    [kind in NodeKind]: errorContext<kind> extends null ? never : kind;\n}[NodeKind];\ntype ArkErrorContextInputsByCode = {\n    [code in ArkErrorCode]: errorContext<code> & DerivableErrorContextInput<code>;\n};\ntype ArkErrorContextInput<code extends ArkErrorCode = ArkErrorCode> = merge<ArkErrorContextInputsByCode[code], {\n    meta?: NodeMeta;\n}>;\ntype NodeErrorContextInput<code extends ArkErrorCode = ArkErrorCode> = ArkErrorContextInputsByCode[code] & {\n    meta: NodeMeta;\n};\ntype MessageContext<code extends ArkErrorCode = ArkErrorCode> = Omit<ArkError<code>, \"message\">;\ntype ProblemContext<code extends ArkErrorCode = ArkErrorCode> = Omit<MessageContext<code>, \"problem\">;\ntype CustomErrorInput = show<{\n    code?: undefined;\n} & DerivableErrorContextInput>;\ntype ArkErrorInput = string | ArkErrorContextInput | CustomErrorInput;\ntype ProblemConfig<code extends ArkErrorCode = ArkErrorCode> = string | ProblemWriter<code>;\ntype ProblemWriter<code extends ArkErrorCode = ArkErrorCode> = (context: ProblemContext<code>) => string;\ntype MessageConfig<code extends ArkErrorCode = ArkErrorCode> = string | MessageWriter<code>;\ntype MessageWriter<code extends ArkErrorCode = ArkErrorCode> = (context: MessageContext<code>) => string;\ntype getAssociatedDataForError<code extends ArkErrorCode> = code extends NodeKind ? Prerequisite<code> : unknown;\ntype ExpectedConfig<code extends ArkErrorCode = ArkErrorCode> = string | ExpectedWriter<code>;\ntype ExpectedWriter<code extends ArkErrorCode = ArkErrorCode> = (source: errorContext<code>) => string;\ntype ActualConfig<code extends ArkErrorCode = ArkErrorCode> = string | ActualWriter<code>;\ntype ActualWriter<code extends ArkErrorCode = ArkErrorCode> = (data: getAssociatedDataForError<code>) => string;\n\ndeclare const makeRootAndArrayPropertiesMutable: <o extends object>(o: o) => makeRootAndArrayPropertiesMutable<o>;\ntype makeRootAndArrayPropertiesMutable<inner> = {\n    -readonly [k in keyof inner]: inner[k] extends array | undefined ? mutable<inner[k]> : inner[k];\n} & unknown;\ntype internalImplementationOf<external, typeOnlyKey extends keyof external = never> = {\n    [k in Exclude<keyof external, typeOnlyKey>]: external[k] extends ((...args: infer args) => unknown) ? (...args: {\n        [i in keyof args]: never;\n    }) => unknown : unknown;\n};\ntype arkKind = typeof arkKind;\ndeclare const arkKind: \" arkKind\";\ninterface ArkKinds {\n    constraint: BaseConstraint;\n    root: BaseRoot;\n    scope: BaseScope;\n    generic: GenericRoot;\n    module: InternalModule;\n    error: ArkError;\n    errors: ArkErrors;\n    context: BaseParseContext;\n}\ntype ArkKind = show<keyof ArkKinds>;\ndeclare const hasArkKind: <kind extends ArkKind>(value: unknown, kind: kind) => value is ArkKinds[kind];\ndeclare const isNode: (value: unknown) => value is BaseNode;\ntype unwrapDefault<thunkableValue> = thunkableValue extends Thunk<infer returnValue> ? returnValue : thunkableValue;\n\ntype GenericParamAst<name extends string = string, constraint = unknown> = [name: name, constraint: constraint];\ntype GenericParamDef<name extends string = string> = name | readonly [name, unknown];\ndeclare const parseGeneric: (paramDefs: array<GenericParamDef>, bodyDef: unknown, $: BaseScope) => GenericRoot;\ntype genericParamNames<params extends array<GenericParamAst>> = {\n    [i in keyof params]: params[i][0];\n};\ntype genericParamConstraints<params extends array<GenericParamAst>> = {\n    [i in keyof params]: params[i][1];\n};\ntype GenericArgResolutions<params extends array<GenericParamAst> = array<GenericParamAst>> = {\n    [i in keyof params as params[i & `${number}`][0]]: BaseRoot;\n};\ndeclare class LazyGenericBody<argResolutions = {}, returns = unknown> extends Callable<(args: argResolutions) => returns> {\n}\ninterface GenericAst<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown, $ = unknown, arg$ = $> {\n    [arkKind]: \"generic\";\n    paramsAst: params;\n    bodyDef: bodyDef;\n    $: $;\n    arg$: arg$;\n    names: genericParamNames<params>;\n    t: this;\n}\ndeclare class GenericRoot<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown> extends Callable<(...args: {\n    [i in keyof params]: BaseRoot;\n}) => BaseRoot> {\n    readonly [arkKind] = \"generic\";\n    readonly paramsAst: params;\n    readonly t: GenericAst<params, bodyDef, {}, {}>;\n    paramDefs: array<GenericParamDef>;\n    bodyDef: bodyDef;\n    $: BaseScope;\n    arg$: BaseScope;\n    baseInstantiation: BaseRoot;\n    hkt: Hkt.constructor | null;\n    description: string;\n    constructor(paramDefs: array<GenericParamDef>, bodyDef: bodyDef, $: BaseScope, arg$: BaseScope, hkt: Hkt.constructor | null);\n    defIsLazy(): this is GenericRoot<params, LazyGenericBody>;\n    protected cacheGetter<name extends keyof this>(name: name, value: this[name]): this[name];\n    get json(): JsonStructure;\n    get params(): {\n        [i in keyof params]: [params[i][0], BaseRoot];\n    };\n    get names(): genericParamNames<params>;\n    get constraints(): {\n        [i in keyof params]: BaseRoot;\n    };\n    get internal(): this;\n    get referencesById(): Record<string, BaseNode>;\n    get references(): BaseNode[];\n}\ntype genericParamSchemasToAst<schemas extends readonly GenericParamDef[]> = {\n    [i in keyof schemas]: schemas[i] extends GenericParamDef<infer name> ? [\n        name,\n        unknown\n    ] : never;\n};\ntype genericHktToConstraints<hkt extends abstract new () => Hkt> = InstanceType<hkt>[\"constraints\"];\ntype GenericRootParser = <const paramsDef extends readonly GenericParamDef[]>(...params: paramsDef) => GenericRootBodyParser<genericParamSchemasToAst<paramsDef>>;\ntype GenericRootBodyParser<params extends array<GenericParamAst>> = {\n    <const body>(body: RootSchema): GenericRoot<params, body>;\n    <hkt extends Hkt.constructor>(instantiateDef: LazyGenericBody<GenericArgResolutions<params>>, hkt: hkt): GenericRoot<{\n        [i in keyof params]: [params[i][0], genericHktToConstraints<hkt>[i]];\n    }, InstanceType<hkt>>;\n};\ndeclare const writeUnsatisfiedParameterConstraintMessage: <name extends string, constraint extends string, arg extends string>(name: name, constraint: constraint, arg: arg) => writeUnsatisfiedParameterConstraintMessage<name, constraint, arg>;\ntype writeUnsatisfiedParameterConstraintMessage<name extends string, constraint extends string, arg extends string> = `${name} must be assignable to ${constraint} (was ${arg})`;\n\ntype ListableJsonSchema = listable<JsonSchema>;\ntype JsonSchemaOrBoolean = listable<JsonSchema.Branch>;\ntype JsonSchema = JsonSchema.NonBooleanBranch;\ndeclare namespace JsonSchema {\n    type TypeName = \"string\" | \"integer\" | \"number\" | \"object\" | \"array\" | \"boolean\" | \"null\";\n    /**\n     *  a subset of JSON Schema's annotations, see:\n     *  https://json-schema.org/understanding-json-schema/reference/annotations\n     **/\n    interface Meta<t = unknown> extends UniversalMeta<t> {\n        $schema?: string;\n        $defs?: Record<string, JsonSchema>;\n    }\n    type Format = autocomplete<\"date-time\" | \"date\" | \"time\" | \"email\" | \"ipv4\" | \"ipv6\" | \"uri\" | \"uuid\" | \"regex\">;\n    /**\n     * doesn't include root-only keys like $schema\n     */\n    interface UniversalMeta<t = unknown> {\n        title?: string;\n        description?: string;\n        format?: Format;\n        deprecated?: true;\n        default?: t;\n        examples?: readonly t[];\n    }\n    type Composition = Union | OneOf | Intersection | Not;\n    type NonBooleanBranch = Constrainable | Const | Composition | Enum | String | Numeric | Object | Array | Ref;\n    type Branch = boolean | JsonSchema;\n    type RefString = `#/$defs/${string}`;\n    interface Ref extends Meta {\n        $ref: RefString;\n        type?: never;\n    }\n    interface Constrainable extends Meta {\n        type?: listable<TypeName>;\n    }\n    interface Intersection extends Meta {\n        allOf: readonly JsonSchema[];\n    }\n    interface Not extends Meta {\n        not: JsonSchema;\n    }\n    interface OneOf extends Meta {\n        oneOf: readonly JsonSchema[];\n    }\n    interface Union extends Meta {\n        anyOf: readonly JsonSchema[];\n    }\n    interface Const extends Meta {\n        const: unknown;\n    }\n    interface Enum extends Meta {\n        enum: array;\n    }\n    interface String extends Meta<string> {\n        type: \"string\";\n        minLength?: number;\n        maxLength?: number;\n        pattern?: string;\n        format?: string;\n    }\n    interface Numeric extends Meta<number> {\n        type: \"number\" | \"integer\";\n        multipleOf?: number;\n        minimum?: number;\n        exclusiveMinimum?: number;\n        maximum?: number;\n        exclusiveMaximum?: number;\n    }\n    interface Object extends Meta<JsonObject> {\n        type: \"object\";\n        properties?: Record<string, JsonSchema>;\n        required?: string[];\n        patternProperties?: Record<string, JsonSchema>;\n        additionalProperties?: JsonSchemaOrBoolean;\n        maxProperties?: number;\n        minProperties?: number;\n        propertyNames?: String;\n    }\n    interface Array extends Meta<JsonArray> {\n        type: \"array\";\n        additionalItems?: JsonSchemaOrBoolean;\n        contains?: JsonSchemaOrBoolean;\n        uniqueItems?: boolean;\n        minItems?: number;\n        maxItems?: number;\n        items?: JsonSchemaOrBoolean;\n        prefixItems?: readonly Branch[];\n    }\n    type LengthBoundable = String | Array;\n    type Structure = Object | Array;\n}\n\ndeclare class ToJsonSchemaError<code extends ToJsonSchema.Code = ToJsonSchema.Code> extends Error {\n    readonly name = \"ToJsonSchemaError\";\n    readonly code: code;\n    readonly context: ToJsonSchema.ContextByCode[code];\n    constructor(code: code, context: ToJsonSchema.ContextByCode[code]);\n    hasCode<code extends ToJsonSchema.Code>(code: code): this is ToJsonSchemaError<code>;\n}\ndeclare const ToJsonSchema: {\n    Error: typeof ToJsonSchemaError;\n    throw: (code: keyof ToJsonSchema.ContextByCode, context: ToJsonSchema.MorphContext | ToJsonSchema.UnitContext | ToJsonSchema.ProtoContext | ToJsonSchema.DomainContext | ToJsonSchema.PredicateContext | ToJsonSchema.DateContext | ToJsonSchema.ArrayObjectContext | ToJsonSchema.ArrayPostfixContext | ToJsonSchema.DefaultValueContext | ToJsonSchema.PatternIntersectionContext | ToJsonSchema.SymbolKeyContext) => never;\n    throwInternalOperandError: (kind: ConstraintKind, schema: JsonSchema) => never;\n    defaultConfig: ToJsonSchema.Context;\n};\ndeclare namespace ToJsonSchema {\n    type Unjsonifiable = object | symbol | bigint | undefined;\n    type Error = InstanceType<typeof ToJsonSchema.Error>;\n    interface BaseContext<code extends Code, base extends JsonSchema = JsonSchema> {\n        code: code;\n        base: base;\n    }\n    interface ArrayObjectContext extends BaseContext<\"arrayObject\", JsonSchema.Array> {\n        object: JsonSchema.Object;\n    }\n    interface ArrayPostfixContext extends BaseContext<\"arrayPostfix\", VariadicArraySchema> {\n        elements: readonly JsonSchema[];\n    }\n    interface DefaultValueContext extends BaseContext<\"defaultValue\", JsonSchema> {\n        value: Unjsonifiable;\n    }\n    interface DomainContext extends BaseContext<\"domain\", JsonSchema> {\n        domain: satisfy<Domain$1, \"symbol\" | \"bigint\" | \"undefined\">;\n    }\n    interface MorphContext extends BaseContext<\"morph\", JsonSchema> {\n        out: JsonSchema | null;\n    }\n    interface PatternIntersectionContext extends BaseContext<\"patternIntersection\", StringSchemaWithPattern> {\n        pattern: string;\n    }\n    interface PredicateContext extends BaseContext<\"predicate\", JsonSchema> {\n        predicate: Predicate;\n    }\n    interface ProtoContext extends BaseContext<\"proto\", JsonSchema> {\n        proto: Constructor;\n    }\n    type SymbolKeyContext = IndexSymbolKeyContext | RequiredSymbolKeyContext | OptionalSymbolKeyContext;\n    interface IndexSymbolKeyContext extends BaseContext<\"symbolKey\", JsonSchema.Object> {\n        key: null;\n        value: JsonSchema;\n        optional: false;\n    }\n    interface RequiredSymbolKeyContext extends BaseContext<\"symbolKey\", JsonSchema.Object> {\n        key: symbol;\n        value: JsonSchema;\n        optional: false;\n    }\n    interface OptionalSymbolKeyContext extends BaseContext<\"symbolKey\", JsonSchema.Object> {\n        key: symbol;\n        value: JsonSchema;\n        optional: true;\n        default?: Json;\n    }\n    interface UnitContext extends BaseContext<\"unit\", JsonSchema> {\n        unit: Unjsonifiable;\n    }\n    interface DateContext extends BaseContext<\"date\", JsonSchema> {\n        before?: Date;\n        after?: Date;\n    }\n    interface ContextByCode {\n        arrayObject: ArrayObjectContext;\n        arrayPostfix: ArrayPostfixContext;\n        defaultValue: DefaultValueContext;\n        domain: DomainContext;\n        morph: MorphContext;\n        patternIntersection: PatternIntersectionContext;\n        predicate: PredicateContext;\n        proto: ProtoContext;\n        symbolKey: SymbolKeyContext;\n        unit: UnitContext;\n        date: DateContext;\n    }\n    type Code = keyof ContextByCode;\n    type FallbackContext = ContextByCode[Code];\n    type HandlerByCode = satisfy<{\n        [code in Code]: (ctx: ContextByCode[code]) => unknown;\n    }, {\n        arrayObject: (ctx: ArrayObjectContext) => JsonSchema.Structure;\n        arrayPostfix: (ctx: ArrayPostfixContext) => VariadicArraySchema;\n        defaultValue: (ctx: DefaultValueContext) => JsonSchema;\n        domain: (ctx: DomainContext) => JsonSchema;\n        morph: (ctx: MorphContext) => JsonSchema;\n        patternIntersection: (ctx: PatternIntersectionContext) => JsonSchema.String;\n        predicate: (ctx: PredicateContext) => JsonSchema;\n        proto: (ctx: ProtoContext) => JsonSchema;\n        symbolKey: (ctx: SymbolKeyContext) => JsonSchema.Object;\n        unit: (ctx: UnitContext) => JsonSchema;\n        date: (ctx: DateContext) => JsonSchema;\n    }>;\n    type VariadicArraySchema = requireKeys<JsonSchema.Array, \"items\">;\n    type StringSchemaWithPattern = requireKeys<JsonSchema.String, \"pattern\">;\n    type UniversalFallback = (ctx: FallbackContext) => JsonSchema;\n    interface FallbackObject extends Partial<HandlerByCode> {\n        default?: UniversalFallback;\n    }\n    type FallbackOption = UniversalFallback | FallbackObject;\n    interface Options {\n        /** value to assign to the generated $schema key\n         *\n         *  - set to `null` to omit the `$schema` key\n         *  - does not affect the contents of the generated schema\n         *\n         * @default \"https://json-schema.org/draft/2020-12/schema\"\n         */\n        dialect?: string | null;\n        useRefs?: boolean;\n        fallback?: FallbackOption;\n    }\n    interface Context extends Required<Options> {\n        fallback: HandlerByCode;\n    }\n}\n\ndeclare class AliasNode extends BaseRoot<Alias.Declaration> {\n    readonly expression: string;\n    readonly structure: undefined;\n    get resolution(): BaseRoot;\n    protected _resolve(): BaseRoot;\n    get resolutionId(): NodeId;\n    get defaultShortDescription(): string;\n    protected innerToJsonSchema(ctx: ToJsonSchema.Context): JsonSchema;\n    traverseAllows: TraverseAllows;\n    traverseApply: TraverseApply;\n    compile(js: NodeCompiler): void;\n}\ndeclare namespace Alias {\n    type Schema<alias extends string = string> = `$${alias}` | NormalizedSchema<alias>;\n    interface NormalizedSchema<alias extends string = string> extends BaseNormalizedSchema {\n        readonly reference: alias;\n        readonly resolve?: () => BaseRoot;\n    }\n    interface Inner<alias extends string = string> {\n        readonly reference: alias;\n        readonly resolve?: () => BaseRoot;\n    }\n    interface Declaration extends declareNode<{\n        kind: \"alias\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n    }> {\n    }\n    type Node = AliasNode;\n}\ndeclare const Alias: {\n    implementation: nodeImplementationOf<Alias.Declaration>;\n    Node: typeof AliasNode;\n};\n\ndeclare const registryName: string;\ndeclare const $ark: ArkSchemaRegistry;\ndeclare const reference: (name: string) => RegisteredReference;\ndeclare const registeredReference: (value: object | symbol) => RegisteredReference;\ntype RegisteredReference<to extends string = string> = `$ark${\"\" | NonNegativeIntegerLiteral}.${to}`;\n\ntype InternalResolutions = Record<string, InternalResolution | undefined>;\ntype exportedNameOf<$> = Exclude<keyof $ & string, PrivateDeclaration>;\ntype resolvableReferenceIn<$> = {\n    [k in keyof $]: k extends string ? k extends PrivateDeclaration<infer alias> ? alias : k extends noSuggest | \"root\" ? never : k : never;\n}[keyof $];\ntype resolveReference<reference extends resolvableReferenceIn<$>, $> = reference extends keyof $ ? $[reference] : $[`#${reference}` & keyof $];\ntype flatResolutionsOf<$> = show<intersectUnion<resolvableReferenceIn<$> extends infer k ? k extends keyof $ & string ? resolutionsOfReference<k, $[k]> : unknown : unknown>>;\ntype resolutionsOfReference<k extends string, v> = [\n    v\n] extends [{\n    [arkKind]: \"module\";\n}] ? [\n    v\n] extends [anyOrNever] ? {\n    [_ in k]: v;\n} : prefixKeys<flatResolutionsOf<v>, k> & {\n    [innerKey in keyof v as innerKey extends \"root\" ? k : never]: v[innerKey];\n} : {\n    [_ in k]: v;\n};\ntype prefixKeys<o, prefix extends string> = {\n    [k in keyof o & string as `${prefix}.${k}`]: o[k];\n} & unknown;\ntype PrivateDeclaration<key extends string = string> = `#${key}`;\ntype InternalResolution = BaseRoot | GenericRoot | InternalModule;\ntype toInternalScope<$> = BaseScope<{\n    [k in keyof $]: $[k] extends {\n        [arkKind]: infer kind;\n    } ? [\n        $[k]\n    ] extends [anyOrNever] ? BaseRoot : kind extends \"generic\" ? GenericRoot : kind extends \"module\" ? InternalModule : never : BaseRoot;\n}>;\ntype CachedResolution = NodeId | BaseRoot | GenericRoot;\ndeclare const writeDuplicateAliasError: <alias extends string>(alias: alias) => writeDuplicateAliasError<alias>;\ntype writeDuplicateAliasError<alias extends string> = `#${alias} duplicates public alias ${alias}`;\ntype AliasDefEntry = [name: string, defValue: unknown];\ntype GlobalOnlyConfigOptionName = satisfy<keyof ArkSchemaConfig, \"dateAllowsInvalid\" | \"numberAllowsNaN\" | \"onUndeclaredKey\" | \"keywords\">;\ninterface ScopeOnlyConfigOptions {\n    name?: string;\n    prereducedAliases?: boolean;\n}\ninterface ArkSchemaScopeConfig extends Omit<ArkSchemaConfig, GlobalOnlyConfigOptionName>, ScopeOnlyConfigOptions {\n}\ninterface ResolvedScopeConfig extends ResolvedConfig, ScopeOnlyConfigOptions {\n}\ntype PrecompiledReferences = {\n    [k: `${string}Allows`]: TraverseAllows;\n    [k: `${string}Apply`]: TraverseApply;\n    [k: `${string}Optimistic`]: (data: unknown) => unknown;\n};\ndeclare abstract class BaseScope<$ extends {} = {}> {\n    readonly config: ArkSchemaScopeConfig;\n    readonly resolvedConfig: ResolvedScopeConfig;\n    readonly name: string;\n    get [arkKind](): \"scope\";\n    readonly referencesById: {\n        [id: string]: BaseNode;\n    };\n    references: readonly BaseNode[];\n    readonly resolutions: {\n        [alias: string]: CachedResolution | undefined;\n    };\n    exportedNames: string[];\n    readonly aliases: Record<string, unknown>;\n    protected resolved: boolean;\n    readonly nodesByHash: Record<string, BaseNode>;\n    readonly intrinsic: Omit<typeof $ark.intrinsic, `json${string}`>;\n    constructor(\n    /** The set of names defined at the root-level of the scope mapped to their\n     * corresponding definitions.**/\n    def: Record<string, unknown>, config?: ArkSchemaScopeConfig);\n    protected cacheGetter<name extends keyof this>(name: name, value: this[name]): this[name];\n    get internal(): this;\n    private _json;\n    get json(): JsonStructure;\n    defineSchema<def extends RootSchema>(def: def): def;\n    generic: GenericRootParser;\n    units: (values: array, opts?: BaseParseOptions) => BaseRoot;\n    protected lazyResolutions: Alias.Node[];\n    lazilyResolve(resolve: () => BaseRoot, syntheticAlias?: string): Alias.Node;\n    schema: InternalSchemaParser;\n    parseSchema: InternalSchemaParser;\n    protected preparseNode(kinds: NodeKind | listable<RootKind>, schema: unknown, opts: BaseParseOptions): BaseNode | NodeParseContextInput;\n    bindReference<reference extends BaseNode | GenericRoot>(reference: reference): reference;\n    resolveRoot(name: string): BaseRoot;\n    maybeResolveRoot(name: string): BaseRoot | undefined;\n    /** If name is a valid reference to a submodule alias, return its resolution  */\n    protected maybeResolveSubalias(name: string): BaseRoot | GenericRoot | undefined;\n    get ambient(): InternalModule;\n    maybeResolve(name: string): Exclude<CachedResolution, string> | undefined;\n    protected createParseContext<input extends BaseParseContextInput>(input: input): input & AttachedParseContext;\n    traversal(root: unknown): Traversal;\n    import(): SchemaModule<{\n        [k in exportedNameOf<$> as PrivateDeclaration<k>]: $[k];\n    }>;\n    import<names extends exportedNameOf<$>[]>(...names: names): SchemaModule<{\n        [k in names[number] as PrivateDeclaration<k>]: $[k];\n    } & unknown>;\n    precompilation: string | undefined;\n    private _exportedResolutions;\n    private _exports;\n    export(): SchemaModule<{\n        [k in exportedNameOf<$>]: $[k];\n    }>;\n    export<names extends exportedNameOf<$>[]>(...names: names): SchemaModule<{\n        [k in names[number]]: $[k];\n    } & unknown>;\n    resolve<name extends exportedNameOf<$>>(name: name): instantiateRoot<$[name]>;\n    node: <kinds extends NodeKind | array<RootKind>, prereduced extends boolean = false>(kinds: kinds, nodeSchema: NodeSchema<flattenListable<kinds>>, opts?: BaseParseOptions<prereduced>) => nodeOfKind<prereduced extends true ? flattenListable<kinds> : reducibleKindOf<flattenListable<kinds>>>;\n    parse: (def: unknown, opts?: BaseParseOptions) => BaseRoot;\n    parseDefinition(def: unknown, opts?: BaseParseOptions): BaseRoot;\n    finalize<node extends BaseRoot>(node: node): node;\n    protected abstract preparseOwnDefinitionFormat(def: unknown, opts: BaseParseOptions): BaseRoot | BaseParseContextInput;\n    abstract parseOwnDefinitionFormat(def: unknown, ctx: BaseParseContext): BaseRoot;\n    protected abstract preparseOwnAliasEntry(k: string, v: unknown): AliasDefEntry;\n    protected abstract normalizeRootScopeValue(resolution: unknown): unknown;\n}\ndeclare class SchemaScope<$ extends {} = {}> extends BaseScope<$> {\n    parseOwnDefinitionFormat(def: unknown, ctx: NodeParseContext): BaseRoot;\n    protected preparseOwnDefinitionFormat(schema: RootSchema, opts: BaseParseOptions): BaseRoot | NodeParseContextInput;\n    protected preparseOwnAliasEntry(k: string, v: unknown): AliasDefEntry;\n    protected normalizeRootScopeValue(v: unknown): unknown;\n}\ntype instantiateAliases<aliases> = {\n    [k in keyof aliases]: aliases[k] extends InternalResolution ? aliases[k] : BaseRoot;\n} & unknown;\ntype SchemaScopeParser = <const aliases>(aliases: {\n    [k in keyof aliases]: conform<aliases[k], RootSchema | PreparsedNodeResolution>;\n}, config?: ArkSchemaScopeConfig) => BaseScope<instantiateAliases<aliases>>;\ndeclare const schemaScope: SchemaScopeParser;\ntype InternalSchemaParser = (schema: RootSchema, opts?: BaseParseOptions) => BaseRoot;\ndeclare const rootSchemaScope: SchemaScope;\ndeclare const parseAsSchema: (def: unknown, opts?: BaseParseOptions) => BaseRoot | ParseError;\ntype RootExportCache = Record<string, BaseRoot | GenericRoot | RootModule | undefined>;\ndeclare const writeUnresolvableMessage: <token extends string>(token: token) => writeUnresolvableMessage<token>;\ntype writeUnresolvableMessage<token extends string> = `'${token}' is unresolvable`;\ndeclare const writeNonSubmoduleDotMessage: <name extends string>(name: name) => writeNonSubmoduleDotMessage<name>;\ntype writeNonSubmoduleDotMessage<name extends string> = `'${name}' must reference a module to be accessed using dot syntax`;\ndeclare const writeMissingSubmoduleAccessMessage: <name extends string>(name: name) => writeMissingSubmoduleAccessMessage<name>;\ntype writeMissingSubmoduleAccessMessage<name extends string> = `Reference to submodule '${name}' must specify an alias`;\ndeclare const rootSchema: BaseScope[\"schema\"];\ndeclare const node: BaseScope[\"node\"];\ndeclare const defineSchema: BaseScope[\"defineSchema\"];\ndeclare const genericNode: BaseScope[\"generic\"];\n\ndeclare class IndexNode extends BaseConstraint<Index.Declaration> {\n    impliedBasis: BaseRoot;\n    expression: string;\n    flatRefs: FlatRef<BaseRoot<InternalRootDeclaration>>[];\n    traverseAllows: TraverseAllows<object>;\n    traverseApply: TraverseApply<object>;\n    protected _transform(mapper: DeepNodeTransformation, ctx: DeepNodeTransformContext): BaseNode | null;\n    compile(): void;\n}\ndeclare namespace Index {\n    type KeyKind = Exclude<RootKind, \"unit\">;\n    type KeyNode = nodeOfKind<KeyKind>;\n    interface Schema extends BaseNormalizedSchema {\n        readonly signature: RootSchema<KeyKind>;\n        readonly value: RootSchema;\n    }\n    interface Inner {\n        readonly signature: KeyNode;\n        readonly value: BaseRoot;\n    }\n    interface Declaration extends declareNode<{\n        kind: \"index\";\n        schema: Schema;\n        normalizedSchema: Schema;\n        inner: Inner;\n        prerequisite: object;\n        intersectionIsOpen: true;\n        childKind: RootKind;\n    }> {\n    }\n    type Node = IndexNode;\n}\ndeclare const Index: {\n    implementation: nodeImplementationOf<Index.Declaration>;\n    Node: typeof IndexNode;\n};\ndeclare const writeEnumerableIndexBranches: (keys: string[]) => string;\ndeclare const writeInvalidPropertyKeyMessage: <indexSchema extends string>(indexSchema: indexSchema) => writeInvalidPropertyKeyMessage<indexSchema>;\ntype writeInvalidPropertyKeyMessage<indexSchema extends string> = `Indexed key definition '${indexSchema}' must be a string or symbol`;\n\ndeclare class RequiredNode extends BaseProp<\"required\"> {\n    expression: string;\n    errorContext: NodeErrorContextInput<\"required\">;\n    compiledErrorContext: string;\n}\ndeclare namespace Required$1 {\n    interface ErrorContext extends BaseErrorContext<\"required\"> {\n        missingValueDescription: string;\n    }\n    interface Schema extends Prop.Schema {\n    }\n    interface Inner extends Prop.Inner {\n    }\n    type Declaration = declareNode<Prop.Declaration<\"required\"> & {\n        schema: Schema;\n        normalizedSchema: Schema;\n        inner: Inner;\n        errorContext: ErrorContext;\n    }>;\n    type Node = RequiredNode;\n}\ndeclare const Required$1: {\n    implementation: nodeImplementationOf<{\n        reducibleTo: \"required\";\n        kind: \"required\";\n        prerequisite: object;\n        intersectionIsOpen: true;\n        childKind: RootKind;\n        schema: Required$1.Schema;\n        normalizedSchema: Required$1.Schema;\n        inner: Required$1.Inner;\n        errorContext: Required$1.ErrorContext;\n    }>;\n    Node: typeof RequiredNode;\n};\n\ndeclare namespace Prop {\n    type Kind = \"required\" | \"optional\";\n    type Node = nodeOfKind<Kind>;\n    interface Schema extends BaseNormalizedSchema {\n        readonly key: Key;\n        readonly value: RootSchema;\n    }\n    interface Inner {\n        readonly key: Key;\n        readonly value: BaseRoot;\n    }\n    interface Declaration<kind extends Kind = Kind> {\n        kind: kind;\n        prerequisite: object;\n        intersectionIsOpen: true;\n        childKind: RootKind;\n    }\n}\ndeclare const intersectProps: (l: nodeOfKind<Prop.Kind>, r: nodeOfKind<Prop.Kind>, ctx: IntersectionContext) => nodeOfKind<Prop.Kind> | Disjoint | null;\ndeclare abstract class BaseProp<kind extends Prop.Kind = Prop.Kind> extends BaseConstraint<kind extends \"required\" ? Required$1.Declaration : Optional.Declaration> {\n    required: boolean;\n    optional: boolean;\n    impliedBasis: BaseRoot;\n    serializedKey: string;\n    compiledKey: string;\n    flatRefs: FlatRef[];\n    protected _transform(mapper: DeepNodeTransformation, ctx: DeepNodeTransformContext): BaseNode | null;\n    hasDefault(): this is Optional.Node.withDefault;\n    traverseAllows: TraverseAllows<object>;\n    traverseApply: TraverseApply<object>;\n    compile(js: NodeCompiler): void;\n}\ndeclare const writeDefaultIntersectionMessage: (lValue: unknown, rValue: unknown) => string;\n\ndeclare class OptionalNode extends BaseProp<\"optional\"> {\n    constructor(...args: ConstructorParameters<typeof BaseProp>);\n    get rawIn(): OptionalNode;\n    get outProp(): Prop.Node;\n    expression: string;\n    defaultValueMorph: Morph | undefined;\n    defaultValueMorphRef: string | undefined;\n}\ndeclare namespace Optional {\n    interface Schema extends Prop.Schema {\n        default?: unknown;\n    }\n    interface Inner extends Prop.Inner {\n        default?: unknown;\n    }\n    type Declaration = declareNode<Prop.Declaration<\"optional\"> & {\n        schema: Schema;\n        normalizedSchema: Schema;\n        inner: Inner;\n    }>;\n    type Node = OptionalNode;\n    namespace Node {\n        type withDefault = requireKeys<Node, \"default\" | \"defaultValueMorph\" | \"defaultValueMorphRef\">;\n    }\n}\ndeclare const Optional: {\n    implementation: nodeImplementationOf<{\n        reducibleTo: \"optional\";\n        errorContext: null;\n        kind: \"optional\";\n        prerequisite: object;\n        intersectionIsOpen: true;\n        childKind: RootKind;\n        schema: Optional.Schema;\n        normalizedSchema: Optional.Schema;\n        inner: Optional.Inner;\n    }>;\n    Node: typeof OptionalNode;\n};\ndeclare const computeDefaultValueMorph: (key: PropertyKey, value: BaseRoot, defaultInput: unknown) => Morph;\ndeclare const assertDefaultValueAssignability: (node: BaseRoot, value: unknown, key: PropertyKey | null) => unknown;\ntype writeUnassignableDefaultValueMessage<baseDef extends string, defaultValue extends string> = `Default value ${defaultValue} must be assignable to ${baseDef}`;\ndeclare const writeNonPrimitiveNonFunctionDefaultValueMessage: (key: PropertyKey | null) => string;\n\ninterface BaseRangeDeclaration extends BaseNodeDeclaration {\n    kind: RangeKind;\n    inner: BaseRangeInner;\n    normalizedSchema: UnknownExpandedRangeSchema;\n}\ndeclare abstract class BaseRange<d extends BaseRangeDeclaration> extends InternalPrimitiveConstraint<d> {\n    readonly exclusive?: true;\n    readonly boundOperandKind: OperandKindsByBoundKind[d[\"kind\"]];\n    readonly compiledActual: string;\n    readonly comparator: RelativeComparator;\n    readonly numericLimit: number;\n    readonly expression: string;\n    readonly compiledCondition: string;\n    readonly compiledNegation: string;\n    readonly stringLimit: string;\n    readonly limitKind: LimitKind;\n    isStricterThan(r: nodeOfKind<d[\"kind\"] | pairedRangeKind<d[\"kind\"]>>): boolean;\n    overlapsRange(r: nodeOfKind<pairedRangeKind<d[\"kind\"]>>): boolean;\n    overlapIsUnit(r: nodeOfKind<pairedRangeKind<d[\"kind\"]>>): boolean;\n}\ninterface BaseRangeInner {\n    readonly rule: LimitValue;\n}\ntype LimitValue = Date | number;\ntype LimitSchemaValue = Date | number | string;\ntype LimitInnerValue<kind extends RangeKind = RangeKind> = kind extends \"before\" | \"after\" ? Date : number;\ninterface UnknownExpandedRangeSchema extends BaseNormalizedSchema {\n    readonly rule: LimitSchemaValue;\n    readonly exclusive?: boolean;\n}\ninterface UnknownNormalizedRangeSchema extends BaseNormalizedSchema {\n    readonly rule: LimitSchemaValue;\n}\ntype UnknownRangeSchema = LimitSchemaValue | UnknownExpandedRangeSchema;\ninterface ExclusiveExpandedDateRangeSchema extends BaseNormalizedSchema {\n    rule: LimitSchemaValue;\n    exclusive?: true;\n}\ntype ExclusiveDateRangeSchema = LimitSchemaValue | ExclusiveExpandedDateRangeSchema;\ninterface InclusiveExpandedDateRangeSchema extends BaseNormalizedSchema {\n    rule: LimitSchemaValue;\n    exclusive?: false;\n}\ntype InclusiveDateRangeSchema = LimitSchemaValue | InclusiveExpandedDateRangeSchema;\ninterface ExclusiveNormalizedNumericRangeSchema extends BaseNormalizedSchema {\n    rule: number;\n    exclusive?: true;\n}\ntype ExclusiveNumericRangeSchema = number | ExclusiveNormalizedNumericRangeSchema;\ninterface InclusiveNormalizedNumericRangeSchema extends BaseNormalizedSchema {\n    rule: number;\n    exclusive?: false;\n}\ntype InclusiveNumericRangeSchema = number | InclusiveNormalizedNumericRangeSchema;\ntype LimitKind = \"lower\" | \"upper\";\ntype RelativeComparator<kind extends LimitKind = LimitKind> = {\n    lower: \">\" | \">=\";\n    upper: \"<\" | \"<=\";\n}[kind];\ndeclare const boundKindPairsByLower: BoundKindPairsByLower;\ntype BoundKindPairsByLower = {\n    min: \"max\";\n    minLength: \"maxLength\";\n    after: \"before\";\n};\ntype BoundKindPairsByUpper = {\n    max: \"min\";\n    maxLength: \"minLength\";\n    before: \"after\";\n};\ntype pairedRangeKind<kind extends RangeKind> = kind extends LowerBoundKind ? BoundKindPairsByLower[kind] : BoundKindPairsByUpper[kind & UpperBoundKind];\ntype LowerBoundKind = keyof typeof boundKindPairsByLower;\ntype LowerNode = nodeOfKind<LowerBoundKind>;\ntype UpperBoundKind = propValueOf<typeof boundKindPairsByLower>;\ntype UpperNode = nodeOfKind<UpperBoundKind>;\ntype NumericallyBoundable = string | number | array;\ntype Boundable = NumericallyBoundable | Date;\ndeclare const parseExclusiveKey: keySchemaDefinitions<Declaration<\"min\" | \"max\">>[\"exclusive\"];\ndeclare const createLengthSchemaNormalizer: <kind extends \"minLength\" | \"maxLength\">(kind: kind) => (schema: NodeSchema<kind>) => NormalizedSchema<kind>;\ndeclare const createDateSchemaNormalizer: <kind extends DateRangeKind>(kind: kind) => (schema: NodeSchema<kind>) => NormalizedSchema<kind>;\ndeclare const parseDateLimit: (limit: LimitSchemaValue) => Date;\ntype LengthBoundKind = \"minLength\" | \"maxLength\" | \"exactLength\";\ndeclare const writeInvalidLengthBoundMessage: (kind: LengthBoundKind, limit: number) => string;\ndeclare const createLengthRuleParser: (kind: LengthBoundKind) => (limit: number) => number | undefined;\ntype OperandKindsByBoundKind = satisfy<Record<RangeKind, BoundOperandKind>, {\n    min: \"value\";\n    max: \"value\";\n    minLength: \"length\";\n    maxLength: \"length\";\n    after: \"date\";\n    before: \"date\";\n}>;\ndeclare const compileComparator: (kind: RangeKind, exclusive: boolean | undefined) => RelativeComparator;\ntype BoundOperandKind = \"value\" | \"length\" | \"date\";\ntype LengthBoundableData = string | array;\ntype DateRangeKind = \"before\" | \"after\";\ndeclare const dateLimitToString: (limit: LimitSchemaValue) => string;\ndeclare const writeUnboundableMessage: <root extends string>(root: root) => writeUnboundableMessage<root>;\ntype writeUnboundableMessage<root extends string> = `Bounded expression ${root} must be exactly one of number, string, Array, or Date`;\n\ndeclare class ExactLengthNode extends InternalPrimitiveConstraint<ExactLength.Declaration> {\n    traverseAllows: TraverseAllows<LengthBoundableData>;\n    readonly compiledCondition: string;\n    readonly compiledNegation: string;\n    readonly impliedBasis: BaseRoot;\n    readonly expression: string;\n    reduceJsonSchema(schema: JsonSchema.LengthBoundable): JsonSchema.LengthBoundable;\n}\ndeclare namespace ExactLength {\n    interface Inner {\n        readonly rule: number;\n    }\n    interface NormalizedSchema extends BaseNormalizedSchema {\n        readonly rule: number;\n    }\n    type Schema = NormalizedSchema | number;\n    interface ErrorContext extends BaseErrorContext<\"exactLength\">, Inner {\n    }\n    type Declaration = declareNode<{\n        kind: \"exactLength\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        prerequisite: LengthBoundableData;\n        errorContext: ErrorContext;\n    }>;\n    type Node = ExactLengthNode;\n}\ndeclare const ExactLength: {\n    implementation: nodeImplementationOf<{\n        intersectionIsOpen: false;\n        childKind: never;\n        reducibleTo: \"exactLength\";\n        kind: \"exactLength\";\n        schema: ExactLength.Schema;\n        normalizedSchema: ExactLength.NormalizedSchema;\n        inner: ExactLength.Inner;\n        prerequisite: LengthBoundableData;\n        errorContext: ExactLength.ErrorContext;\n    }>;\n    Node: typeof ExactLengthNode;\n};\n\ndeclare class MaxLengthNode extends BaseRange<MaxLength.Declaration> {\n    readonly impliedBasis: BaseRoot;\n    traverseAllows: TraverseAllows<LengthBoundableData>;\n    reduceJsonSchema(schema: JsonSchema.LengthBoundable): JsonSchema.LengthBoundable;\n}\ndeclare namespace MaxLength {\n    interface Inner extends BaseRangeInner {\n        rule: number;\n    }\n    interface NormalizedSchema extends UnknownNormalizedRangeSchema {\n        rule: number;\n    }\n    interface ExpandedSchema extends UnknownExpandedRangeSchema {\n        rule: number;\n    }\n    type Schema = ExpandedSchema | number;\n    interface ErrorContext extends BaseErrorContext<\"maxLength\">, Inner {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"maxLength\";\n        schema: Schema;\n        reducibleTo: \"exactLength\";\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        prerequisite: LengthBoundableData;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = MaxLengthNode;\n}\ndeclare const MaxLength: {\n    implementation: nodeImplementationOf<MaxLength.Declaration>;\n    Node: typeof MaxLengthNode;\n};\n\ndeclare class MinLengthNode extends BaseRange<MinLength.Declaration> {\n    readonly impliedBasis: BaseRoot;\n    traverseAllows: TraverseAllows<LengthBoundableData>;\n    reduceJsonSchema(schema: JsonSchema.LengthBoundable): JsonSchema.LengthBoundable;\n}\ndeclare namespace MinLength {\n    interface Inner extends BaseRangeInner {\n        rule: number;\n    }\n    interface NormalizedSchema extends UnknownNormalizedRangeSchema {\n        rule: number;\n    }\n    interface ExpandedSchema extends UnknownExpandedRangeSchema {\n        rule: number;\n    }\n    type Schema = ExpandedSchema | number;\n    interface ErrorContext extends BaseErrorContext<\"minLength\">, Inner {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"minLength\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        prerequisite: LengthBoundableData;\n        reducibleTo: \"intersection\";\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = MinLengthNode;\n}\ndeclare const MinLength: {\n    implementation: nodeImplementationOf<MinLength.Declaration>;\n    Node: typeof MinLengthNode;\n};\n\ndeclare class SequenceNode extends BaseConstraint<Sequence.Declaration> {\n    impliedBasis: BaseRoot;\n    tuple: SequenceTuple;\n    prefixLength: number;\n    defaultablesLength: number;\n    optionalsLength: number;\n    postfixLength: number;\n    defaultablesAndOptionals: BaseRoot[];\n    prevariadic: array<PrevariadicSequenceElement>;\n    variadicOrPostfix: array<BaseRoot>;\n    flatRefs: FlatRef[];\n    protected addFlatRefs(): FlatRef[];\n    isVariadicOnly: boolean;\n    minVariadicLength: number;\n    minLength: number;\n    minLengthNode: MinLengthNode | null;\n    maxLength: number | null;\n    maxLengthNode: MaxLengthNode | ExactLengthNode | null;\n    impliedSiblings: array<MaxLengthNode | MinLengthNode | ExactLengthNode>;\n    defaultValueMorphs: Morph[];\n    defaultValueMorphsReference: `$ark.${string}` | `$ark0.${string}` | `$ark${`1${string}` & `${bigint}`}.${string}` | `$ark${`4${string}` & `${bigint}`}.${string}` | `$ark${`2${string}` & `${bigint}`}.${string}` | `$ark${`3${string}` & `${bigint}`}.${string}` | `$ark${`5${string}` & `${bigint}`}.${string}` | `$ark${`6${string}` & `${bigint}`}.${string}` | `$ark${`7${string}` & `${bigint}`}.${string}` | `$ark${`8${string}` & `${bigint}`}.${string}` | `$ark${`9${string}` & `${bigint}`}.${string}` | undefined;\n    protected elementAtIndex(data: array, index: number): SequenceElement;\n    traverseAllows: TraverseAllows<array>;\n    traverseApply: TraverseApply<array>;\n    get element(): BaseRoot;\n    compile(js: NodeCompiler): void;\n    protected _transform(mapper: DeepNodeTransformation, ctx: DeepNodeTransformContext): BaseNode | null;\n    expression: string;\n    reduceJsonSchema(schema: JsonSchema.Array, ctx: ToJsonSchema.Context): JsonSchema.Array;\n}\ndeclare namespace Sequence {\n    interface NormalizedSchema extends BaseNormalizedSchema {\n        readonly prefix?: array<RootSchema>;\n        readonly defaultables?: array<DefaultableSchema>;\n        readonly optionals?: array<RootSchema>;\n        readonly variadic?: RootSchema;\n        readonly minVariadicLength?: number;\n        readonly postfix?: array<RootSchema>;\n    }\n    type Schema = NormalizedSchema | RootSchema;\n    type DefaultableSchema = [schema: RootSchema, defaultValue: unknown];\n    type DefaultableElement = [node: BaseRoot, defaultValue: unknown];\n    interface Inner {\n        readonly prefix?: array<BaseRoot>;\n        readonly defaultables?: array<DefaultableElement>;\n        readonly optionals?: array<BaseRoot>;\n        readonly variadic?: BaseRoot;\n        readonly minVariadicLength?: number;\n        readonly postfix?: array<BaseRoot>;\n    }\n    interface Declaration extends declareNode<{\n        kind: \"sequence\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        prerequisite: array;\n        reducibleTo: \"sequence\";\n        childKind: RootKind;\n    }> {\n    }\n    type Node = SequenceNode;\n}\ndeclare const Sequence: {\n    implementation: nodeImplementationOf<Sequence.Declaration>;\n    Node: typeof SequenceNode;\n};\ndeclare const postfixAfterOptionalOrDefaultableMessage = \"A postfix required element cannot follow an optional or defaultable element\";\ntype postfixAfterOptionalOrDefaultableMessage = typeof postfixAfterOptionalOrDefaultableMessage;\ndeclare const postfixWithoutVariadicMessage = \"A postfix element requires a variadic element\";\ntype postfixWithoutVariadicMessage = typeof postfixWithoutVariadicMessage;\ntype SequenceElement = PrevariadicSequenceElement | VariadicSequenceElement | PostfixSequenceElement;\ntype SequenceElementKind = satisfy<keyof Sequence.Inner, SequenceElement[\"kind\"]>;\ntype PrevariadicSequenceElement = PrefixSequenceElement | DefaultableSequenceElement | OptionalSequenceElement;\ntype PrefixSequenceElement = {\n    kind: \"prefix\";\n    node: BaseRoot;\n};\ntype OptionalSequenceElement = {\n    kind: \"optionals\";\n    node: BaseRoot;\n};\ntype PostfixSequenceElement = {\n    kind: \"postfix\";\n    node: BaseRoot;\n};\ntype VariadicSequenceElement = {\n    kind: \"variadic\";\n    node: BaseRoot;\n};\ntype DefaultableSequenceElement = {\n    kind: \"defaultables\";\n    node: BaseRoot;\n    default: unknown;\n};\ntype SequenceTuple = array<SequenceElement>;\n\n/**\n * - `\"ignore\"` (default) - allow and preserve extra properties\n * - `\"reject\"` - disallow extra properties\n * - `\"delete\"` - clone and remove extra properties from output\n */\ntype UndeclaredKeyBehavior = \"ignore\" | UndeclaredKeyHandling;\ntype UndeclaredKeyHandling = \"reject\" | \"delete\";\ndeclare class StructureNode extends BaseConstraint<Structure.Declaration> {\n    impliedBasis: BaseRoot;\n    impliedSiblings: BaseConstraint<Constraint.Declaration>[];\n    props: array<Prop.Node>;\n    propsByKey: Record<Key, Prop.Node | undefined>;\n    propsByKeyReference: RegisteredReference;\n    expression: string;\n    requiredKeys: Key[];\n    optionalKeys: Key[];\n    literalKeys: Key[];\n    _keyof: BaseRoot | undefined;\n    keyof(): BaseRoot;\n    map(flatMapProp: PropFlatMapper): StructureNode;\n    assertHasKeys(keys: array<KeyOrKeyNode>): void;\n    get(indexer: GettableKeyOrNode, ...path: array<GettableKeyOrNode>): BaseRoot;\n    pick(...keys: KeyOrKeyNode[]): StructureNode;\n    omit(...keys: KeyOrKeyNode[]): StructureNode;\n    optionalize(): StructureNode;\n    require(): StructureNode;\n    merge(r: StructureNode): StructureNode;\n    private filterKeys;\n    traverseAllows: TraverseAllows<object>;\n    traverseApply: TraverseApply<object>;\n    protected _traverse: (traversalKind: TraversalKind, data: object, ctx: InternalTraversal) => boolean;\n    get defaultable(): Optional.Node.withDefault[];\n    declaresKey: (k: Key) => boolean;\n    _compileDeclaresKey(js: NodeCompiler): string;\n    get structuralMorph(): Morph | undefined;\n    structuralMorphRef: RegisteredReference | undefined;\n    compile(js: NodeCompiler): unknown;\n    protected compileExhaustiveEntry(js: NodeCompiler): NodeCompiler;\n    reduceJsonSchema(schema: JsonSchema.Structure, ctx: ToJsonSchema.Context): JsonSchema.Structure;\n    reduceObjectJsonSchema(schema: JsonSchema.Object, ctx: ToJsonSchema.Context): JsonSchema.Object;\n}\ntype PropFlatMapper = (entry: Prop.Node) => listable<MappedPropInner>;\ntype MappedPropInner = BaseMappedPropInner | OptionalMappedPropInner;\ninterface BaseMappedPropInner extends Required$1.Schema {\n    kind?: \"required\" | \"optional\";\n}\ninterface OptionalMappedPropInner extends Optional.Schema {\n    kind: \"optional\";\n}\ndeclare namespace Structure {\n    interface Schema extends BaseNormalizedSchema {\n        readonly optional?: readonly Optional.Schema[];\n        readonly required?: readonly Required$1.Schema[];\n        readonly index?: readonly Index.Schema[];\n        readonly sequence?: Sequence.Schema;\n        readonly undeclared?: UndeclaredKeyBehavior;\n    }\n    interface Inner {\n        readonly optional?: readonly Optional.Node[];\n        readonly required?: readonly Required$1.Node[];\n        readonly index?: readonly Index.Node[];\n        readonly sequence?: Sequence.Node;\n        readonly undeclared?: UndeclaredKeyHandling;\n    }\n    namespace Inner {\n        type mutable = makeRootAndArrayPropertiesMutable<Inner>;\n    }\n    interface Declaration extends declareNode<{\n        kind: \"structure\";\n        schema: Schema;\n        normalizedSchema: Schema;\n        inner: Inner;\n        prerequisite: object;\n        childKind: StructuralKind;\n    }> {\n    }\n    type Node = StructureNode;\n}\ndeclare const Structure: {\n    implementation: nodeImplementationOf<Structure.Declaration>;\n    Node: typeof StructureNode;\n};\ndeclare const writeNumberIndexMessage: (indexExpression: string, sequenceExpression: string) => string;\ntype NormalizedIndex = {\n    index?: Index.Node;\n    required?: Required$1.Node[];\n    optional?: Optional.Node[];\n};\n/** extract enumerable named props from an index signature */\ndeclare const normalizeIndex: (signature: BaseRoot, value: BaseRoot, $: BaseScope) => NormalizedIndex;\ndeclare const typeKeyToString: (k: KeyOrKeyNode) => string;\ndeclare const writeInvalidKeysMessage: <o extends string, keys extends array<KeyOrKeyNode>>(o: o, keys: keys) => string;\n\ndeclare const basisKinds: readonly [\"unit\", \"proto\", \"domain\"];\ntype BasisKind = (typeof basisKinds)[number];\ndeclare const structuralKinds: readonly [\"required\", \"optional\", \"index\", \"sequence\"];\ntype StructuralKind = (typeof structuralKinds)[number];\ntype RangeKind = Exclude<BoundKind, \"exactLength\">;\ntype BoundKind = Exclude<RefinementKind, \"pattern\" | \"divisor\">;\ndeclare const refinementKinds: readonly [\"pattern\", \"divisor\", \"exactLength\", \"max\", \"min\", \"maxLength\", \"minLength\", \"before\", \"after\"];\ntype RefinementKind = (typeof refinementKinds)[number];\ntype orderedConstraintKinds = [\n    ...typeof refinementKinds,\n    ...typeof structuralKinds,\n    \"structure\",\n    \"predicate\"\n];\ndeclare const constraintKinds: orderedConstraintKinds;\ntype ConstraintKind = (typeof constraintKinds)[number];\ndeclare const rootKinds: readonly [\"alias\", \"union\", \"morph\", \"unit\", \"intersection\", \"proto\", \"domain\"];\ntype RootKind = (typeof rootKinds)[number];\ntype NodeKind = RootKind | ConstraintKind;\ntype orderedNodeKinds = [...typeof rootKinds, ...typeof constraintKinds];\ndeclare const nodeKinds: orderedNodeKinds;\ntype OpenNodeKind = {\n    [k in NodeKind]: Declaration<k>[\"intersectionIsOpen\"] extends true ? k : never;\n}[NodeKind];\ntype ClosedNodeKind = Exclude<NodeKind, OpenNodeKind>;\ntype PrimitiveKind = RefinementKind | BasisKind | \"predicate\";\ntype CompositeKind = Exclude<NodeKind, PrimitiveKind>;\ntype OrderedNodeKinds = typeof nodeKinds;\ndeclare const constraintKeys: KeySet<ConstraintKind>;\ndeclare const structureKeys: keySetOf<Structure.Inner>;\ntype RightsByKind = accumulateRightKinds<OrderedNodeKinds, {}>;\ntype kindOrRightOf<kind extends NodeKind> = kind | kindRightOf<kind>;\ntype kindLeftOf<kind extends NodeKind> = Exclude<NodeKind, kindOrRightOf<kind>>;\ntype kindOrLeftOf<kind extends NodeKind> = kind | kindLeftOf<kind>;\ntype accumulateRightKinds<remaining extends readonly NodeKind[], result> = remaining extends (readonly [infer head extends NodeKind, ...infer tail extends NodeKind[]]) ? accumulateRightKinds<tail, result & {\n    [k in head]: tail[number];\n}> : result;\ninterface InternalIntersectionOptions {\n    pipe: boolean;\n}\ninterface IntersectionContext extends InternalIntersectionOptions {\n    $: BaseScope;\n    invert: boolean;\n}\ntype ConstraintIntersection<lKind extends ConstraintKind, rKind extends kindOrRightOf<lKind>> = (l: nodeOfKind<lKind>, r: nodeOfKind<rKind>, ctx: IntersectionContext) => BaseNode | Disjoint | null;\ntype ConstraintIntersectionMap<kind extends ConstraintKind> = show<{\n    [_ in kind]: ConstraintIntersection<kind, kind>;\n} & {\n    [rKind in kindRightOf<kind>]?: ConstraintIntersection<kind, rKind>;\n}>;\ntype RootIntersection<lKind extends RootKind, rKind extends schemaKindOrRightOf<lKind>> = (l: nodeOfKind<lKind>, r: nodeOfKind<rKind>, ctx: IntersectionContext) => BaseRoot | Disjoint;\ntype TypeIntersectionMap<kind extends RootKind> = {\n    [rKind in schemaKindOrRightOf<kind>]: RootIntersection<kind, rKind>;\n};\ntype IntersectionMap<kind extends NodeKind> = kind extends RootKind ? TypeIntersectionMap<kind> : ConstraintIntersectionMap<kind & ConstraintKind>;\ntype UnknownIntersectionMap = {\n    [k in NodeKind]?: (l: BaseNode, r: BaseNode, ctx: IntersectionContext) => UnknownIntersectionResult;\n};\ntype UnknownIntersectionResult = BaseNode | Disjoint | null;\ntype PrecedenceByKind = {\n    [i in arrayIndexOf<OrderedNodeKinds> as OrderedNodeKinds[i]]: i;\n};\ndeclare const precedenceByKind: PrecedenceByKind;\ndeclare const isNodeKind: (value: unknown) => value is NodeKind;\ndeclare function assertNodeKind<kind extends NodeKind>(value: BaseNode, kind: kind): asserts value is nodeOfKind<kind>;\ntype precedenceOfKind<kind extends NodeKind> = PrecedenceByKind[kind];\ndeclare const precedenceOfKind: <kind extends NodeKind>(kind: kind) => precedenceOfKind<kind>;\ntype kindRightOf<kind extends NodeKind> = RightsByKind[kind];\ndeclare const schemaKindsRightOf: <kind extends RootKind>(kind: kind) => schemaKindRightOf<kind>[];\ndeclare const unionChildKinds: readonly [...(\"intersection\" | \"morph\" | \"unit\" | \"proto\" | \"domain\")[], \"alias\"];\ntype UnionChildKind = (typeof unionChildKinds)[number];\ndeclare const morphChildKinds: readonly [...(\"intersection\" | \"unit\" | \"proto\" | \"domain\")[], \"alias\"];\ntype MorphChildKind = (typeof morphChildKinds)[number];\ntype keySchemaDefinitions<d extends BaseNodeDeclaration> = {\n    [k in keyRequiringSchemaDefinition<d>]: NodeKeyImplementation<d, k>;\n};\ntype keyRequiringSchemaDefinition<d extends BaseNodeDeclaration> = Exclude<keyof d[\"normalizedSchema\"], keyof BaseNormalizedSchema>;\ndeclare const defaultValueSerializer: (v: unknown) => Json;\ntype NodeKeyImplementation<d extends BaseNodeDeclaration, k extends keyof d[\"normalizedSchema\"], instantiated = k extends keyof d[\"inner\"] ? Exclude<d[\"inner\"][k], undefined> : never> = requireKeys<{\n    preserveUndefined?: true;\n    child?: boolean | ((value: instantiated) => BaseNode[]);\n    serialize?: (schema: instantiated) => Json;\n    reduceIo?: (ioKind: \"in\" | \"out\", inner: makeRootAndArrayPropertiesMutable<d[\"inner\"]>, value: d[\"inner\"][k]) => void;\n    parse?: (schema: Exclude<d[\"normalizedSchema\"][k], undefined>, ctx: NodeParseContext<d[\"kind\"]>) => instantiated | undefined;\n}, (d[\"normalizedSchema\"][k] extends instantiated | undefined ? never : \"parse\") | ([instantiated] extends [listable<BaseNode>] ? \"child\" : never)>;\ninterface CommonNodeImplementationInput<d extends BaseNodeDeclaration> {\n    kind: d[\"kind\"];\n    keys: keySchemaDefinitions<d>;\n    normalize: (schema: d[\"schema\"], $: BaseScope) => d[\"normalizedSchema\"];\n    applyConfig?: (schema: d[\"normalizedSchema\"], config: ResolvedScopeConfig) => d[\"normalizedSchema\"];\n    hasAssociatedError: d[\"errorContext\"] extends null ? false : true;\n    finalizeInnerJson?: (json: {\n        [k in keyof d[\"inner\"]]: Json;\n    }) => JsonStructure;\n    collapsibleKey?: keyof d[\"inner\"];\n    reduce?: (inner: d[\"inner\"], $: BaseScope) => nodeOfKind<d[\"reducibleTo\"]> | Disjoint | undefined;\n    obviatesBasisDescription?: d[\"kind\"] extends RefinementKind ? true : never;\n    obviatesBasisExpression?: d[\"kind\"] extends RefinementKind ? true : never;\n}\ninterface UnknownNodeImplementation extends CommonNodeImplementationInput<BaseNodeDeclaration> {\n    defaults: ResolvedUnknownNodeConfig;\n    intersectionIsOpen: boolean;\n    intersections: UnknownIntersectionMap;\n    keys: Record<string, NodeKeyImplementation<any, any>>;\n}\ndeclare const compileObjectLiteral: (ctx: object) => string;\ntype nodeImplementationOf<d extends BaseNodeDeclaration> = nodeImplementationInputOf<d> & {\n    intersections: IntersectionMap<d[\"kind\"]>;\n    intersectionIsOpen: d[\"intersectionIsOpen\"];\n    defaults: Required<NodeConfig<d[\"kind\"]>>;\n};\ntype nodeImplementationInputOf<d extends BaseNodeDeclaration> = CommonNodeImplementationInput<d> & {\n    intersections: IntersectionMap<d[\"kind\"]>;\n    defaults: nodeSchemaaultsImplementationInputFor<d[\"kind\"]>;\n} & (d[\"intersectionIsOpen\"] extends true ? {\n    intersectionIsOpen: true;\n} : {}) & (d[\"reducibleTo\"] extends d[\"kind\"] ? {} : {\n    reduce: {};\n});\ntype nodeSchemaaultsImplementationInputFor<kind extends NodeKind> = requireKeys<NodeConfig<kind>, \"description\" | (Inner<kind> extends (Omit<errorContext<kind>, keyof BaseErrorContext | \"description\">) ? never : \"expected\" & keyof NodeConfig<kind>)>;\ntype DescriptionWriter<kind extends NodeKind = NodeKind> = (node: nodeOfKind<kind>) => string;\ninterface UnknownAttachments {\n    readonly kind: NodeKind;\n    readonly impl: UnknownNodeImplementation;\n    readonly id: NodeId;\n    readonly inner: Record<string, any>;\n    readonly innerEntries: readonly Entry<string>[];\n    readonly innerJson: object;\n    readonly innerHash: string;\n    readonly meta: NodeMeta;\n    readonly metaJson: object;\n    readonly json: object;\n    readonly hash: string;\n    readonly collapsibleJson: Json;\n    readonly children: BaseNode[];\n}\ninterface NarrowedAttachments<d extends BaseNodeDeclaration> extends UnknownAttachments {\n    kind: d[\"kind\"];\n    inner: d[\"inner\"];\n    json: JsonStructure;\n    innerJson: JsonStructure;\n    collapsibleJson: Json;\n    children: nodeOfKind<d[\"childKind\"]>[];\n}\ndeclare const implementNode: <d extends BaseNodeDeclaration = never>(_: nodeImplementationInputOf<d>) => nodeImplementationOf<d>;\n\ndeclare abstract class InternalBasis<d extends InternalRootDeclaration = InternalRootDeclaration> extends BaseRoot<d> {\n    abstract compiledCondition: string;\n    abstract compiledNegation: string;\n    structure: undefined;\n    traverseApply: TraverseApply<d[\"prerequisite\"]>;\n    get errorContext(): d[\"errorContext\"];\n    get compiledErrorContext(): string;\n    compile(js: NodeCompiler): void;\n}\n\ndeclare class DomainNode extends InternalBasis<Domain.Declaration> {\n    private readonly requiresNaNCheck;\n    readonly traverseAllows: TraverseAllows;\n    readonly compiledCondition: string;\n    readonly compiledNegation: string;\n    readonly expression: string;\n    get nestableExpression(): string;\n    get defaultShortDescription(): string;\n    protected innerToJsonSchema(ctx: ToJsonSchema.Context): JsonSchema.Constrainable;\n}\ntype Domain = Domain$1;\ndeclare namespace Domain {\n    type Enumerable = \"undefined\" | \"null\" | \"boolean\";\n    type NonEnumerable = Exclude<Domain, Enumerable>;\n    interface Inner<domain extends NonEnumerable = NonEnumerable> {\n        readonly domain: domain;\n        readonly numberAllowsNaN?: boolean;\n    }\n    interface NormalizedSchema<domain extends NonEnumerable = NonEnumerable> extends BaseNormalizedSchema, Inner<domain> {\n    }\n    type Schema<domain extends NonEnumerable = NonEnumerable> = domain | NormalizedSchema<domain>;\n    interface ErrorContext extends BaseErrorContext<\"domain\">, Inner {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"domain\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = DomainNode;\n}\ndeclare const Domain: {\n    implementation: nodeImplementationOf<Domain.Declaration>;\n    Node: typeof DomainNode;\n    writeBadAllowNanMessage: (actual: Exclude<Domain.NonEnumerable, \"number\">) => string;\n};\n\ninterface DisjointEntry<kind extends DisjointKind = DisjointKind> {\n    kind: kind;\n    l: OperandsByDisjointKind[kind];\n    r: OperandsByDisjointKind[kind];\n    path: Key[];\n    optional: boolean;\n}\ntype OperandsByDisjointKind = {\n    domain: nodeOfKind<\"domain\"> | Domain.Enumerable;\n    unit: nodeOfKind<\"unit\">;\n    proto: nodeOfKind<\"proto\">;\n    presence: BaseRoot;\n    range: nodeOfKind<BoundKind>;\n    assignability: BaseNode;\n    union: readonly BaseRoot[];\n};\ntype DisjointEntryContext = {\n    path?: Key[];\n    optional?: true;\n};\ndeclare class Disjoint extends Array<DisjointEntry> {\n    static init<kind extends DisjointKind>(kind: kind, l: OperandsByDisjointKind[kind], r: OperandsByDisjointKind[kind], ctx?: DisjointEntryContext): Disjoint;\n    add<kind extends DisjointKind>(kind: kind, l: OperandsByDisjointKind[kind], r: OperandsByDisjointKind[kind], ctx?: DisjointEntryContext): Disjoint;\n    get summary(): string;\n    describeReasons(): string;\n    throw(): never;\n    invert(): Disjoint;\n    withPrefixKey(key: PropertyKey, kind: Prop.Kind): Disjoint;\n    toNeverIfDisjoint(): BaseRoot;\n}\ntype DisjointKind = keyof OperandsByDisjointKind;\ndeclare const writeUnsatisfiableExpressionError: <expression extends string>(expression: expression) => writeUnsatisfiableExpressionError<expression>;\ntype writeUnsatisfiableExpressionError<expression extends string> = `${expression} results in an unsatisfiable type`;\n\ntype withMetaPrefixedKeys<o> = {\n    [k in keyof o as k extends string ? `meta.${k}` : never]: o[k];\n};\ninterface DefaultArkEnv {\n    meta(): {};\n    onFail(errors: ArkErrors): ArkErrors;\n}\ninterface NodeMeta extends JsonSchema.UniversalMeta, UnknownErrorConfigs {\n    alias?: string;\n    onFail?: ArkErrors.Handler;\n}\ndeclare global {\n    export interface ArkEnv extends DefaultArkEnv {\n    }\n    export namespace ArkEnv {\n        type meta = show<NodeMeta & ReturnType<ArkEnv[\"meta\"]>>;\n        type onFail = ReturnType<ArkEnv[\"onFail\"]>;\n    }\n}\ntype TypeMeta = Omit<ArkEnv.meta, \"onFail\">;\ndeclare namespace TypeMeta {\n    type Collapsible<meta extends TypeMeta = TypeMeta> = meta | string;\n    type Mapper<meta extends TypeMeta = TypeMeta> = (existing: Readonly<meta>) => meta;\n    type MappableInput<meta extends TypeMeta = TypeMeta> = Collapsible<meta> | Mapper<meta>;\n    namespace MappableInput {\n        type Internal = MappableInput<ArkEnv.meta>;\n    }\n}\ninterface BaseNormalizedSchema extends withMetaPrefixedKeys<TypeMeta> {\n    readonly meta?: ArkEnv.meta | string;\n}\ninterface DeclarationInput {\n    kind: NodeKind;\n    schema: unknown;\n    normalizedSchema: BaseNormalizedSchema;\n    inner: object;\n    errorContext?: BaseErrorContext;\n    reducibleTo?: NodeKind;\n    intersectionIsOpen?: true;\n    prerequisite?: unknown;\n    childKind?: NodeKind;\n}\ninterface BaseErrorContext<kind extends NodeKind = NodeKind> {\n    readonly description?: string;\n    readonly code: kind;\n    readonly meta: NodeMeta;\n}\ntype defaultErrorContext<d extends DeclarationInput> = show<BaseErrorContext<d[\"kind\"]> & d[\"inner\"]>;\ntype declareNode<d extends {\n    [k in keyof d]: k extends keyof DeclarationInput ? DeclarationInput[k] : never;\n} & DeclarationInput> = merge<{\n    intersectionIsOpen: false;\n    prerequisite: prerequisiteOf<d>;\n    childKind: never;\n    reducibleTo: d[\"kind\"];\n    errorContext: null;\n}, d>;\ntype prerequisiteOf<d extends DeclarationInput> = \"prerequisite\" extends keyof d ? d[\"prerequisite\"] : unknown;\ntype attachmentsOf<d extends BaseNodeDeclaration> = NarrowedAttachments<d> & attachedInner<d>;\ntype attachedInner<d extends BaseNodeDeclaration> = \"intersection\" & d[\"kind\"] extends never ? d[\"inner\"] : {};\ninterface BaseNodeDeclaration {\n    kind: NodeKind;\n    schema: unknown;\n    normalizedSchema: BaseNormalizedSchema;\n    inner: {};\n    reducibleTo: NodeKind;\n    prerequisite: any;\n    intersectionIsOpen: boolean;\n    childKind: NodeKind;\n    errorContext: BaseErrorContext | null;\n}\ntype ownIntersectionResult<d extends BaseNodeDeclaration> = nodeOfKind<reducibleKindOf<d[\"kind\"]>> | Disjoint;\n\ndeclare class DivisorNode extends InternalPrimitiveConstraint<Divisor.Declaration> {\n    traverseAllows: TraverseAllows<number>;\n    readonly compiledCondition: string;\n    readonly compiledNegation: string;\n    readonly impliedBasis: BaseRoot;\n    readonly expression: string;\n    reduceJsonSchema(schema: JsonSchema.Numeric): JsonSchema.Numeric;\n}\ndeclare namespace Divisor {\n    interface Inner {\n        readonly rule: number;\n    }\n    interface NormalizedSchema extends BaseNormalizedSchema {\n        readonly rule: number;\n    }\n    type Schema = NormalizedSchema | number;\n    interface ErrorContext extends BaseErrorContext<\"divisor\">, Inner {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"divisor\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        prerequisite: number;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = DivisorNode;\n}\ndeclare const Divisor: {\n    implementation: nodeImplementationOf<Divisor.Declaration>;\n    Node: typeof DivisorNode;\n};\ndeclare const writeIndivisibleMessage: (t: BaseRoot) => string;\ntype writeIndivisibleMessage<actual> = writeInvalidOperandMessage<\"divisor\", actual>;\ndeclare const writeNonIntegerDivisorMessage: <divisor extends number>(divisor: divisor) => writeNonIntegerDivisorMessage<divisor>;\ntype writeNonIntegerDivisorMessage<divisor extends number> = `divisor must be an integer (was ${divisor})`;\n\ndeclare class PatternNode extends InternalPrimitiveConstraint<Pattern.Declaration> {\n    readonly instance: RegExp;\n    readonly expression: string;\n    traverseAllows: (string: string) => boolean;\n    readonly compiledCondition: string;\n    readonly compiledNegation: string;\n    readonly impliedBasis: BaseRoot;\n    reduceJsonSchema(base: JsonSchema.String, ctx: ToJsonSchema.Context): JsonSchema.String;\n}\ndeclare namespace Pattern {\n    interface NormalizedSchema extends BaseNormalizedSchema {\n        readonly rule: string;\n        readonly flags?: string;\n    }\n    interface Inner {\n        readonly rule: string;\n        readonly flags?: string;\n    }\n    type Schema = NormalizedSchema | string | RegExp;\n    interface ErrorContext extends BaseErrorContext<\"pattern\">, Inner {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"pattern\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        intersectionIsOpen: true;\n        prerequisite: string;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = PatternNode;\n}\ndeclare const Pattern: {\n    implementation: nodeImplementationOf<Pattern.Declaration>;\n    Node: typeof PatternNode;\n};\n\ndeclare class UnitNode extends InternalBasis<Unit.Declaration> {\n    compiledValue: JsonPrimitive;\n    serializedValue: string;\n    compiledCondition: string;\n    compiledNegation: string;\n    expression: string;\n    domain: Domain$1;\n    get defaultShortDescription(): string;\n    protected innerToJsonSchema(ctx: ToJsonSchema.Context): JsonSchema;\n    traverseAllows: TraverseAllows;\n}\ndeclare namespace Unit {\n    interface Schema<value = unknown> extends BaseNormalizedSchema {\n        readonly unit: value;\n    }\n    interface Inner<value = unknown> {\n        readonly unit: value;\n    }\n    interface ErrorContext<value = unknown> extends BaseErrorContext<\"unit\">, Inner<value> {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"unit\";\n        schema: Schema;\n        normalizedSchema: Schema;\n        inner: Inner;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = UnitNode;\n}\ndeclare const Unit: {\n    implementation: nodeImplementationOf<Unit.Declaration>;\n    Node: typeof UnitNode;\n};\n\ndeclare class UnionNode extends BaseRoot<Union.Declaration> {\n    isBoolean: boolean;\n    get branchGroups(): BaseRoot[];\n    unitBranches: (MorphNode | UnitNode)[];\n    discriminant: Discriminant<DiscriminantKind> | null;\n    discriminantJson: JsonStructure | null;\n    expression: string;\n    createBranchedOptimisticRootApply(): BaseNode[\"rootApply\"];\n    get shallowMorphs(): array<Morph>;\n    get defaultShortDescription(): string;\n    protected innerToJsonSchema(ctx: ToJsonSchema.Context): JsonSchema;\n    traverseAllows: TraverseAllows;\n    traverseApply: TraverseApply;\n    traverseOptimistic: (data: unknown) => unknown;\n    compile(js: NodeCompiler): void;\n    private compileIndiscriminable;\n    get nestableExpression(): string;\n    discriminate(): Discriminant | null;\n}\ndeclare namespace Union {\n    type ChildKind = UnionChildKind;\n    type ChildSchema = NodeSchema<ChildKind>;\n    type ChildNode = nodeOfKind<ChildKind>;\n    type Schema = NormalizedSchema | readonly RootSchema[];\n    interface NormalizedSchema extends BaseNormalizedSchema {\n        readonly branches: array<RootSchema>;\n        readonly ordered?: true;\n    }\n    interface Inner {\n        readonly branches: readonly ChildNode[];\n        readonly ordered?: true;\n    }\n    interface ErrorContext extends BaseErrorContext<\"union\"> {\n        errors: readonly ArkError[];\n    }\n    interface Declaration extends declareNode<{\n        kind: \"union\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        errorContext: ErrorContext;\n        reducibleTo: RootKind;\n        childKind: UnionChildKind;\n    }> {\n    }\n    type Node = UnionNode;\n}\ndeclare const Union: {\n    implementation: nodeImplementationOf<Union.Declaration>;\n    Node: typeof UnionNode;\n};\ntype DescribeBranchesOptions = {\n    delimiter?: string;\n    finalDelimiter?: string;\n};\ndeclare const describeBranches: (descriptions: string[], opts?: DescribeBranchesOptions) => string;\ndeclare const intersectBranches: (l: readonly Union.ChildNode[], r: readonly Union.ChildNode[], ctx: IntersectionContext) => readonly Union.ChildNode[] | Disjoint;\ndeclare const reduceBranches: ({ branches, ordered }: Union.Inner) => readonly Union.ChildNode[];\ntype CaseKey<kind extends DiscriminantKind = DiscriminantKind> = DiscriminantKind extends kind ? string : DiscriminantKinds[kind] | \"default\";\ntype DiscriminantLocation<kind extends DiscriminantKind = DiscriminantKind> = {\n    path: PropertyKey[];\n    optionallyChainedPropString: string;\n    kind: kind;\n};\ninterface Discriminant<kind extends DiscriminantKind = DiscriminantKind> extends DiscriminantLocation<kind> {\n    cases: DiscriminatedCases<kind>;\n}\ntype CaseContext = {\n    branchIndices: number[];\n    condition: nodeOfKind<DiscriminantKind> | Domain.Enumerable;\n};\ntype CaseDiscriminant = nodeOfKind<DiscriminantKind> | Domain.Enumerable;\ntype DiscriminatedCases<kind extends DiscriminantKind = DiscriminantKind> = {\n    [caseKey in CaseKey<kind>]: BaseRoot | true;\n};\ntype DiscriminantKinds = {\n    domain: Domain;\n    unit: SerializedPrimitive | RegisteredReference;\n};\ntype DiscriminantKind = show<keyof DiscriminantKinds>;\ndeclare const pruneDiscriminant: (discriminantBranch: BaseRoot, discriminantCtx: DiscriminantLocation) => BaseRoot | null;\ndeclare const writeIndiscriminableMorphMessage: (lDescription: string, rDescription: string) => string;\ndeclare const writeOrderedIntersectionMessage: (lDescription: string, rDescription: string) => string;\n\ninterface InternalRootDeclaration extends BaseNodeDeclaration {\n    kind: RootKind;\n}\ndeclare abstract class BaseRoot<\n/** @ts-ignore cast variance */\nout d extends InternalRootDeclaration = InternalRootDeclaration> extends BaseNode<d> implements StandardSchemaV1 {\n    readonly [arkKind]: \"root\";\n    readonly [inferred]: unknown;\n    constructor(attachments: UnknownAttachments, $: BaseScope);\n    get rawIn(): BaseRoot;\n    get rawOut(): BaseRoot;\n    get internal(): this;\n    get \"~standard\"(): StandardSchemaV1.ArkTypeProps;\n    as(): this;\n    brand(name: string): this;\n    readonly(): this;\n    readonly branches: readonly nodeOfKind<Union.ChildKind>[];\n    distribute<mapOut, reduceOut = mapOut[]>(mapBranch: (branch: nodeOfKind<Union.ChildKind>, i: number, branches: array<nodeOfKind<Union.ChildKind>>) => mapOut, reduceMapped?: (mappedBranches: mapOut[]) => reduceOut): reduceOut;\n    abstract get defaultShortDescription(): string;\n    get shortDescription(): string;\n    toJsonSchema(opts?: ToJsonSchema.Options): JsonSchema;\n    toJsonSchemaRecurse(ctx: ToJsonSchema.Context): JsonSchema;\n    get alwaysExpandJsonSchema(): boolean;\n    protected toResolvedJsonSchema(ctx: ToJsonSchema.Context): JsonSchema;\n    protected abstract innerToJsonSchema(ctx: ToJsonSchema.Context): JsonSchema;\n    intersect(r: unknown): BaseRoot | Disjoint;\n    rawIntersect(r: BaseRoot): BaseRoot;\n    toNeverIfDisjoint(): BaseRoot;\n    and(r: unknown): BaseRoot;\n    rawAnd(r: BaseRoot): BaseRoot;\n    or(r: unknown): BaseRoot;\n    rawOr(r: BaseRoot): BaseRoot;\n    map(flatMapEntry: PropFlatMapper): BaseRoot;\n    pick(...keys: KeyOrKeyNode[]): BaseRoot;\n    omit(...keys: KeyOrKeyNode[]): BaseRoot;\n    required(): BaseRoot;\n    partial(): BaseRoot;\n    private _keyof?;\n    keyof(): BaseRoot;\n    get props(): Prop.Node[];\n    merge(r: unknown): BaseRoot;\n    private applyStructuralOperation;\n    get(...path: GettableKeyOrNode[]): BaseRoot;\n    extract(r: unknown): BaseRoot;\n    exclude(r: unknown): BaseRoot;\n    array(): BaseRoot;\n    overlaps(r: unknown): boolean;\n    extends(r: unknown): boolean;\n    ifExtends(r: unknown): BaseRoot | undefined;\n    subsumes(r: unknown): boolean;\n    configure(meta: TypeMeta.MappableInput, selector?: NodeSelector): this;\n    describe(description: string, selector?: NodeSelector): this;\n    optional(): [this, \"?\"];\n    default(thunkableValue: unknown): [this, \"=\", unknown];\n    from(input: unknown): unknown;\n    protected _pipe(...morphs: Morph[]): BaseRoot;\n    protected tryPipe(...morphs: Morph[]): BaseRoot;\n    pipe: ((...morphs: Morph[]) => BaseRoot) & {\n        try: (...morphs: Morph[]) => BaseRoot;\n    };\n    to(def: unknown): BaseRoot;\n    private toNode;\n    rawPipeOnce(morph: Morph): BaseRoot;\n    narrow(predicate: Predicate): BaseRoot;\n    constrain<kind extends Constraint.PrimitiveKind>(kind: kind, schema: NodeSchema<kind>): BaseRoot;\n    constrainIn<kind extends Constraint.PrimitiveKind>(kind: kind, schema: NodeSchema<kind>): BaseRoot;\n    constrainOut<kind extends Constraint.PrimitiveKind>(kind: kind, schema: NodeSchema<kind>): BaseRoot;\n    private _constrain;\n    onUndeclaredKey(cfg: UndeclaredKeyBehavior | UndeclaredKeyConfig): BaseRoot;\n    hasEqualMorphs(r: BaseRoot): boolean;\n    onDeepUndeclaredKey(behavior: UndeclaredKeyBehavior): BaseRoot;\n    filter(predicate: Predicate): BaseRoot;\n    divisibleBy(schema: Divisor.Schema): BaseRoot;\n    matching(schema: Pattern.Schema): BaseRoot;\n    atLeast(schema: InclusiveNumericRangeSchema): BaseRoot;\n    atMost(schema: InclusiveNumericRangeSchema): BaseRoot;\n    moreThan(schema: ExclusiveNumericRangeSchema): BaseRoot;\n    lessThan(schema: ExclusiveNumericRangeSchema): BaseRoot;\n    atLeastLength(schema: InclusiveNumericRangeSchema): BaseRoot;\n    atMostLength(schema: InclusiveNumericRangeSchema): BaseRoot;\n    moreThanLength(schema: ExclusiveNumericRangeSchema): BaseRoot;\n    lessThanLength(schema: ExclusiveNumericRangeSchema): BaseRoot;\n    exactlyLength(schema: ExactLength.Schema): BaseRoot;\n    atOrAfter(schema: InclusiveDateRangeSchema): BaseRoot;\n    atOrBefore(schema: InclusiveDateRangeSchema): BaseRoot;\n    laterThan(schema: ExclusiveDateRangeSchema): BaseRoot;\n    earlierThan(schema: ExclusiveDateRangeSchema): BaseRoot;\n}\ntype UndeclaredKeyConfig = {\n    rule: UndeclaredKeyBehavior;\n    deep?: boolean;\n};\ndeclare const emptyBrandNameMessage = \"Expected a non-empty brand name after #\";\ntype emptyBrandNameMessage = typeof emptyBrandNameMessage;\ndeclare const exclusivizeRangeSchema: <schema extends UnknownRangeSchema>(schema: schema) => schema;\ntype exclusivizeRangeSchema<schema extends UnknownRangeSchema> = schema extends LimitSchemaValue ? {\n    rule: schema;\n    exclusive: true;\n} : schema;\ndeclare const typeOrTermExtends: (t: unknown, base: unknown) => boolean;\ntype intersectRoot<l extends RootKind, r extends NodeKind> = [\n    l,\n    r\n] extends [r, l] ? l : asymmetricIntersectionOf<l, r> | asymmetricIntersectionOf<r, l>;\ntype asymmetricIntersectionOf<l extends NodeKind, r extends NodeKind> = l extends unknown ? r extends kindRightOf<l> ? l | reducibleKindOf<l> : never : never;\ntype schemaKindRightOf<kind extends RootKind> = Extract<kindRightOf<kind>, RootKind>;\ntype schemaKindOrRightOf<kind extends RootKind> = kind | schemaKindRightOf<kind>;\ntype StructuralOperationBranchResultByName = {\n    keyof: Union.ChildNode;\n    pick: Union.ChildNode;\n    omit: Union.ChildNode;\n    get: Union.ChildNode;\n    map: Union.ChildNode;\n    required: Union.ChildNode;\n    partial: Union.ChildNode;\n    merge: Union.ChildNode;\n    props: array<Prop.Node>;\n};\ntype StructuralOperationName = keyof StructuralOperationBranchResultByName;\ndeclare const writeLiteralUnionEntriesMessage: (expression: string) => string;\ndeclare const writeNonStructuralOperandMessage: <operation extends StructuralOperationName, operand extends string>(operation: operation, operand: operand) => writeNonStructuralOperandMessage<operation, operand>;\ntype writeNonStructuralOperandMessage<operation extends StructuralOperationName, operand extends string> = `${operation} operand must be an object (was ${operand})`;\n\ndeclare class MorphNode extends BaseRoot<Morph.Declaration> {\n    serializedMorphs: string[];\n    compiledMorphs: string;\n    lastMorph: BaseRoot<InternalRootDeclaration> | Morph<any, unknown> | undefined;\n    lastMorphIfNode: BaseRoot | undefined;\n    introspectableIn: BaseRoot | undefined;\n    introspectableOut: BaseRoot | undefined;\n    get shallowMorphs(): array<Morph>;\n    get rawIn(): BaseRoot;\n    get rawOut(): BaseRoot;\n    declareIn(declaredIn: BaseRoot): MorphNode;\n    declareOut(declaredOut: BaseRoot): MorphNode;\n    expression: string;\n    get defaultShortDescription(): string;\n    protected innerToJsonSchema(ctx: ToJsonSchema.Context): JsonSchema;\n    compile(js: NodeCompiler): void;\n    traverseAllows: TraverseAllows;\n    traverseApply: TraverseApply;\n    /** Check if the morphs of r are equal to those of this node */\n    hasEqualMorphs(r: MorphNode): boolean;\n}\ndeclare namespace Morph {\n    interface Inner {\n        readonly in?: BaseRoot;\n        readonly morphs: array<Morph | BaseRoot>;\n        readonly declaredIn?: BaseRoot;\n        readonly declaredOut?: BaseRoot;\n    }\n    interface Schema extends BaseNormalizedSchema {\n        readonly in?: RootSchema;\n        readonly morphs: listable<Morph | BaseRoot>;\n        readonly declaredIn?: BaseRoot;\n        readonly declaredOut?: BaseRoot;\n    }\n    interface Declaration extends declareNode<{\n        kind: \"morph\";\n        schema: Schema;\n        normalizedSchema: Schema;\n        inner: Inner;\n        childKind: RootKind;\n    }> {\n    }\n    type Node = MorphNode;\n    type In<morph extends Morph> = morph extends Morph<infer i> ? i : never;\n    type Out<morph extends Morph> = morph extends Morph<never, infer o> ? o : never;\n    type ContextFree<i = any, o = unknown> = (In: i) => o;\n}\ntype Morph<i = any, o = unknown> = (In: i, ctx: Traversal) => o;\ndeclare const Morph: {\n    implementation: nodeImplementationOf<Morph.Declaration>;\n    Node: typeof MorphNode;\n};\ndeclare const writeMorphIntersectionMessage: (lDescription: string, rDescription: string) => string;\n\ntype MorphsAtPath = {\n    path: ReadonlyPath;\n    morphs: array<Morph>;\n};\ntype BranchTraversal = {\n    error: ArkError | undefined;\n    queuedMorphs: MorphsAtPath[];\n};\ntype InternalTraversal = Omit<Traversal, \"error\" | \"mustBe\" | \"reject\">;\ndeclare class Traversal {\n    /**\n     * #### the path being validated or morphed\n     *\n     * âœ… array indices represented as numbers\n     * âš ï¸ mutated during traversal - use `path.slice(0)` to snapshot\n     * ðŸ”— use {@link propString} for a stringified version\n     */\n    path: PropertyKey[];\n    /**\n     * #### {@link ArkErrors} that will be part of this traversal's finalized result\n     *\n     * âœ… will always be an empty array for a valid traversal\n     */\n    errors: ArkErrors;\n    /**\n     * #### the original value being traversed\n     */\n    root: unknown;\n    /**\n     * #### configuration for this traversal\n     *\n     * âœ… options can affect traversal results and error messages\n     * âœ… defaults < global config < scope config\n     * âœ… does not include options configured on individual types\n     */\n    config: ResolvedConfig;\n    queuedMorphs: MorphsAtPath[];\n    branches: BranchTraversal[];\n    seen: {\n        [id in string]?: unknown[];\n    };\n    constructor(root: unknown, config: ResolvedConfig);\n    /**\n     * #### the data being validated or morphed\n     *\n     * âœ… extracted from {@link root} at {@link path}\n     */\n    get data(): unknown;\n    /**\n     * #### a string representing {@link path}\n     *\n     * @propString\n     */\n    get propString(): string;\n    /**\n     * #### add an {@link ArkError} and return `false`\n     *\n     * âœ… useful for predicates like `.narrow`\n     */\n    reject(input: ArkErrorInput): false;\n    /**\n     * #### add an {@link ArkError} from a description and return `false`\n     *\n     * âœ… useful for predicates like `.narrow`\n     * ðŸ”— equivalent to {@link reject}({ expected })\n     */\n    mustBe(expected: string): false;\n    /**\n     * #### add and return an {@link ArkError}\n     *\n     * âœ… useful for morphs like `.pipe`\n     */\n    error<input extends ArkErrorInput>(input: input): ArkError<input extends {\n        code: ArkErrorCode;\n    } ? input[\"code\"] : \"predicate\">;\n    /**\n     * #### whether {@link currentBranch} (or the traversal root, outside a union) has one or more errors\n     */\n    hasError(): boolean;\n    get currentBranch(): BranchTraversal | undefined;\n    queueMorphs(morphs: array<Morph>): void;\n    finalize(onFail?: ArkErrors.Handler | null): unknown;\n    get currentErrorCount(): number;\n    get failFast(): boolean;\n    pushBranch(): void;\n    popBranch(): BranchTraversal | undefined;\n    private errorFromContext;\n    private applyQueuedMorphs;\n    private applyMorphsAtPath;\n}\ndeclare const traverseKey: <result>(key: PropertyKey, fn: () => result, ctx: InternalTraversal | undefined) => result;\ntype TraversalMethodsByKind<input = unknown> = {\n    Allows: TraverseAllows<input>;\n    Apply: TraverseApply<input>;\n};\ntype TraversalKind = keyof TraversalMethodsByKind;\ntype TraverseAllows<data = unknown> = (data: data, ctx: InternalTraversal) => boolean;\ntype TraverseApply<data = unknown> = (data: data, ctx: InternalTraversal) => void;\n\ntype CoercibleValue = string | number | boolean | null | undefined;\ndeclare class CompiledFunction<compiledSignature = (...args: unknown[]) => unknown, args extends readonly string[] = readonly string[]> extends CastableBase<{\n    [k in args[number]]: k;\n}> {\n    readonly argNames: args;\n    readonly body = \"\";\n    constructor(...args: args);\n    indentation: number;\n    indent(): this;\n    dedent(): this;\n    prop(key: PropertyKey, optional?: boolean): string;\n    index(key: string | number, optional?: boolean): string;\n    line(statement: string): this;\n    const(identifier: string, expression: CoercibleValue): this;\n    let(identifier: string, expression: CoercibleValue): this;\n    set(identifier: string, expression: CoercibleValue): this;\n    if(condition: string, then: (self: this) => this): this;\n    elseIf(condition: string, then: (self: this) => this): this;\n    else(then: (self: this) => this): this;\n    /** Current index is \"i\" */\n    for(until: string, body: (self: this) => this, initialValue?: CoercibleValue): this;\n    /** Current key is \"k\" */\n    forIn(object: string, body: (self: this) => this): this;\n    block(prefix: string, contents: (self: this) => this, suffix?: string): this;\n    return(expression?: CoercibleValue): this;\n    write(name?: string, indent?: number): string;\n    compile(): compiledSignature;\n}\ndeclare const compileSerializedValue: (value: unknown) => string;\ndeclare const compileLiteralPropAccess: (key: PropertyKey, optional?: boolean) => string;\ndeclare const serializeLiteralKey: (key: PropertyKey) => string;\ndeclare const indexPropAccess: (key: string, optional?: boolean) => string;\ninterface InvokeOptions extends ReferenceOptions {\n    arg?: string;\n}\ninterface ReferenceOptions {\n    kind?: TraversalKind;\n    bind?: string;\n}\ndeclare namespace NodeCompiler {\n    interface Context {\n        kind: TraversalKind;\n        optimistic?: true;\n    }\n}\ndeclare class NodeCompiler extends CompiledFunction<Fn, [\"data\", \"ctx\"]> {\n    traversalKind: TraversalKind;\n    optimistic: boolean;\n    constructor(ctx: NodeCompiler.Context);\n    invoke(node: BaseNode | NodeId, opts?: InvokeOptions): string;\n    referenceToId(id: NodeId, opts?: ReferenceOptions): string;\n    requiresContextFor(node: BaseNode): boolean;\n    initializeErrorCount(): this;\n    returnIfFail(): this;\n    returnIfFailFast(): this;\n    traverseKey(keyExpression: string, accessExpression: string, node: BaseNode): this;\n    check(node: BaseNode, opts?: InvokeOptions): this;\n}\n\ndeclare class PredicateNode extends BaseConstraint<Predicate.Declaration> {\n    serializedPredicate: RegisteredReference;\n    compiledCondition: string;\n    compiledNegation: string;\n    impliedBasis: null;\n    expression: string;\n    traverseAllows: TraverseAllows;\n    errorContext: Predicate.ErrorContext;\n    compiledErrorContext: string;\n    traverseApply: TraverseApply;\n    compile(js: NodeCompiler): void;\n    reduceJsonSchema(base: JsonSchema.Constrainable, ctx: ToJsonSchema.Context): JsonSchema;\n}\ndeclare namespace Predicate {\n    type Schema<predicate extends Predicate = Predicate> = NormalizedSchema<predicate> | predicate;\n    interface NormalizedSchema<predicate extends Predicate = Predicate> extends BaseNormalizedSchema {\n        readonly predicate: predicate;\n    }\n    interface Inner<predicate extends Predicate = Predicate> {\n        readonly predicate: predicate;\n    }\n    interface ErrorContext extends BaseErrorContext<\"predicate\"> {\n        readonly predicate?: Predicate;\n    }\n    interface Declaration extends declareNode<{\n        kind: \"predicate\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        intersectionIsOpen: true;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = PredicateNode;\n}\ndeclare const Predicate: {\n    implementation: nodeImplementationOf<Predicate.Declaration>;\n    Node: typeof PredicateNode;\n};\ntype Predicate<data = any> = (data: data, ctx: Traversal) => boolean;\ndeclare namespace Predicate {\n    type Casted<input = never, narrowed extends input = input> = (input: input, ctx: Traversal) => input is narrowed;\n    type Castable<input = never, narrowed extends input = input> = Predicate<input> | Casted<input, narrowed>;\n}\n\ndeclare class ProtoNode extends InternalBasis<Proto.Declaration> {\n    builtinName: BuiltinObjectKind | null;\n    serializedConstructor: string;\n    private readonly requiresInvalidDateCheck;\n    traverseAllows: TraverseAllows;\n    compiledCondition: string;\n    compiledNegation: string;\n    protected innerToJsonSchema(ctx: ToJsonSchema.Context): JsonSchema;\n    expression: string;\n    get nestableExpression(): string;\n    readonly domain = \"object\";\n    get defaultShortDescription(): string;\n}\ndeclare namespace Proto {\n    type Reference = Constructor | BuiltinObjectKind;\n    type Schema<proto extends Reference = Reference> = proto | ExpandedSchema<proto>;\n    interface NormalizedSchema<proto extends Constructor = Constructor> extends BaseNormalizedSchema {\n        readonly proto: proto;\n        readonly dateAllowsInvalid?: boolean;\n    }\n    interface ExpandedSchema<proto extends Reference = Reference> {\n        readonly proto: proto;\n        readonly dateAllowsInvalid?: boolean;\n    }\n    interface Inner<proto extends Constructor = Constructor> {\n        readonly proto: proto;\n        readonly dateAllowsInvalid?: boolean;\n    }\n    interface ErrorContext extends BaseErrorContext<\"proto\">, Inner {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"proto\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = ProtoNode;\n}\ndeclare const Proto: {\n    implementation: nodeImplementationOf<Proto.Declaration>;\n    Node: typeof ProtoNode;\n    writeBadInvalidDateMessage: (actual: Constructor) => string;\n    writeInvalidSchemaMessage: (actual: unknown) => string;\n};\n\ndeclare class IntersectionNode extends BaseRoot<Intersection.Declaration> {\n    basis: nodeOfKind<Intersection.BasisKind> | null;\n    refinements: array<nodeOfKind<RefinementKind>>;\n    structure: Structure.Node | undefined;\n    expression: string;\n    get shallowMorphs(): array<Morph>;\n    get defaultShortDescription(): string;\n    protected innerToJsonSchema(ctx: ToJsonSchema.Context): JsonSchema;\n    traverseAllows: TraverseAllows;\n    traverseApply: TraverseApply;\n    compile(js: NodeCompiler): void;\n}\ndeclare namespace Intersection {\n    type BasisKind = \"domain\" | \"proto\";\n    type ChildKind = BasisKind | RefinementKind | \"predicate\" | \"structure\";\n    type FlattenedChildKind = ChildKind | StructuralKind;\n    type RefinementsInner = {\n        [k in RefinementKind]?: intersectionChildInnerValueOf<k>;\n    };\n    interface Inner extends RefinementsInner {\n        domain?: Domain.Node;\n        proto?: Proto.Node;\n        structure?: Structure.Node;\n        predicate?: array<PredicateNode>;\n    }\n    namespace Inner {\n        type mutable = makeRootAndArrayPropertiesMutable<Inner>;\n    }\n    type ConstraintsSchema<inferredBasis = any> = show<BaseNormalizedSchema & {\n        domain?: Domain.Schema;\n        proto?: Proto.Schema;\n    } & conditionalRootOf<inferredBasis>>;\n    type NormalizedSchema = Omit<ConstraintsSchema, StructuralKind | \"undeclared\">;\n    type Schema<inferredBasis = any> = ConstraintsSchema<inferredBasis>;\n    interface AstSchema extends BaseNormalizedSchema {\n        intersection: readonly RootSchema[];\n    }\n    interface ErrorContext extends BaseErrorContext<\"intersection\">, Inner {\n        errors: readonly ArkError[];\n    }\n    type Declaration = declareNode<{\n        kind: \"intersection\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        reducibleTo: \"intersection\" | BasisKind;\n        errorContext: ErrorContext;\n        childKind: ChildKind;\n    }>;\n    type Node = IntersectionNode;\n}\ndeclare const Intersection: {\n    implementation: nodeImplementationOf<{\n        intersectionIsOpen: false;\n        prerequisite: unknown;\n        kind: \"intersection\";\n        schema: Intersection.Schema;\n        normalizedSchema: Intersection.NormalizedSchema;\n        inner: Intersection.Inner;\n        reducibleTo: \"intersection\" | Intersection.BasisKind;\n        errorContext: Intersection.ErrorContext;\n        childKind: Intersection.ChildKind;\n    }>;\n    Node: typeof IntersectionNode;\n};\ntype ConditionalTerminalIntersectionRoot = {\n    undeclared?: UndeclaredKeyBehavior;\n};\ntype ConditionalTerminalIntersectionKey = keyof ConditionalTerminalIntersectionRoot;\ntype ConditionalIntersectionKey = ConstraintKind | ConditionalTerminalIntersectionKey;\ntype constraintKindOf<t> = {\n    [k in ConstraintKind]: t extends Prerequisite<k> ? k : never;\n}[ConstraintKind];\ntype conditionalIntersectionKeyOf<t> = constraintKindOf<t> | (t extends object ? \"undeclared\" : never);\ntype intersectionChildSchemaValueOf<k extends Intersection.FlattenedChildKind> = k extends OpenNodeKind ? listable<NodeSchema<k>> : NodeSchema<k>;\ntype conditionalSchemaValueOfKey<k extends ConditionalIntersectionKey> = k extends Intersection.FlattenedChildKind ? intersectionChildSchemaValueOf<k> : ConditionalTerminalIntersectionRoot[k & ConditionalTerminalIntersectionKey];\ntype intersectionChildInnerValueOf<k extends Intersection.FlattenedChildKind> = k extends OpenNodeKind ? readonly nodeOfKind<k>[] : nodeOfKind<k>;\ntype conditionalRootOf<t> = {\n    [k in conditionalIntersectionKeyOf<t>]?: conditionalSchemaValueOfKey<k>;\n};\n\ndeclare namespace Constraint {\n    interface Declaration extends BaseNodeDeclaration {\n        kind: ConstraintKind;\n    }\n    type ReductionResult = BaseRoot | Disjoint | Intersection.Inner.mutable;\n    interface Attachments {\n        impliedBasis: BaseRoot | null;\n        impliedSiblings?: array<BaseConstraint> | null;\n    }\n    type PrimitiveKind = Exclude<ConstraintKind, StructuralKind>;\n}\ndeclare abstract class BaseConstraint<\n/** @ts-ignore allow instantiation assignment to the base type */\nout d extends Constraint.Declaration = Constraint.Declaration> extends BaseNode<d> {\n    readonly [arkKind]: \"constraint\";\n    constructor(attachments: UnknownAttachments, $: BaseScope);\n    abstract readonly impliedBasis: BaseRoot | null;\n    readonly impliedSiblings?: array<BaseConstraint>;\n    intersect<r extends BaseConstraint>(r: r): intersectConstraintKinds<d[\"kind\"], r[\"kind\"]>;\n}\ndeclare abstract class InternalPrimitiveConstraint<d extends Constraint.Declaration> extends BaseConstraint<d> {\n    abstract traverseAllows: TraverseAllows<d[\"prerequisite\"]>;\n    abstract readonly compiledCondition: string;\n    abstract readonly compiledNegation: string;\n    abstract reduceJsonSchema(base: JsonSchema.Constrainable, ctx: ToJsonSchema.Context): JsonSchema.Constrainable;\n    traverseApply: TraverseApply<d[\"prerequisite\"]>;\n    compile(js: NodeCompiler): void;\n    get errorContext(): d[\"errorContext\"];\n    get compiledErrorContext(): string;\n}\ndeclare const constraintKeyParser: <kind extends ConstraintKind>(kind: kind) => (schema: listable<NodeSchema<kind>>, ctx: NodeParseContext) => innerAttachedAs<kind> | undefined;\ntype ConstraintGroupKind = satisfy<NodeKind, \"intersection\" | \"structure\">;\ninterface ConstraintIntersectionState<kind extends ConstraintGroupKind = ConstraintGroupKind> {\n    kind: kind;\n    baseInner: Record<string, unknown>;\n    l: BaseConstraint[];\n    r: BaseConstraint[];\n    roots: BaseRoot[];\n    ctx: IntersectionContext;\n}\ndeclare const intersectConstraints: <kind extends ConstraintGroupKind>(s: ConstraintIntersectionState<kind>) => nodeOfKind<RootKind | Extract<kind, \"structure\">> | Disjoint;\ndeclare const flattenConstraints: (inner: object) => BaseConstraint[];\ntype FlatIntersectionInner = Intersection.Inner & Structure.Inner;\ndeclare const unflattenConstraints: (constraints: array<BaseConstraint>) => FlatIntersectionInner;\ntype constraintKindLeftOf<kind extends ConstraintKind> = ConstraintKind & kindLeftOf<kind>;\ntype constraintKindOrLeftOf<kind extends ConstraintKind> = kind | constraintKindLeftOf<kind>;\ntype intersectConstraintKinds<l extends ConstraintKind, r extends ConstraintKind> = nodeOfKind<l | r | \"unit\" | \"union\"> | Disjoint | null;\ndeclare const throwInvalidOperandError: (...args: Parameters<typeof writeInvalidOperandMessage>) => never;\ndeclare const writeInvalidOperandMessage: <kind extends ConstraintKind, expected extends BaseRoot, actual extends BaseRoot>(kind: kind, expected: expected, actual: actual) => string;\ntype writeInvalidOperandMessage<kind extends ConstraintKind, actual> = `${Capitalize<kind>} operand must be ${describe<Prerequisite<kind>>} (was ${describe<Exclude<actual, Prerequisite<kind>>>})`;\n\ndeclare abstract class BaseNode<\n/** @ts-ignore allow instantiation assignment to the base type */\nout d extends BaseNodeDeclaration = BaseNodeDeclaration> extends Callable<(data: d[\"prerequisite\"], ctx?: Traversal, onFail?: ArkErrors.Handler | null) => unknown, attachmentsOf<d>> {\n    attachments: UnknownAttachments;\n    $: BaseScope;\n    onFail: ArkErrors.Handler | null;\n    includesTransform: boolean;\n    includesContextualPredicate: boolean;\n    isCyclic: boolean;\n    allowsRequiresContext: boolean;\n    rootApplyStrategy: \"allows\" | \"contextual\" | \"optimistic\" | \"branchedOptimistic\";\n    contextFreeMorph: ((data: unknown) => unknown) | undefined;\n    rootApply: (data: unknown, onFail: ArkErrors.Handler | null) => unknown;\n    referencesById: Record<string, BaseNode>;\n    shallowReferences: BaseNode[];\n    flatRefs: FlatRef[];\n    flatMorphs: FlatRef<Morph.Node | Intersection.Node>[];\n    allows: (data: d[\"prerequisite\"]) => boolean;\n    get shallowMorphs(): array<Morph>;\n    constructor(attachments: UnknownAttachments, $: BaseScope);\n    protected createRootApply(): this[\"rootApply\"];\n    abstract traverseAllows: TraverseAllows<d[\"prerequisite\"]>;\n    abstract traverseApply: TraverseApply<d[\"prerequisite\"]>;\n    abstract expression: string;\n    abstract compile(js: NodeCompiler): void;\n    readonly compiledMeta: string;\n    protected cacheGetter<name extends keyof this>(name: name, value: this[name]): this[name];\n    get description(): string;\n    get references(): BaseNode[];\n    readonly precedence: number;\n    precompilation: string | undefined;\n    assert: (data: d[\"prerequisite\"], pipedFromCtx?: Traversal) => unknown;\n    traverse(data: d[\"prerequisite\"], pipedFromCtx?: Traversal): ArkErrors | {} | null | undefined;\n    /** rawIn should be used internally instead */\n    get in(): unknown;\n    get rawIn(): BaseNode;\n    /** rawOut should be used internally instead */\n    get out(): unknown;\n    get rawOut(): BaseNode;\n    getIo(ioKind: \"in\" | \"out\"): BaseNode;\n    toJSON(): JsonStructure;\n    toString(): string;\n    equals(r: unknown): boolean;\n    ifEquals(r: unknown): BaseNode | undefined;\n    hasKind<kind extends NodeKind>(kind: kind): this is nodeOfKind<kind>;\n    assertHasKind<kind extends NodeKind>(kind: kind): nodeOfKind<kind>;\n    hasKindIn<kinds extends NodeKind[]>(...kinds: kinds): this is nodeOfKind<kinds[number]>;\n    assertHasKindIn<kinds extends NodeKind[]>(...kinds: kinds): nodeOfKind<kinds[number]>;\n    isBasis(): this is nodeOfKind<BasisKind>;\n    isConstraint(): this is BaseConstraint;\n    isStructural(): this is nodeOfKind<StructuralKind>;\n    isRefinement(): this is nodeOfKind<RefinementKind>;\n    isRoot(): this is BaseRoot;\n    isUnknown(): boolean;\n    isNever(): boolean;\n    hasUnit<value>(value: unknown): this is Unit.Node & {\n        unit: value;\n    };\n    hasOpenIntersection(): this is nodeOfKind<OpenNodeKind>;\n    get nestableExpression(): string;\n    select<const selector extends NodeSelector.CompositeInput, predicate extends GuardablePredicate<NodeSelector.inferSelectKind<d[\"kind\"], selector>>>(selector: NodeSelector.validateComposite<selector, predicate>): NodeSelector.infer<d[\"kind\"], selector>;\n    select<const selector extends NodeSelector.Single>(selector: selector): NodeSelector.infer<d[\"kind\"], selector>;\n    private _select;\n    transform<mapper extends DeepNodeTransformation>(mapper: mapper, opts?: DeepNodeTransformOptions): nodeOfKind<reducibleKindOf<this[\"kind\"]>> | Extract<ReturnType<mapper>, null>;\n    protected _createTransformContext(opts: DeepNodeTransformOptions | undefined): DeepNodeTransformContext;\n    protected _transform(mapper: DeepNodeTransformation, ctx: DeepNodeTransformContext): BaseNode | null;\n    configureReferences(meta: TypeMeta.MappableInput.Internal, selector?: NodeSelector): this;\n}\n/** a literal key (named property) or a node (index signatures) representing part of a type structure */\ntype KeyOrKeyNode = Key | BaseRoot;\ntype GettableKeyOrNode = KeyOrKeyNode | number;\ntype FlatRef<root extends BaseRoot = BaseRoot> = {\n    path: array<KeyOrKeyNode>;\n    node: root;\n    propString: string;\n};\ntype NodeSelector = NodeSelector.Single | NodeSelector.Composite;\ndeclare namespace NodeSelector {\n    type SelectableFn<input, returns, kind extends NodeKind = NodeKind> = {\n        <const selector extends NodeSelector.CompositeInput, predicate extends GuardablePredicate<NodeSelector.inferSelectKind<kind, selector>>>(input: input, selector?: NodeSelector.validateComposite<selector, predicate>): returns;\n        <const selector extends NodeSelector.Single>(input: input, selector?: selector): returns;\n    };\n    type Single = NodeSelector.Boundary | NodeSelector.Kind | GuardablePredicate<BaseNode>;\n    type Boundary = \"self\" | \"child\" | \"shallow\" | \"references\";\n    type Kind = NodeKind;\n    type Method = \"filter\" | \"assertFilter\" | \"find\" | \"assertFind\";\n    interface Composite {\n        method?: Method;\n        boundary?: Boundary;\n        kind?: Kind;\n        where?: GuardablePredicate<BaseNode>;\n    }\n    type Normalized = requireKeys<Composite, \"method\" | \"boundary\">;\n    type CompositeInput = Omit<Composite, \"where\">;\n    type BaseResult = BaseNode | BaseNode[] | undefined;\n    type validateComposite<selector, predicate> = {\n        [k in keyof selector]: k extends \"where\" ? predicate : conform<selector[k], CompositeInput[k & keyof CompositeInput]>;\n    };\n    type infer<selfKind extends NodeKind, selector> = applyMethod<selector extends NodeSelector.WhereCastInput<any, infer narrowed> ? narrowed : NodeSelector.inferSelectKind<selfKind, selector>, selector>;\n    type BoundaryInput<b extends Boundary> = b | {\n        boundary: b;\n    };\n    type KindInput<k extends Kind> = k | {\n        kind: k;\n    };\n    type WhereCastInput<kindNode extends BaseNode, narrowed extends kindNode> = ((In: kindNode) => In is narrowed) | {\n        where: (In: kindNode) => In is narrowed;\n    };\n    type inferSelectKind<selfKind extends NodeKind, selector> = selectKind<selfKind, selector> extends infer kind extends NodeKind ? NodeKind extends kind ? BaseNode : nodeOfKind<kind> : never;\n    type selectKind<selfKind extends NodeKind, selector> = selector extends BoundaryInput<\"self\"> ? selfKind : selector extends KindInput<infer kind> ? kind : selector extends BoundaryInput<\"child\"> ? selfKind | childKindOf<selfKind> : NodeKind;\n    type applyMethod<t, selector> = selector extends {\n        method: infer method extends Method;\n    } ? method extends \"filter\" ? t[] : method extends \"assertFilter\" ? [t, ...t[]] : method extends \"find\" ? t | undefined : method extends \"assertFind\" ? t : never : t[];\n}\ndeclare const typePathToPropString: (path: array<KeyOrKeyNode>) => string;\ndeclare const flatRef: <node extends BaseRoot>(path: array<KeyOrKeyNode>, node: node) => FlatRef<node>;\ndeclare const flatRefsAreEqual: (l: FlatRef, r: FlatRef) => boolean;\ndeclare const appendUniqueFlatRefs: <node extends BaseRoot>(existing: FlatRef<node>[] | undefined, refs: listable<FlatRef<node>>) => FlatRef<node>[];\ndeclare const appendUniqueNodes: <node extends BaseNode>(existing: node[] | undefined, refs: listable<node>) => node[];\ntype DeepNodeTransformOptions = {\n    shouldTransform?: ShouldTransformFn;\n    bindScope?: BaseScope;\n    prereduced?: boolean;\n    selected?: readonly BaseNode[] | undefined;\n};\ntype ShouldTransformFn = (node: BaseNode, ctx: DeepNodeTransformContext) => boolean;\ninterface DeepNodeTransformContext extends DeepNodeTransformOptions {\n    root: BaseNode;\n    selected: readonly BaseNode[] | undefined;\n    path: mutable<array<KeyOrKeyNode>>;\n    seen: {\n        [originalId: string]: (() => BaseNode | undefined) | undefined;\n    };\n    parseOptions: BaseParseOptions;\n    undeclaredKeyHandling: UndeclaredKeyHandling | undefined;\n}\ntype DeepNodeTransformation = <kind extends NodeKind>(kind: kind, innerWithMeta: Inner<kind> & {\n    meta: NodeMeta;\n}, ctx: DeepNodeTransformContext) => NormalizedSchema<kind> | null;\n\ndeclare class AfterNode extends BaseRange<After.Declaration> {\n    impliedBasis: BaseRoot;\n    collapsibleLimitString: string;\n    traverseAllows: TraverseAllows<Date>;\n    reduceJsonSchema(base: JsonSchema, ctx: ToJsonSchema.Context): JsonSchema;\n}\ndeclare namespace After {\n    interface Inner extends BaseRangeInner {\n        rule: Date;\n    }\n    interface NormalizedSchema extends UnknownNormalizedRangeSchema {\n        rule: LimitSchemaValue;\n    }\n    interface ExpandedSchema extends UnknownExpandedRangeSchema {\n        rule: LimitSchemaValue;\n    }\n    type Schema = ExpandedSchema | LimitSchemaValue;\n    interface ErrorContext extends BaseErrorContext<\"after\">, Inner {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"after\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        prerequisite: Date;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = AfterNode;\n}\ndeclare const After: {\n    implementation: nodeImplementationOf<After.Declaration>;\n    Node: typeof AfterNode;\n};\n\ndeclare class BeforeNode extends BaseRange<Before.Declaration> {\n    collapsibleLimitString: string;\n    traverseAllows: TraverseAllows<Date>;\n    impliedBasis: BaseRoot;\n    reduceJsonSchema(base: JsonSchema, ctx: ToJsonSchema.Context): JsonSchema;\n}\ndeclare namespace Before {\n    interface Inner extends BaseRangeInner {\n        rule: Date;\n    }\n    interface NormalizedSchema extends UnknownNormalizedRangeSchema {\n        rule: LimitSchemaValue;\n    }\n    interface ExpandedSchema extends UnknownExpandedRangeSchema {\n        rule: LimitSchemaValue;\n    }\n    type Schema = ExpandedSchema | LimitSchemaValue;\n    interface ErrorContext extends BaseErrorContext<\"before\">, Inner {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"before\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        prerequisite: Date;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = BeforeNode;\n}\ndeclare const Before: {\n    implementation: nodeImplementationOf<Before.Declaration>;\n    Node: typeof BeforeNode;\n};\n\ndeclare class MaxNode extends BaseRange<Max.Declaration> {\n    impliedBasis: BaseRoot;\n    traverseAllows: TraverseAllows<number>;\n    reduceJsonSchema(schema: JsonSchema.Numeric): JsonSchema.Numeric;\n}\ndeclare namespace Max {\n    interface Inner extends BaseRangeInner {\n        rule: number;\n        exclusive?: true;\n    }\n    interface NormalizedSchema extends UnknownExpandedRangeSchema {\n        rule: number;\n    }\n    type Schema = NormalizedSchema | number;\n    interface ErrorContext extends BaseErrorContext<\"max\">, Inner {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"max\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        prerequisite: number;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = MaxNode;\n}\ndeclare const Max: {\n    implementation: nodeImplementationOf<Max.Declaration>;\n    Node: typeof MaxNode;\n};\n\ndeclare class MinNode extends BaseRange<Min.Declaration> {\n    readonly impliedBasis: BaseRoot;\n    traverseAllows: TraverseAllows<number>;\n    reduceJsonSchema(schema: JsonSchema.Numeric): JsonSchema.Numeric;\n}\ndeclare namespace Min {\n    interface Inner extends BaseRangeInner {\n        rule: number;\n        exclusive?: true;\n    }\n    interface NormalizedSchema extends UnknownExpandedRangeSchema {\n        rule: number;\n    }\n    type Schema = NormalizedSchema | number;\n    interface ErrorContext extends BaseErrorContext<\"min\">, Inner {\n    }\n    interface Declaration extends declareNode<{\n        kind: \"min\";\n        schema: Schema;\n        normalizedSchema: NormalizedSchema;\n        inner: Inner;\n        prerequisite: number;\n        errorContext: ErrorContext;\n    }> {\n    }\n    type Node = MinNode;\n}\ndeclare const Min: {\n    implementation: nodeImplementationOf<Min.Declaration>;\n    Node: typeof MinNode;\n};\n\ninterface BoundDeclarations {\n    min: Min.Declaration;\n    max: Max.Declaration;\n    minLength: MinLength.Declaration;\n    maxLength: MaxLength.Declaration;\n    exactLength: ExactLength.Declaration;\n    after: After.Declaration;\n    before: Before.Declaration;\n}\ninterface BoundNodesByKind {\n    min: Min.Node;\n    max: Max.Node;\n    minLength: MinLength.Node;\n    maxLength: MaxLength.Node;\n    exactLength: ExactLength.Node;\n    after: After.Node;\n    before: Before.Node;\n}\n\ninterface NodeDeclarationsByKind extends BoundDeclarations {\n    alias: Alias.Declaration;\n    domain: Domain.Declaration;\n    unit: Unit.Declaration;\n    proto: Proto.Declaration;\n    union: Union.Declaration;\n    morph: Morph.Declaration;\n    intersection: Intersection.Declaration;\n    sequence: Sequence.Declaration;\n    divisor: Divisor.Declaration;\n    required: Required$1.Declaration;\n    optional: Optional.Declaration;\n    index: Index.Declaration;\n    pattern: Pattern.Declaration;\n    predicate: Predicate.Declaration;\n    structure: Structure.Declaration;\n}\ndeclare const nodeImplementationsByKind: Record<NodeKind, UnknownNodeImplementation>;\ndeclare const nodeClassesByKind: Record<NodeKind, new (attachments: UnknownAttachments, $: BaseScope) => BaseNode>;\ninterface NodesByKind extends BoundNodesByKind {\n    alias: Alias.Node;\n    union: Union.Node;\n    morph: Morph.Node;\n    intersection: Intersection.Node;\n    unit: Unit.Node;\n    proto: Proto.Node;\n    domain: Domain.Node;\n    divisor: Divisor.Node;\n    pattern: Pattern.Node;\n    predicate: Predicate.Node;\n    required: Required$1.Node;\n    optional: Optional.Node;\n    index: Index.Node;\n    sequence: Sequence.Node;\n    structure: Structure.Node;\n}\ntype nodeOfKind<kind extends NodeKind> = NodesByKind[kind];\ntype Declaration<kind extends NodeKind> = NodeDeclarationsByKind[kind];\ntype NodeSchema<kind extends NodeKind> = Declaration<kind>[\"schema\"];\ntype RootSchema<kind extends RootKind = RootKind> = NodeSchema<kind>;\ntype NormalizedSchema<kind extends NodeKind> = Declaration<kind>[\"normalizedSchema\"];\ntype childKindOf<kind extends NodeKind> = Declaration<kind>[\"childKind\"];\ntype Prerequisite<kind extends NodeKind> = Declaration<kind>[\"prerequisite\"];\ntype reducibleKindOf<kind extends NodeKind> = Declaration<kind>[\"reducibleTo\"] extends NodeKind ? Declaration<kind>[\"reducibleTo\"] : kind;\ntype Inner<kind extends NodeKind> = Declaration<kind>[\"inner\"];\ntype defAttachedAs<kind extends ConstraintKind> = kind extends OpenNodeKind ? listable<NodeSchema<kind>> : NodeSchema<kind>;\ntype innerAttachedAs<kind extends ConstraintKind> = kind extends OpenNodeKind ? array<nodeOfKind<kind>> : nodeOfKind<kind>;\n/** make nested arrays mutable while keeping nested nodes immutable */\ntype mutableInnerOfKind<kind extends NodeKind> = makeRootAndArrayPropertiesMutable<Inner<kind>>;\ntype mutableNormalizedRootOfKind<kind extends NodeKind> = makeRootAndArrayPropertiesMutable<NormalizedSchema<kind>>;\ntype errorContext<kind extends NodeKind> = Declaration<kind>[\"errorContext\"];\n\ntype ContextualArgs = Record<string, BaseRoot | NodeId>;\ntype BaseParseOptions<prereduced extends boolean = boolean> = {\n    alias?: string;\n    prereduced?: prereduced;\n    args?: ContextualArgs;\n    id?: NodeId;\n};\ninterface BaseParseContextInput extends BaseParseOptions {\n    prefix: string;\n    def: unknown;\n}\ninterface AttachedParseContext {\n    [arkKind]: \"context\";\n    $: BaseScope;\n    id: NodeId;\n    phase: \"unresolved\" | \"resolving\" | \"resolved\";\n}\ninterface BaseParseContext extends BaseParseContextInput, AttachedParseContext {\n    id: NodeId;\n}\ninterface NodeParseContextInput<kind extends NodeKind = NodeKind> extends BaseParseContextInput {\n    kind: kind;\n    def: NormalizedSchema<kind>;\n}\ninterface NodeParseContext<kind extends NodeKind = NodeKind> extends NodeParseContextInput<kind>, AttachedParseContext {\n    id: NodeId;\n}\ndeclare const schemaKindOf: <kind extends RootKind = RootKind>(schema: unknown, allowedKinds?: readonly kind[]) => kind;\ndeclare const writeInvalidSchemaMessage: (schema: unknown) => string;\ntype NodeId = Brand<string, \"NodeId\">;\ntype NodeResolver = (id: NodeId) => BaseNode;\ndeclare const nodesByRegisteredId: Record<NodeId, BaseNode | BaseParseContext | undefined>;\ndeclare const registerNodeId: (prefix: string) => NodeId;\ndeclare const parseNode: (ctx: NodeParseContext) => BaseNode;\ntype CreateNodeInput = {\n    id: NodeId;\n    kind: NodeKind;\n    inner: dict;\n    meta: NodeMeta;\n    $: BaseScope;\n    ignoreCache?: true;\n};\ndeclare const createNode: ({ id, kind, inner, meta, $, ignoreCache }: CreateNodeInput) => BaseNode;\ndeclare const withId: <node extends BaseNode>(node: node, id: NodeId) => node;\ndeclare const withMeta: <node extends BaseNode>(node: node, meta: ArkEnv.meta, id?: NodeId) => node;\n\ninterface ArkSchemaRegistry extends ArkRegistry {\n    intrinsic: typeof intrinsic;\n    config: ArkSchemaConfig;\n    defaultConfig: ResolvedConfig;\n    resolvedConfig: ResolvedConfig;\n    nodesByRegisteredId: typeof nodesByRegisteredId;\n}\ntype nodeConfigForKind<kind extends NodeKind> = Readonly<show<{\n    description?: DescriptionWriter<kind>;\n} & (kind extends ArkErrorCode ? {\n    expected?: ExpectedConfig<kind>;\n    actual?: ActualConfig<kind>;\n    problem?: ProblemConfig<kind>;\n    message?: MessageConfig<kind>;\n} : {})>>;\ntype NodeConfigsByKind = {\n    [kind in NodeKind]: nodeConfigForKind<kind>;\n};\ntype NodeConfig<kind extends NodeKind = NodeKind> = NodeConfigsByKind[kind];\ninterface UnknownErrorConfigs {\n    expected?: ExpectedConfig;\n    actual?: ActualConfig;\n    problem?: ProblemConfig;\n    message?: MessageConfig;\n}\ninterface UnknownNodeConfig extends UnknownErrorConfigs {\n    description?: DescriptionWriter;\n}\ntype ResolvedUnknownNodeConfig = requireKeys<UnknownNodeConfig, \"description\">;\ndeclare const configureSchema: (config: ArkSchemaConfig) => ArkSchemaConfig;\ndeclare const mergeConfigs: <base extends ArkSchemaConfig>(base: base, merged: ArkSchemaConfig | undefined) => base;\ntype MergeToJsonSchemaConfigs = <base extends ToJsonSchema.Options | undefined>(baseConfig: base, mergedConfig: ToJsonSchema.Options | undefined) => base extends ToJsonSchema.Context ? ToJsonSchema.Context : ToJsonSchema.Options;\ndeclare const mergeToJsonSchemaConfigs: MergeToJsonSchemaConfigs;\ntype CloneImplementation = <original extends object>(original: original) => original;\ninterface ArkSchemaConfig extends Partial<Readonly<NodeConfigsByKind>> {\n    readonly jitless?: boolean;\n    readonly clone?: boolean | CloneImplementation;\n    readonly onUndeclaredKey?: UndeclaredKeyBehavior;\n    readonly numberAllowsNaN?: boolean;\n    readonly dateAllowsInvalid?: boolean;\n    readonly exactOptionalPropertyTypes?: boolean;\n    readonly onFail?: ArkErrors.Handler | null;\n    readonly keywords?: Record<string, TypeMeta.Collapsible | undefined>;\n    readonly toJsonSchema?: ToJsonSchema.Options;\n}\ntype resolveConfig<config extends ArkSchemaConfig> = show<{\n    [k in keyof ArkSchemaConfig]-?: k extends NodeKind ? Required<config[k]> : k extends \"clone\" ? CloneImplementation | false : k extends \"keywords\" ? Record<string, TypeMeta | undefined> : k extends \"toJsonSchema\" ? ToJsonSchema.Context : config[k];\n} & Omit<config, keyof ArkSchemaConfig>>;\ntype ResolvedConfig = resolveConfig<ArkSchemaConfig>;\n\ntype InternalNodeIntersection<ctx> = <l extends BaseNode, r extends BaseNode>(l: l, r: r, ctx: ctx) => l[\"kind\"] | r[\"kind\"] extends RootKind ? BaseRoot | Disjoint : BaseNode | Disjoint | null;\ndeclare const intersectNodesRoot: InternalNodeIntersection<BaseScope>;\ndeclare const pipeNodesRoot: InternalNodeIntersection<BaseScope>;\ndeclare const intersectOrPipeNodes: InternalNodeIntersection<IntersectionContext>;\n\nexport { $ark, type ActualConfig, type ActualWriter, After, AfterNode, type AliasDefEntry, ArkError, type ArkErrorCode, type ArkErrorContextInput, type ArkErrorInput, type ArkErrorResult, ArkErrors, type ArkKind, type ArkKinds, type ArkSchemaConfig, type ArkSchemaRegistry, type ArkSchemaScopeConfig, type AttachedParseContext, BaseConstraint, type BaseErrorContext, type BaseMappedPropInner, BaseNode, type BaseNodeDeclaration, type BaseNormalizedSchema, type BaseParseContext, type BaseParseContextInput, type BaseParseOptions, BaseProp, BaseRange, type BaseRangeDeclaration, type BaseRangeInner, BaseRoot, BaseScope, type BasisKind, Before, BeforeNode, type BoundKind, type BoundOperandKind, type Boundable, type BranchTraversal, type CaseContext, type CaseDiscriminant, type CaseKey, type CloneImplementation, type ClosedNodeKind, type CoercibleValue, CompiledFunction, type CompositeKind, type ConditionalTerminalIntersectionRoot, Constraint, type ConstraintIntersection, type ConstraintIntersectionMap, type ConstraintKind, type ContextualArgs, type CreateNodeInput, type CustomErrorInput, type DateRangeKind, type Declaration, type DeepNodeTransformContext, type DeepNodeTransformOptions, type DeepNodeTransformation, type DefaultArkEnv, type DefaultableSequenceElement, type DerivableErrorContext, type DerivableErrorContextInput, type DescriptionWriter, type Discriminant, type DiscriminantKind, type DiscriminantKinds, type DiscriminatedCases, Disjoint, type DisjointEntry, type DisjointEntryContext, type DisjointKind, Divisor, DivisorNode, Domain, DomainNode, ExactLength, ExactLengthNode, type ExclusiveDateRangeSchema, type ExclusiveExpandedDateRangeSchema, type ExclusiveNormalizedNumericRangeSchema, type ExclusiveNumericRangeSchema, type ExpectedConfig, type ExpectedWriter, type FlatRef, type GenericArgResolutions, type GenericAst, type GenericParamAst, type GenericParamDef, GenericRoot, type GenericRootBodyParser, type GenericRootParser, type GettableKeyOrNode, type GlobalOnlyConfigOptionName, type InclusiveDateRangeSchema, type InclusiveExpandedDateRangeSchema, type InclusiveNormalizedNumericRangeSchema, type InclusiveNumericRangeSchema, Index, IndexNode, Inner, type InternalIntersectionOptions, type InternalModule, InternalPrimitiveConstraint, type InternalResolution, type InternalResolutions, type InternalRootDeclaration, type InternalSchemaParser, type InternalTraversal, Intersection, type IntersectionContext, type IntersectionMap, IntersectionNode, type InvokeOptions, JsonSchema, type JsonSchemaOrBoolean, type KeyOrKeyNode, LazyGenericBody, type LengthBoundKind, type LengthBoundableData, type LimitInnerValue, type LimitKind, type LimitSchemaValue, type LimitValue, type ListableJsonSchema, type LowerBoundKind, type LowerNode, type MappedPropInner, Max, MaxLength, MaxLengthNode, MaxNode, type MessageConfig, type MessageContext, type MessageWriter, Min, MinLength, MinLengthNode, MinNode, Morph, type MorphChildKind, MorphNode, type MorphsAtPath, type NarrowedAttachments, NodeCompiler, type NodeConfig, type NodeDeclarationsByKind, type NodeErrorContextInput, type NodeId, type NodeKeyImplementation, type NodeKind, type NodeMeta, type NodeParseContext, type NodeParseContextInput, type NodeResolver, type NodeSchema, NodeSelector, type NormalizedIndex, type NormalizedSchema, type NumericallyBoundable, type OpenNodeKind, Optional, type OptionalMappedPropInner, OptionalNode, type OptionalSequenceElement, type OrderedNodeKinds, Pattern, PatternNode, type PostfixSequenceElement, type PrecompiledReferences, Predicate, PredicateNode, type PrefixSequenceElement, type PreparsedNodeResolution, type Prerequisite, type PrevariadicSequenceElement, type PrimitiveKind, type PrivateDeclaration, type ProblemConfig, type ProblemContext, type ProblemWriter, Prop, type PropFlatMapper, Proto, ProtoNode, type RangeKind, type ReferenceOptions, type RefinementKind, type RegisteredReference, type RelativeComparator, Required$1 as Required, RequiredNode, type ResolvedConfig, type ResolvedScopeConfig, type ResolvedUnknownNodeConfig, type RootExportCache, type RootIntersection, type RootKind, RootModule, type RootSchema, SchemaModule, SchemaScope, type SchemaScopeParser, type ScopeOnlyConfigOptions, Sequence, type SequenceElement, type SequenceElementKind, SequenceNode, type SequenceTuple, type ShouldTransformFn, StandardSchemaV1, type StructuralKind, type StructuralOperationBranchResultByName, type StructuralOperationName, Structure, StructureNode, ToJsonSchema, Traversal, TraversalError, type TraversalKind, type TraversalMethodsByKind, type TraverseAllows, type TraverseApply, type TypeIntersectionMap, TypeMeta, type UndeclaredKeyBehavior, type UndeclaredKeyConfig, type UndeclaredKeyHandling, Union, type UnionChildKind, UnionNode, Unit, UnitNode, type UnknownAttachments, type UnknownErrorConfigs, type UnknownExpandedRangeSchema, type UnknownIntersectionMap, type UnknownIntersectionResult, type UnknownNodeImplementation, type UnknownNormalizedRangeSchema, type UnknownRangeSchema, type UpperBoundKind, type UpperNode, type VariadicSequenceElement, appendUniqueFlatRefs, appendUniqueNodes, arkKind, assertDefaultValueAssignability, assertNodeKind, type attachmentsOf, basisKinds, bindModule, boundKindPairsByLower, type childKindOf, compileComparator, compileLiteralPropAccess, compileObjectLiteral, compileSerializedValue, computeDefaultValueMorph, type conditionalRootOf, configureSchema, constraintKeyParser, constraintKeys, type constraintKindLeftOf, type constraintKindOf, type constraintKindOrLeftOf, constraintKinds, createDateSchemaNormalizer, createLengthRuleParser, createLengthSchemaNormalizer, createNode, dateLimitToString, type declareNode, type defAttachedAs, type defaultErrorContext, defaultValueSerializer, defineSchema, describeBranches, emptyBrandNameMessage, type errorContext, exclusivizeRangeSchema, type exportedNameOf, flatRef, flatRefsAreEqual, type flatResolutionsOf, flattenConstraints, type genericHktToConstraints, genericNode, type genericParamConstraints, type genericParamNames, type genericParamSchemasToAst, type getAssociatedDataForError, hasArkKind, implementNode, indexPropAccess, type innerAttachedAs, type instantiateRoot, type internalImplementationOf, intersectBranches, type intersectConstraintKinds, intersectConstraints, intersectNodesRoot, intersectOrPipeNodes, intersectProps, type intersectRoot, intrinsic, isNode, isNodeKind, type keySchemaDefinitions, type kindLeftOf, type kindOrLeftOf, type kindOrRightOf, type kindRightOf, makeRootAndArrayPropertiesMutable, mergeConfigs, mergeToJsonSchemaConfigs, morphChildKinds, type mutableInnerOfKind, type mutableNormalizedRootOfKind, node, nodeClassesByKind, type nodeImplementationInputOf, type nodeImplementationOf, nodeImplementationsByKind, nodeKinds, type nodeOfKind, nodesByRegisteredId, normalizeIndex, type ownIntersectionResult, type pairedRangeKind, parseAsSchema, parseDateLimit, parseExclusiveKey, parseGeneric, parseNode, pipeNodesRoot, postfixAfterOptionalOrDefaultableMessage, postfixWithoutVariadicMessage, precedenceByKind, precedenceOfKind, pruneDiscriminant, reduceBranches, type reducibleKindOf, reference, refinementKinds, registerNodeId, registeredReference, registryName, type resolvableReferenceIn, type resolveConfig, type resolveReference, rootKinds, rootSchema, rootSchemaScope, schemaKindOf, type schemaKindOrRightOf, type schemaKindRightOf, schemaKindsRightOf, schemaScope, serializeLiteralKey, structuralKinds, structureKeys, throwInvalidOperandError, type toInternalScope, traverseKey, typeKeyToString, typeOrTermExtends, typePathToPropString, unflattenConstraints, unionChildKinds, type unwrapDefault, withId, withMeta, writeDefaultIntersectionMessage, writeDuplicateAliasError, writeEnumerableIndexBranches, writeIndiscriminableMorphMessage, writeIndivisibleMessage, writeInvalidKeysMessage, writeInvalidLengthBoundMessage, writeInvalidOperandMessage, writeInvalidPropertyKeyMessage, writeInvalidSchemaMessage, writeLiteralUnionEntriesMessage, writeMissingSubmoduleAccessMessage, writeMorphIntersectionMessage, writeNonIntegerDivisorMessage, writeNonPrimitiveNonFunctionDefaultValueMessage, writeNonStructuralOperandMessage, writeNonSubmoduleDotMessage, writeNumberIndexMessage, writeOrderedIntersectionMessage, type writeUnassignableDefaultValueMessage, writeUnboundableMessage, writeUnresolvableMessage, writeUnsatisfiableExpressionError, writeUnsatisfiedParameterConstraintMessage };\n\n}"
