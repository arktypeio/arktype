# How to use this beaut

Creating a simple string schema

```ts
import { type } from "arktype"

const stringData = type("string")

// throws on error
stringData.assert("Arktype") // "Arktype"
stringData.assert({}) // throws ArktypeError

// returns {problems?, data}
stringData.check("Arktype") //{data: "Arktype"}
stringData.check({}) //{problems: ArktypeError, data: }
```

## Creating an object schema

```ts
import { type } from "arktype"

// Define a type...
export const user = type({
    name: "string",
    yearsOfExperience: "number"
})

type User = typeof user.infer
//  {
//      name: string;
//      yearsOfExperience: number;
//  }

user.check({
    name: "David",
    yearsOfExperience: 69
})
// { name: 'David', age: 69 }
```

## Optional keys

```ts
import { type } from "arktype"
// Maybe we don't care about how long David has been programming
export const user = type({ name: "string", "yearsOfExperience?": "number" })

type User = typeof user.infer
//  {
//      name: string;
//      yearsOfExperience?: number;
//  }

user.check({
    name: "David"
})
// { name: 'David'}
```

## Constraints

Looking to constrain your data?

```ts
import { type } from "arktype"

// single bound
type("number<5")
type("number<=5")
type("number>5")
type("number>=5")

//double bound
type("2<number<5")
type("2<=number<=5")

// These bounds can also be applied to 'string'
```

## Custom Errors

We try to write clear and concise error messages but we can't adhere to everyone so we give you the ability to write your own :)
assuming this gets reimplemented

```ts
import { type } from "arktype"
// Solid default errors
const gte3 = type("string>=3")
gte3.check("no").errors.message
// '"no" must be greater than or equal to 3 characters (was 2).'

// You want to provide a custom error message?
type("3<number<5").check(0, {
    diagnostics: {
        BoundViolation: {
            message: ({ data, comparator, limit }) =>
                `${data} not ${comparator}${limit}`
        }
    }
})
// "0 not >3"
```

## Fan of Tuples?

```ts
import { type } from "arktype"

const tupleSchema = type(["string", "number", "string"])
tupleSchema.check(["EZ", 69, "MOOCHI"])
// { data: [ 'EZ', 69, 'MOOCHI' ] }
```

## Intersections and Unions

```ts
const union = type("string|number")
typeof union // string|number

const intersection = type("string&number")
typeof intersection // never
```

## Escape Characters

```ts
import { type } from "arktype"

// Sometimes you want to have a question mark in your key
const questionableKey = type({ "questionable\\?": "boolean" })
// questionableKey.root
// object: {
// props: { required: { "a?": "string" } }
// }
questionableKey.check({ "questionable?": true })
```

## Cyclic Data

We handle those cycles with ease! Cycle away!

<TOCInline toc={toc} />
